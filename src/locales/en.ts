// English translations
export default {
  common: {
    copy: 'Copy',
    generate: 'Generate',
    calculate: 'Calculate',
    parse: 'Parse',
    clear: 'Clear',
    copied: 'Copied to clipboard!',
    copyFailed: 'Failed to copy',
    error: 'Error',
    result: 'Result',
    loading: 'Loading...',
    close: 'Close',
    cancel: 'Cancel',
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: 'Key Gen',
    tr31: 'TR-31',
    kcv: 'KCV Calc',
    pinBlock: 'PIN Block',
    asn1: 'ASN.1',
    cipher: 'Cipher',
    generic: 'Generic',
    hashes: 'Hashes',
    characterEncoding: 'Character Encoding',
    bcd: 'BCD',
    checkDigits: 'Check Digits',
    base64: 'Base64',
    base94: 'Base94',
    messageParser: 'Message Parser',
    rsaDerPublicKey: 'RSA DER Public Key',
    uuid: 'UUID',
    // PKI 菜单
    pki: 'PKI',
    asn1Decoder: 'ASN.1 Decoder',
    sslCertificates: 'SSL Certificates',
    // Keys 菜单
    keys: 'Keys',
    keysDea: 'Keys DEA',
    keyshareGenerator: 'Keyshare Generator',
    keysHsm: 'Keys HSM',
    keysFuturex: 'Keys Futurex',
    keysAtalla: 'Keys Atalla',
    keysSafeNet: 'Keys SafeNet',
    keysThales: 'Keys Thales',
    keyBlocks: 'Key Blocks',
    thalesKeyBlock: 'Thales Key Block',
    tr31KeyBlock: 'TR-31 Key Block',
    // Payments 菜单
    payments: 'Payments',
    as2805: 'AS2805',
    bitmap: 'Bitmap',
    cardValidation: 'Card Validation',
    cvvs: 'CVVs',
    amexCscs: 'AMEX CSCs',
    mastercardCvc3: 'MasterCard dynamic CVC3',
    dukpt: 'DUKPT',
    dukptIso9797: 'DUKPT (ISO 9797)',
    dukptAes: 'DUKPT (AES)',
    macAlgorithms: 'MAC Algorithms',
    iso9797_1: 'ISO/IEC 9797-1',
    ansix9: 'ANSI X9.9 & X9.19',
    as2805_4_1: 'AS2805.4.1',
    tdesCbcMac: 'TDES CBC-MAC',
    hmac: 'HMAC',
    cmac: 'CMAC',
    retail: 'Retail',
    pinBlocks: 'PIN Blocks',
    pinBlocksGeneral: 'PIN Blocks General',
    pinBlocksAes: 'PIN Blocks AES',
    pinOffset: 'PIN Offset',
    pinPvv: 'PIN PVV',
    visaCertificates: 'Visa Certificates',
    zka: 'ZKA',
  },
  
  footer: {
    tagline: 'Browser-based Security Calculation Tools',
    privacyPolicy: 'Privacy Policy',
    termsOfService: 'Terms of Service',
    disclaimer: 'Disclaimer',
    contact: 'Contact & Feedback',
  },

  privacyPolicy: {
    seoTitle: 'Privacy Policy | HSM Kit',
    seoDescription: 'Privacy Policy for HSM Kit - Learn how we handle your data with client-side processing.',
    seoKeywords: 'privacy policy, data protection, client-side processing, HSM Kit',
    title: 'Privacy Policy',
    introTitle: 'Introduction',
    introContent: 'At HSM Kit, we take your security and privacy seriously. This Privacy Policy outlines how we handle data when you use our online cryptographic tools.',
    clientSideTitle: 'Client-Side Processing',
    clientSideContent: 'We do not collect, store, or transmit your input data. All cryptographic operations (encryption, decryption, hashing, key formatting) are performed entirely within your web browser using JavaScript. Your keys, PINs, and data never leave your device and are never sent to our servers.',
    dataCollectionTitle: 'Data Collection',
    dataCollectionContent: 'We do not track or store any personal information.',
    analyticsTitle: 'Usage Analytics',
    analyticsContent: 'We may use anonymous analytics tools (e.g., Google Analytics) to track page views and site performance. These tools do not have access to the data you input into the calculation forms.',
    localStorageTitle: 'Local Storage',
    localStorageContent: 'We may use your browser\'s Local Storage to save your interface preferences (such as Dark Mode settings). This data is stored on your device and is not transmitted to us.',
    thirdPartyTitle: 'Third-Party Services',
    thirdPartyContent: 'Our website is hosted on a public cloud provider. While we do not collect data, standard server logs (IP addresses, user agents) may be processed by the hosting provider for security and maintenance purposes.',
    changesTitle: 'Changes to This Policy',
    changesContent: 'We may update this Privacy Policy from time to time. We encourage you to review this page periodically for any changes.',
    lastUpdated: 'Last updated',
    lastUpdatedDate: 'January {year}',
    backToHome: 'Back to Home',
    contactTitle: 'Contact Us',
    contactContent: 'If you have any questions about this Privacy Policy, please contact us at ',
  },

  termsOfService: {
    seoTitle: 'Terms of Service | HSM Kit',
    seoDescription: 'Terms of Service for HSM Kit - Read our terms and conditions for using our cryptographic tools.',
    seoKeywords: 'terms of service, terms and conditions, user agreement, HSM Kit',
    title: 'Terms of Service',
    acceptanceTitle: '1. Acceptance of Terms',
    acceptanceContent: 'By accessing and using HSM Kit (hsmkit.com), you accept and agree to be bound by the terms and provision of this agreement. If you do not agree to abide by these terms, please do not use this website.',
    useOfServiceTitle: '2. Use of Service',
    useOfServiceIntro: 'HSM Kit provides online cryptographic tools for developers and security professionals.',
    licenseTitle: 'License',
    licenseContent: 'We grant you a limited, non-exclusive, non-transferable license to use the tools for personal, educational, and professional testing purposes.',
    restrictionsTitle: 'Restrictions',
    restrictionsContent: 'You agree not to misuse the services. This includes, but is not limited to:',
    restriction1: 'Attempting to interfere with the proper working of the website (e.g., DDoS attacks).',
    restriction2: 'Using any automated systems (robots, spiders) to access the website without our permission.',
    restriction3: 'Using the tools for any illegal activities or to facilitate malicious acts.',
    intellectualPropertyTitle: '3. Intellectual Property',
    intellectualPropertyContent: 'The content, layout, design, data, databases, and graphics on this website are protected by intellectual property laws and are owned by HSM Kit, unless otherwise stated. You may not reproduce, duplicate, copy, sell, or exploit any portion of the service without express written permission from us.',
    disclaimerTitle: '4. Disclaimer of Warranties',
    disclaimerContent: 'The tools are provided on an "AS IS" and "AS AVAILABLE" basis. HSM Kit makes no representations or warranties of any kind, express or implied, regarding the accuracy, reliability, or completeness of the calculations.',
    limitationTitle: '5. Limitation of Liability',
    limitationContent: 'In no event shall HSM Kit or its operators be liable for any direct, indirect, incidental, special, or consequential damages arising out of or in any way connected with the use of this website. This includes, but is not limited to, loss of data, loss of profits, or business interruption.',
    changesTitle: '6. Changes to Terms',
    changesContent: 'We reserve the right to modify these terms at any time. Your continued use of the website following any changes signifies your acceptance of the new terms.',
    lastUpdated: 'Last updated',
    lastUpdatedDate: 'January {year}',
    backToHome: 'Back to Home',
    contactTitle: 'Contact Us',
    contactContent: 'If you have any questions about these Terms of Service, please contact us at ',
  },

  disclaimer: {
    seoTitle: 'Disclaimer | HSM Kit',
    seoDescription: 'Legal disclaimer for HSM Kit - Important information about using our cryptographic tools.',
    seoKeywords: 'disclaimer, legal notice, terms of use, HSM Kit',
    title: 'Disclaimer',
    generalTitle: 'General Disclaimer',
    generalContent: 'The tools and information provided on HSM Kit are for educational, testing, and development purposes only. While we strive to ensure the accuracy of the algorithms and calculations, the software is provided "AS IS", without warranty of any kind, express or implied.',
    noLiabilityTitle: 'No Liability',
    noLiabilityContent: 'In no event shall the authors or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the software or the use or other dealings in the software.',
    securityTitle: 'Security Warning',
    securityContent: 'Do NOT use real production keys, sensitive financial data, or live personal information on this website. Although all calculations are performed client-side, it is a best practice in the security industry never to expose live cryptographic material in a browser environment.',
    securityWarningTitle: 'Important Security Notice',
    securityWarningContent: 'Never use real production keys, sensitive data, or live credentials on this website. This tool is for educational and testing purposes only.',
    complianceTitle: 'Compliance',
    complianceContent: 'Users are responsible for ensuring that their use of these tools complies with all applicable local, state, and federal laws and regulations.',
    lastUpdated: 'Last updated',
    lastUpdatedDate: 'January {year}',
    backToHome: 'Back to Home',
    contactTitle: 'Contact Us',
    contactContent: 'If you have any questions about this Disclaimer, please contact us at ',
  },

  home: {
    heroTitle: 'Free Online Encryption & Key Management Tools',
    heroDescription: 'A comprehensive suite of cryptographic tools for security professionals. All calculations are performed client-side in your browser — your data never leaves your device.',
    searchPlaceholder: 'Search tools... (e.g., MD5, AES, PIN Block)',
    availableTools: 'Most Popular Tools',
    gridView: 'Grid View',
    listView: 'List View',
    whyChoose: 'Why Choose HSM Kit?',
    categories: {
      all: 'All',
      symmetric: 'Symmetric',
      asymmetric: 'Asymmetric',
      payment: 'Payment',
      encoding: 'Encoding',
      hashing: 'Hashing',
    },
    // Tool cards
    tools: {
      asn1: {
        title: 'ASN.1 Parser',
        description: 'Parse and analyze ASN.1 DER/BER structures, decode X.509 certificates and PKCS formats.',
      },
      aes: {
        title: 'AES Encryption',
        description: 'Encrypt and decrypt data using AES-128/192/256 with ECB, CBC, CFB, OFB, CTR modes.',
      },
      des: {
        title: 'DES/3DES Encryption',
        description: 'DES and Triple DES encryption with multiple padding options for legacy systems.',
      },
      rsa: {
        title: 'RSA Encryption',
        description: 'RSA asymmetric encryption, decryption, digital signing and verification.',
      },
      ecc: {
        title: 'ECC/ECDSA',
        description: 'Elliptic Curve Cryptography for compact keys and efficient digital signatures.',
      },
      fpe: {
        title: 'Format-Preserving Encryption',
        description: 'FPE (FF1/FF3-1) for encrypting data while preserving format and length.',
      },
      keyGenerator: {
        title: 'Key Generator',
        description: 'Generate secure random keys for AES, DES, 3DES. Key combination and parity tools.',
      },
      tr31: {
        title: 'TR-31 Key Block',
        description: 'Encode and decode TR-31/ANSI X9.143 key blocks with KBPK protection. Supports TDES and AES versions.',
      },
      kcv: {
        title: 'KCV Calculator',
        description: 'Calculate Key Check Value (KCV) for AES and DES/3DES keys verification.',
      },
      pinBlock: {
        title: 'PIN Block Generator',
        description: 'Generate ISO 9564 PIN Blocks (Format 0, 1, 3, 4) for payment transactions.',
      },
      pinBlockGeneral: {
        title: 'PIN Blocks General',
        description: 'Encode and decode PIN Blocks in all ISO 9564 formats (0, 1, 2, 3, 4) with PAN.',
      },
      pinBlockAes: {
        title: 'PIN Blocks AES',
        description: 'AES-128 encryption/decryption of ISO 9564 Format 4 PIN Blocks with 32 hex output.',
      },
      pinOffset: {
        title: 'PIN Offset',
        description: 'Calculate and verify PIN offset using IBM 3624 method with validation data.',
      },
      pinPvv: {
        title: 'PIN PVV',
        description: 'Visa PIN Verification Value (PVV) calculation and PIN verification with PDK/PVKI.',
      },
      as2805: {
        title: 'AS2805 Message Tools',
        description: 'Australian ISO 8583 payment tools with key generation, PIN block translation, and MAC calculation.',
      },
      ansiMac: {
        title: 'ANSI MAC (X9.9 & X9.19)',
        description: 'ANSI X9.9/X9.19 MAC with DES CBC-MAC or 3DES encryption.',
      },
      as2805Mac: {
        title: 'AS2805 MAC',
        description: 'AS2805.4.1 MAC for Australian EFTPOS with Method 1 and Method 2.',
      },
      tdesCbcMac: {
        title: 'TDES CBC-MAC',
        description: 'Triple DES CBC-MAC with 2-key/3-key TDES and ISO 9797-1 padding.',
      },
      hmac: {
        title: 'HMAC',
        description: 'Hash-based MAC using SHA-256/SHA-512 for API authentication and data integrity.',
      },
      cmac: {
        title: 'CMAC',
        description: 'NIST SP 800-38B cipher-based MAC with AES/TDES and CMAC-96.',
      },
      retailMac: {
        title: 'Retail MAC',
        description: 'ISO 9797-1 Method 2 Retail MAC with DES/3DES for POS and ATM systems.',
      },
      iso9797: {
        title: 'ISO 9797-1 MAC',
        description: 'ISO/IEC 9797-1 MAC calculator with algorithms 1-6 and multiple padding methods.',
      },
      visaCertificates: {
        title: 'VISA Certificates',
        description: 'Validate VISA issuer certificates with VSDC CA V92/V94 and custom CA keys.',
      },
      zka: {
        title: 'ZKA',
        description: 'German banking standard with session key derivation, PIN encryption, and MAC calculation.',
      },
      bitmap: {
        title: 'ISO8583 Bitmap',
        description: 'Encode and decode ISO 8583 bitmaps for payment messages. Primary and secondary bitmaps supported.',
      },
      cvv: {
        title: 'CVV/CVC',
        description: 'Generate and validate CVV, iCVV, CVV2, dCVV for card verification and payment security.',
      },
      amexCsc: {
        title: 'AMEX CSC',
        description: 'Generate and validate AMEX Card Security Codes (CSC-5, CSC-4, CSC-3) for American Express.',
      },
      mastercardCvc3: {
        title: 'MasterCard CVC3',
        description: 'Generate dynamic CVC3 for MasterCard contactless EMV transactions.',
      },
      // Generic Tools
      hash: {
        title: 'Hash Calculator',
        description: 'Calculate hash values using MD5, SHA-1, SHA-256, SHA-512, BLAKE2, and more algorithms.',
      },
      encoding: {
        title: 'Character Encoding',
        description: 'Convert between ASCII, EBCDIC, Hexadecimal, Binary, and ATM Decimal formats.',
      },
      bcd: {
        title: 'BCD Encoder/Decoder',
        description: 'Encode decimal to BCD or decode BCD back to decimal format.',
      },
      checkDigits: {
        title: 'Check Digits',
        description: 'Calculate and verify check digits using Luhn (MOD 10) and MOD 9 algorithms.',
      },
      base64: {
        title: 'Base64',
        description: 'Encode and decode data using Base64 binary-to-text encoding.',
      },
      base94: {
        title: 'Base94',
        description: 'Compact encoding using all 94 printable ASCII characters.',
      },
      messageParser: {
        title: 'Message Parser',
        description: 'Parse ATM NDC, Wincor, and ISO 8583 financial message formats.',
      },
      dukpt: {
        title: 'DUKPT (ISO 9797)',
        description: 'Derive PEK from BDK/IPEK and KSN. Encrypt/decrypt PIN, calculate MAC, process data.',
      },
      dukptAes: {
        title: 'DUKPT (AES)',
        description: 'DUKPT with AES support (2TDEA, 3TDEA, AES-128/192/256). Derive working keys and process data.',
      },
      rsaDer: {
        title: 'RSA DER Public Key',
        description: 'Encode/decode RSA public keys between modulus/exponent and DER format.',
      },
      uuid: {
        title: 'UUID Generator',
        description: 'Generate universally unique identifiers (UUID v1, v3, v4, v5).',
      },
      // Keys HSM Tools
      keyshareGenerator: {
        title: 'Keyshare Generator',
        description: 'Generate key shares for secure key splitting and component management with KCV.',
      },
      futurexKeys: {
        title: 'Futurex Keys',
        description: 'Futurex HSM key encryption, decryption and lookup with multiple variants.',
      },
      atallaKeys: {
        title: 'Atalla Keys (AKB)',
        description: 'Atalla AKB format key encryption and decryption with MFK and MAC verification.',
      },
      safeNetKeys: {
        title: 'SafeNet Keys',
        description: 'SafeNet HSM key encryption, decryption and lookup with KM key variants.',
      },
      thalesKeys: {
        title: 'Thales Keys',
        description: 'Thales HSM LMK key encryption, decryption and lookup with variants.',
      },
      thalesKeyBlock: {
        title: 'Thales Key Block',
        description: 'Encode and decode Thales proprietary key blocks with KBPK protection.',
      },
      sslCert: {
        title: 'SSL Certificates',
        description: 'Generate RSA keys, create CSRs, self-signed X.509 certificates, and parse certificates.',
      },
    },
    // Features
    features: {
      clientSide: {
        title: '100% Browser-Based',
        description: 'All cryptographic operations run entirely in your browser. Your keys, PINs, and sensitive data never leave your device.',
      },
      free: {
        title: 'Free & Open',
        description: 'All 44+ tools are completely free. No registration, no login, no hidden costs. Use instantly.',
      },
      paymentReady: {
        title: 'HSM & Payment Ready',
        description: 'Professional tools for Thales, Futurex, Atalla, SafeNet HSMs. TR-31, KCV, PIN Block and more.',
      },
    },
  },
  
  asn1: {
    title: 'ASN.1 Parser',
    description: 'Parse and analyze ASN.1 DER/BER structures with RFC definition matching',
    infoTitle: 'About ASN.1 Parser',
    infoContent1: 'Parse ASN.1 DER/BER encoded data structures',
    infoContent2: 'Supports Hex, Base64, and PEM input formats',
    infoContent3: 'Enable RFC definitions to match known structures like X.509, PKCS',
    inputLabel: 'Input (Hex, Base64, or PEM):',
    inputPlaceholder: 'Paste hex, base64 or PEM encoded ASN.1 BER/DER structures, or upload a file',
    withHexDump: 'with hex dump',
    trimBigChunks: 'trim big chunks',
    withDefinitions: 'with definitions',
    uploadFile: 'Upload File',
    parse: 'Parse',
    clear: 'Clear',
    structureDefinition: 'Structure Definition:',
    selectDefinition: 'Select structure definition...',
    parsedResult: 'Parsed Result:',
    hexDump: 'Hex Dump:',
    offset: 'Offset',
    length: 'Length',
    value: 'Value',
    constructed: 'constructed',
    loadError: 'ASN.1 library failed to load',
    inputRequired: 'Please enter ASN.1 data',
    parseError: 'Parse failed',
    copied: 'Copied',
    copyHex: 'Copy Hex',
    copyHexDump: 'Copy hex dump',
    copyBase64: 'Copy Base64',
    copySubtree: 'Copy subtree',
    copyValue: 'Copy value',
  },
  
  keyGenerator: {
    title: 'Random Key Generator',
    description: 'Generate cryptographically strong random keys for DES, 3DES, or AES.',
    infoTitle: 'About Key Generator',
    infoContent1: 'Generate cryptographically secure random keys using Web Crypto API',
    infoContent2: 'Supports DES (8 bytes), 3DES (16/24 bytes), and AES (16/24/32 bytes)',
    infoContent3: 'KCV (Key Check Value) is calculated for key verification',
    keyLength: 'Key Length',
    bytes: 'Bytes',
    bits: 'bits',
    generateNow: 'Generate Now',
    generatedKey: 'GENERATED KEY (HEX)',
    kcv: 'KCV',
    length: 'Length',
    
    // Tabs
    tabKeyGen: 'Key Generator',
    tabCombination: 'Key Combination',
    tabParity: 'Parity Enforcement',
    tabValidation: 'Key Validation',
    
    // Key Combination
    combinationTitle: 'Key Component Combination',
    combinationDesc: 'XOR multiple key components to form a complete key',
    component: 'Component',
    components: 'components',
    combinedKey: 'Combined Key',
    addComponent: 'Add Component',
    removeComponent: 'Remove Component',
    combineKeys: 'Combine Keys',
    errorInvalidComponent: 'Component {index} is invalid',
    errorComponentLength: 'All components must have the same length',
    errorComponentLength2: 'Length must be',
    errorMinComponents: 'At least 2 components required',
    errorMaxComponents: 'Maximum 9 components allowed',
    clearAll: 'Clear All',
    
    // Parity Enforcement
    parityTitle: 'Key Parity Adjustment',
    parityDesc: 'Adjust parity bits for DES/3DES keys',
    keyInput: 'Key Input',
    keyInputPlaceholder: 'Enter hexadecimal key',
    parityType: 'Parity Type',
    odd: 'Odd',
    even: 'Even',
    adjustParity: 'Adjust Parity',
    adjustedKey: 'Adjusted Key',
    
    // Key Validation
    validationTitle: 'Key Validity Check',
    validationDesc: 'Check key format, length and parity',
    validateKey: 'Validate Key',
    validKey: 'Valid Key',
    invalidKey: 'Invalid Key',
    keyType: 'Key Type',
    parityStatus: 'Parity Status',
    parityValid: 'Valid',
    parityInvalid: 'Invalid',
  },
  
  kcvCalculator: {
    title: 'KCV Calculator',
    description: 'Calculate Key Check Value to verify key correctness.',
    algorithm: 'Algorithm',
    keyInput: 'Key (Hexadecimal)',
    keyPlaceholder: 'e.g., 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'Calculate KCV',
    keyCheckValue: 'Key Check Value',
    errorInvalidHex: 'Key must be valid hexadecimal characters',
    errorDesLength: 'DES/3DES key length must be 8, 16 or 24 bytes',
    errorAesLength: 'AES key length must be 16, 24 or 32 bytes',
    errorCalculation: 'Calculation failed, please check key format',
    format: 'Format',
    autoAdjustParity: 'Auto-adjust Parity Bits',
    parityAdjustmentHint: 'Some keys may not have correct parity bits set, check this option to auto-correct',
    kcvCalcTitle: 'Key Check Value Calculation',
    desCalcDesc: 'Use the plaintext of the key to encrypt 16 characters long \'0\' with the 3DES-ECB algorithm, then intercept the first six characters of the encrypted value as the key check value',
    aesCalcDesc: 'Use the plaintext of the key to encrypt 32 characters long \'0\' with the CMAC-AES algorithm, then intercept the first six characters of the encrypted value as the key check value',
  },
  
  pinBlock: {
    title: 'PIN Block Generator',
    description: 'Generate ISO format PIN Block for payment transactions.',
    format: 'PIN Block Format',
    pinLabel: 'PIN (4-12 digits)',
    pinPlaceholder: 'e.g., 1234',
    panLabel: 'PAN (Primary Account Number)',
    panPlaceholder: 'e.g., 4111111111111111',
    generatePinBlock: 'Generate PIN Block',
    pinBlockHex: 'PIN Block (Hexadecimal)',
    errorInvalidPin: 'PIN must be 4-12 digits',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorGeneration: 'Generation failed, please check input',
    errorFormat1: 'ISO Format 1 coming soon...',
    pinLengthHint: 'Supports 4-12 digit PIN',
    panHint: 'Enter complete card number (13-19 digits), system will automatically extract rightmost 12 digits (excluding check digit)',
  },

  pinBlockGeneral: {
    title: 'PIN Blocks',
    infoTitle: 'About PIN Blocks',
    info1: 'ISO 9564 defines PIN block formats for secure PIN transmission in payment systems.',
    info2: 'Format 0: XOR with PAN (most common). Format 1: No PAN required (random padding).',
    info3: 'Formats 2-4: Enhanced security with different PAN encoding and random padding schemes.',
    formatLabel: 'PIN block format:',
    encode: 'Encode',
    decode: 'Decode',
    panLabel: 'PAN:',
    panPlaceholder: '456789012345cccc',
    pinLabel: 'PIN:',
    pinPlaceholder: '123456',
    pinBlockLabel: 'PIN Block:',
    pinBlockPlaceholder: '041226FFFFFFFF1234',
    paddingLabel: 'Padding character:',
    paddingHint: 'Single hex digit (0-9, A-F). Default: F',
    encodeButton: 'Encode',
    decodeButton: 'Decode',
    resultPinBlock: 'PIN Block (Hex)',
    resultPin: 'Decoded PIN',
    format: 'Format',
    length: 'Length',
    hexChars: 'hex chars',
    pinLength: 'PIN Length',
    errorInvalidPin: 'PIN must be 4-12 digits',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorInvalidPinBlock: 'Invalid PIN Block length',
    errorInvalidFormat: 'Invalid PIN Block format',
    errorInvalidPinLength: 'Invalid PIN length in block',
    errorProcessing: 'Processing failed, please check input',
  },

  pinBlockAes: {
    title: 'AES PIN Block Format 4',
    infoTitle: 'About AES PIN Block',
    info1: 'PIN Block Format 4 is designed specifically for AES encryption with 128-bit block size.',
    info2: 'Unlike older formats, Format 4 uses a 32 hex character block (16 bytes) suitable for AES.',
    info3: 'The PIN block is XORed with the PAN block before AES encryption for enhanced security.',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    keyLabel: 'Key:',
    keyPlaceholder: 'C1D0F8FB4958670DBA40AB1F3752EF0D',
    keyHint: 'AES-128 key: 32 hex characters (16 bytes)',
    panLabel: 'PAN/PAN Block:',
    panPlaceholder: '6432198765432109870',
    pinLabel: 'PIN/PIN Block:',
    pinPlaceholder: '441234',
    encryptedBlockLabel: 'Encrypted PIN Block:',
    encryptedBlockPlaceholder: 'Enter encrypted PIN block (32 hex chars)',
    encryptButton: 'Encrypt',
    decryptButton: 'Decrypt',
    resultEncrypted: 'Encrypted PIN Block',
    resultDecrypted: 'Decrypted PIN',
    clearPinBlock: 'Clear PIN Block:',
    panBlockUsed: 'PAN Block (used in XOR):',
    format: 'Format',
    algorithm: 'Algorithm',
    pinLength: 'PIN Length',
    errorInvalidPin: 'PIN must be 4-12 digits',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorInvalidKey: 'AES key must be 32 hex characters (16 bytes)',
    errorInvalidBlock: 'Block must be 32 hex characters',
    errorInvalidFormat: 'Invalid PIN Block format (not Format 4)',
    errorInvalidPinLength: 'Invalid PIN length in block',
    errorEncryption: 'Encryption failed',
    errorDecryption: 'Decryption failed',
    errorProcessing: 'Processing failed, please check input',
  },

  pinOffset: {
    title: 'PIN offset (IBM 3624 Method)',
    infoTitle: 'About PIN Offset',
    info1: 'IBM 3624 method calculates PIN offset using 3DES encryption with PDK and decimalization table.',
    info2: 'The offset is calculated as (Customer PIN - Natural PIN) mod 10.',
    info3: 'Validation data can be extracted using parameters or a mask pattern for flexible PIN verification.',
    tabOffset: 'Offset',
    tabPin: 'PIN',
    pdkLabel: 'PDK:',
    pdkPlaceholder: '0123456789ABCDEFFEDCBA9876543210',
    panLabel: 'PAN:',
    panPlaceholder: '1234567899876543',
    pinLabel: 'PIN:',
    pinPlaceholder: '3196',
    offsetLabel: 'PIN offset:',
    offsetPlaceholder: '0000',
    decTabLabel: 'DecTab:',
    validationDataLabel: 'Validation data',
    useParameters: 'Use validation data parameters',
    useMask: 'Use validation data mask',
    startLabel: 'Start:',
    lengthLabel: 'Length:',
    padLabel: 'Pad:',
    pinLengthLabel: 'PIN Length:',
    validationMaskLabel: 'Validation data mask:',
    maskHint: 'Use N for natural PIN digits, 0-9 for fixed values',
    calculateOffset: 'Calculate Offset',
    calculatePin: 'Calculate PIN',
    offsetResult: 'PIN Offset',
    pinResult: 'Calculated PIN',
    errorInvalidPdk: 'PDK must be 32 hex characters (16 bytes)',
    errorInvalidPan: 'PAN must be 12-19 digits',
    errorInvalidPin: 'PIN must be 4-12 digits',
    errorInvalidOffset: 'PIN offset must be 4-12 digits',
    errorInvalidDecTab: 'DecTab must be 16 digits',
    errorInvalidMask: 'Validation mask must contain only digits and N',
    errorProcessing: 'Processing failed, please check input',
  },
  pinPvv: {
    title: 'PIN PVV Calculator',
    infoTitle: 'About PIN PVV',
    info1: 'PIN Verification Value (PVV) is a Visa standard for PIN verification. It uses a PIN Derivation Key (PDK) to encrypt the card number (PAN), applies decimalization, and calculates a 4-digit verification value.',
    info2: 'The PVV tab calculates the PVV from a PIN. The PIN tab verifies a PIN by calculating it from a known PVV.',
    info3: 'PVKI (PIN Verification Key Index) determines which position in the encrypted result to use for verification.',
    tabPvv: 'PVV',
    tabPin: 'PIN',
    pdkLabel: 'PDK',
    panLabel: 'PAN',
    pinLabel: 'PIN',
    pvvLabel: 'PVV',
    pvkiLabel: 'PVKI',
    pdkHint: '32 hex characters (16 bytes) - PIN Derivation Key',
    panHint: '12-19 digits - Primary Account Number',
    pinHint: '4-12 digits - Customer PIN',
    pvvHint: '4 digits - PIN Verification Value',
    pvkiHint: '0-9 - PIN Verification Key Index',
    calculatePvv: 'Calculate PVV',
    calculatePin: 'Calculate PIN',
    pvvResult: 'PVV',
    pinResult: 'PIN',
    encryptedPan: 'Encrypted PAN',
    tsp: 'TSP (Transformed Selection)',
    pvvCalculated: 'PVV calculated successfully',
    pinCalculated: 'PIN calculated successfully',
    copied: 'copied to clipboard',
    errorInvalidPdk: 'PDK must be 32 hex characters',
    errorInvalidPan: 'PAN must be 12-19 digits',
    errorInvalidPin: 'PIN must be 4-12 digits',
    errorInvalidPvv: 'PVV must be 4 digits',
    errorProcessing: 'Error processing calculation',
  },
  
  bitmap: {
    title: 'ISO8583 Bitmap',
    description: 'Parse bitmap (hexadecimal data) into bits and construct a bitmap back from binary data provided.',
    bitmapLabel: 'Bitmap',
    bitmapPlaceholder: 'e.g., B0300054020000000000000010000001',
    bitmapHint: 'Enter hexadecimal bitmap or select bits below. Bit 1 indicates secondary bitmap presence (ISO8583 standard).',
    primaryBitmap: 'Primary Bitmap',
    secondaryBitmap: 'Secondary Bitmap',
    bits: 'Bits',
    copySuccess: 'Copied to clipboard',
    copyError: 'Failed to copy',
    errorNoBitmap: 'Please enter or generate a bitmap',
    errorInvalidHex: 'Invalid hexadecimal input',
    infoTitle: 'About ISO8583 Bitmap',
    info1: 'ISO 8583 bitmap indicates which data fields are present in the message.',
    info2: 'Primary bitmap (64 bits) covers fields 1-64. If bit 1 is set, secondary bitmap (65-128) is present.',
    info3: 'Each bit position corresponds to a data field number in the ISO8583 message.',
  },

  visaCertificates: {
    title: 'VISA Certificates Validator',
    infoTitle: 'About VISA Certificates',
    info1: 'Validate issuer certificate signing requests and verify signed public key data',
    info2: 'Supports VSDC CA V92, V94, or custom CA keys',
    description: 'Validate and verify VISA issuer certificates for EMV payment cards',
    tabRequest: 'Validate Issuer Signing Request',
    tabSigned: 'Validate Signed Issuer Public Key Data',
    loadRequestFile: 'Load Issuer Certificate Request File ...',
    loadSignedFile: 'Load Signed Issuer Public Key Data File ...',
    loadCaFile: 'Load CA Public Key File ...',
    debug: 'Debug',
    requestDataLabel: 'Issuer Certificate Request Data:',
    signedDataLabel: 'Signed Issuer Public Key Data:',
    caKeyLabel: 'CA Public Key:',
    requestDataPlaceholder: 'Enter hex data (e.g., 22B0E1D3EC02...)',
    signedDataPlaceholder: 'Enter hex data (e.g., 2410100000004455...)',
    caKeyPlaceholder: 'CA public key will be loaded automatically or enter manually',
    validate: 'Validate',
    validationSuccess: 'Validation Successful',
    validationFailed: 'Validation Failed',
    debugInfo: 'Debug Information:',
    lengthBytes: 'Length: {0} bytes',
    fileLoadSuccess: 'File loaded successfully',
    fileLoadError: 'Failed to load file',
    errorInvalidHex: 'Invalid hex data',
    errorTooShort: 'Invalid certificate request: too short',
    errorDataTooShort: 'Invalid data: too short',
    errorNoCA: 'Please select or provide a CA public key',
    errorInvalidSignedHex: 'Invalid signed data hex',
    errorValidationFailed: 'Validation failed: {0}',
    aboutRequestTitle: 'About Certificate Request',
    aboutRequestText1: 'The Issuer Certificate Request contains the public key and other certificate information that needs to be signed by the CA.',
    aboutRequestText2: 'This tool validates the structure and format of the certificate request before it is sent to the CA for signing.',
    aboutSignedTitle: 'About Signed Public Key Data',
    aboutSignedText1: 'The signed issuer public key data contains the certificate signed by the VISA CA.',
    aboutSignedText2: 'This tool validates the signature using the corresponding CA public key.',
    aboutCaTitle: 'About CA Public Key',
    aboutCaText1: 'Select a predefined VISA CA public key or load a custom one.',
    aboutCaText2: 'The CA public key is used to verify the signature on the issuer certificate.',
  },

  as2805: {
    infoTitle: 'About AS2805 Tools',
    info1: 'Includes terminal key set generation, PIN block translation (formats 01/46), MAC calculation (ISO9797-1 M2, TDES-CBC) and OWF (HMAC-SHA256). All operations are client-side.',
    description: 'Client-side implementations for common payment operations',
    tabGenerate: 'Generate Terminal Key Set',
    tabTranslatePin: 'Translate PIN Block',
    kekFlag: 'KEK Flag',
    kekrKey: 'KEKr Key',
    schemeKek: 'Key Scheme KEK',
    schemeLmk: 'Key Scheme LMK',
    kcvType: 'Key Check Value Type',
    translate: 'Translate',
    sysZpk: 'System ZPK',
    termTpk: 'Terminal TPK',
    stan: 'STAN',
    amount: 'Transaction Amount',
    inFmt: 'Incoming PIN Block Format',
    outFmt: 'Outgoing PIN Block Format',
    inPinBlock: 'Incoming PIN Block',
    account: 'Account Number',
    key: 'Key',
    data: 'Data',
    errorInvalidHex: 'Invalid hexadecimal input',
    errorGeneration: 'Generation failed',
    errorPinBlock: 'PIN Block must be 16 hex characters',
    errorAccount: 'Account number must be 12-19 digits',
    errorKeyLength: 'Invalid key length',
    errorCalculation: 'Calculation failed',
  },

  cvv: {
    title: 'Card Verification Value',
    description: 'Generate and validate CVV/CVC, iCVV, CVV2/CVC2, and dCVV for payment card security.',
    infoTitle: 'About CVV/CVC',
    info1: 'CVV (Card Verification Value) and CVC (Card Verification Code) are security features for card-not-present transactions.',
    info2: 'CVV/CVC: Printed on card (3 digits). CVV2/CVC2: Enhanced version. iCVV: Integrated chip CVV. dCVV: Dynamic CVV for contactless.',
    info3: 'Generated using card data (PAN, expiry, service code) encrypted with issuer CVK keys.',
    tabGenerate: 'Generate',
    tabValidate: 'Validate',
    cvkA: 'CVK A',
    cvkB: 'CVK B',
    pan: 'PAN',
    expDate: 'Exp. date',
    serviceCode: 'Service Code',
    atc: 'ATC',
    cvvLabel: 'CVV/CVC',
    verificationType: 'Verification Value Type',
    errorInvalidCvkA: 'CVK A must be 32 hex characters (16 bytes)',
    errorInvalidCvkB: 'CVK B must be 32 hex characters (16 bytes)',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorInvalidExpDate: 'Exp. date must be 4 digits (YYMM)',
    errorInvalidServiceCode: 'Service code must be 3 digits',
    errorInvalidAtc: 'ATC must be 4 digits for iCVV/dCVV',
    errorInvalidCvv: 'CVV must be 3 digits',
    errorGeneration: 'Failed to generate CVV',
    errorValidation: 'Failed to validate CVV',
    validResult: '✓ Valid - CVV is correct',
    invalidResult: '✗ Invalid - CVV does not match',
    copyError: 'Failed to copy',
  },

  amexCsc: {
    title: 'Card Security Code (AMEX)',
    description: 'Generate and validate AMEX Card Security Codes (CSC) for American Express payment cards.',
    infoTitle: 'About AMEX CSC',
    info1: 'AMEX CSC (Card Security Code) is a security feature similar to CVV/CVC but specific to American Express cards.',
    info2: 'CSC ver. 1: 4-digit code on magnetic stripe. CSC ver. 2: Enhanced with CSC-5 (5 digits), CSC-4 (4 digits), and CSC-3 (3 digits printed on card front).',
    info3: 'Generated using AMEX 15-digit PAN, expiry date, and service code encrypted with the issuer CSC Key.',
    tabGenerate: 'Generate',
    tabValidate: 'Validate',
    cscKey: 'CSC Key',
    pan: 'PAN',
    expDate: 'Exp. date',
    serviceCode: 'Service Code',
    csc: 'CSC',
    cscVersion: 'CSC version',
    verificationType: 'Verification Value Type',
    errorInvalidKey: 'CSC Key must be 32 or 48 hex characters',
    errorInvalidPan: 'AMEX PAN must be 15 digits',
    errorInvalidExpDate: 'Exp. date must be 4 digits (YYMM)',
    errorInvalidServiceCode: 'Service code must be 3 digits',
    errorInvalidCsc: 'Invalid CSC length',
    errorGeneration: 'Failed to generate CSC',
    errorValidation: 'Failed to validate CSC',
    validResult: '✓ Valid - CSC is correct',
    invalidResult: '✗ Invalid - CSC does not match',
    copyError: 'Failed to copy',
  },
  mastercardCvc3: {
    title: 'Card Verification Code (MasterCard)',
    subtitle: 'Generate and validate MasterCard dynamic CVC3 for contactless EMV payment cards.',
    infoTitle: 'About MasterCard CVC3',
    info1: 'MasterCard dynamic CVC3 is a 3-digit security code generated dynamically for contactless EMV transactions.',
    info2: 'The CVC3 is derived from the ICC Master Key (IMK) and includes PAN, Track Data, Unpredictable Number, and ATC to ensure each transaction is unique.',
    imk: 'IMK',
    pan: 'PAN',
    panSeqNum: 'PAN Seq. Num.',
    track12Data: 'Track 1/2 Data',
    unpredictableNum: 'Unpredictable Num.',
    atc: 'ATC',
    cvc3Type: 'CVC3 type',
    dynamicCvc3: 'dynamic CVC3',
    pinCvc3: 'PIN-CVC3',
    generate: 'Generate',
    validate: 'Validate',
    errorInvalidImk: 'IMK must be 32 hex characters',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorInvalidPanSeq: 'PAN Seq. Num. must be 2 digits',
    errorInvalidTrack: 'Track 1/2 Data must be max 128 hex characters',
    errorInvalidUN: 'Unpredictable Number must be 8 hex characters',
    errorInvalidAtc: 'ATC must be 4 hex characters',
    errorInvalidCvc3: 'CVC3 must be 3 digits',
    errorGeneration: 'Failed to generate CVC3',
    errorValidation: 'Failed to validate CVC3',
    copyError: 'Failed to copy',
    validResult: '✓ Valid - CVC3 is correct',
    invalidResult: '✗ Invalid - CVC3 does not match',
  },
  dukpt: {
    title: 'DUKPT (ISO 9797)',
    subtitle: 'Derive keys and encrypt/decrypt data using DUKPT (Derived Unique Key Per Transaction) standard.',
    infoTitle: 'About DUKPT',
    info1: 'DUKPT (Derived Unique Key Per Transaction) is a key management scheme used in POS and ATM systems.',
    info2: 'It derives a unique encryption key for each transaction from a Base Derivation Key (BDK) and Key Serial Number (KSN), ensuring that compromised keys cannot be used to decrypt past transactions.',
    tabPekDerivation: 'PEK derivation',
    tabDukptPin: 'DUKPT PIN',
    tabDukptMac: 'DUKPT MAC',
    tabDukptData: 'DUKPT DATA',
    inputKeyDesignation: 'Input key designation',
    bdk: 'BDK',
    ipek: 'IPEK',
    ksn: 'KSN',
    pek: 'PEK',
    pinBlock: 'PIN block',
    algorithm: 'Algorithm',
    des: 'DES',
    threeDes: '3DES',
    data: 'Data',
    dataVariant: 'Data Variant',
    dataInput: 'Data input',
    ascii: 'ASCII',
    hexadecimal: 'Hexadecimal',
    derivePek: 'Derive PEK',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    calculateMac: 'Calculate MAC',
    result: 'Result',
    mac: 'MAC',
    errorInvalidBdk: 'BDK must be 32 hex characters',
    errorInvalidIpek: 'IPEK must be 32 hex characters',
    errorInvalidKsn: 'KSN must be 20 hex characters',
    errorInvalidPek: 'PEK must be 32 hex characters',
    errorInvalidPekMac: 'PEK must be 32 or 48 hex characters',
    errorInvalidPinBlock: 'PIN block must be 16 hex characters',
    errorInvalidData: 'Data is required',
    errorInvalidPekData: 'PEK must be 32 hex characters',
    errorInvalidEncryptedData: 'Encrypted data must be multiple of 16 hex characters',
    errorDerivation: 'Failed to derive PEK',
    errorEncryption: 'Failed to encrypt PIN block',
    errorDecryption: 'Failed to decrypt PIN block',
    errorMacCalculation: 'Failed to calculate MAC',
    errorDataEncryption: 'Failed to encrypt data',
    errorDataDecryption: 'Failed to decrypt data',
  },
  dukptAes: {
    title: 'DUKPT (AES)',
    subtitle: 'Derive keys and encrypt/decrypt data using DUKPT with AES support.',
    infoTitle: 'About DUKPT (AES)',
    info1: 'DUKPT (Derived Unique Key Per Transaction) with AES support extends the original DUKPT standard to use AES encryption algorithms.',
    info2: 'It supports 2TDEA, 3TDEA, AES-128, AES-192, and AES-256 encryption, providing enhanced security for modern payment systems.',
    tabWorkingKeyDerivation: 'Working key derivation',
    tabDukptPin: 'DUKPT PIN',
    tabDukptMac: 'DUKPT MAC',
    tabDukptData: 'DUKPT DATA',
    inputKeyDesignation: 'Input key designation',
    bdk: 'BDK',
    ik: 'IK',
    workingKeyType: 'Working key type',
    ksn: 'KSN',
    pek: 'PEK',
    pinBlock: 'PIN block',
    macGen: 'MAC Gen.',
    dek: 'DEK',
    dataInput: 'Data input',
    ascii: 'ASCII',
    hexadecimal: 'Hexadecimal',
    data: 'Data',
    deriveKey: 'Derive Key',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    calculateMac: 'Calculate MAC',
    result: 'Result',
    workingKey: 'Working Key',
    mac: 'MAC',
    errorInvalidKeyLength: '{keyDesignation} must be {expectedLength} hex characters',
    errorInvalidKsn: 'KSN must be 24 hex characters',
    errorInvalidPekLength: 'PEK must be {expectedLength} hex characters',
    errorInvalidPinBlock: 'PIN block must be 32 hex characters',
    errorInvalidMacLength: 'MAC Gen. must be {expectedLength} hex characters',
    errorInvalidDekLength: 'DEK must be {expectedLength} hex characters',
    errorInvalidData: 'Data is required',
    errorInvalidEncryptedData: 'Encrypted data must be multiple of {blockSize} hex characters',
    errorDerivation: 'Failed to derive working key',
    errorEncryption: 'Failed to encrypt',
    errorDecryption: 'Failed to decrypt',
    errorMacCalculation: 'Failed to calculate MAC',
    errorDataEncryption: 'Failed to encrypt data',
    errorDataDecryption: 'Failed to decrypt data',
  },

  mac: {
    iso9797: {
      title: 'ISO/IEC 9797-1 MAC',
      description: 'Calculate Message Authentication Code using ISO/IEC 9797-1 algorithms.',
      algorithm: 'MAC Algorithm',
      keyK: 'Key (K)',
      keyKPrime: 'Key (K\')',
      keyKDoublePrime: 'Key (K")',
      key2K: 'Key 2 (K)',
      key2KPrime: 'Key 2 (K\')',
      key2KDoublePrime: 'Key 2 (K")',
      padding: 'Padding',
      data: 'Data (Hex)',
      truncation: 'Truncation (bytes)',
      calculate: 'Calculate MAC',
      result: 'MAC Result',
      hexChars: 'hex chars',
      copied: 'Copied!',
      success: 'MAC calculated successfully',
      error: {
        invalidKeyFormat: 'Invalid key format',
        invalidKeyLength: 'Invalid key length',
        emptyData: 'Data is required',
        invalidDataFormat: 'Invalid data format',
        invalidTruncation: 'Truncation must be 1-8 bytes',
      },
    },
    ansimac: {
      title: 'ANSI MACs',
      description: 'Calculate Message Authentication Code using ANSI X9.9 or X9.19 standard.',
      infoTitle: 'About ANSI MACs',
      infoDescription1: 'ANSI X9.9 and X9.19 define MAC algorithms used in financial transactions.',
      infoDescription2: 'X9.9 (Wholesale MAC) uses DES CBC-MAC. X9.19 (Retail MAC) uses DES with final 3DES encryption for enhanced security.',
      algorithmLabel: 'MAC Algorithm:',
      algorithmX99: 'ANSI MAC X9.9 (Wholesale MAC)',
      algorithmX919: 'ANSI MAC X9.19 (Retail MAC)',
      keyK: 'Key (K):',
      keyKPrime: 'Key (K\'):',
      dataLabel: 'Data:',
      dataPlaceholder: 'Enter hex data',
      truncation: 'Truncation:',
      calculate: 'Calculate MAC',
      result: 'MAC:',
      hexChars: 'hex chars',
      copied: 'Copied!',
      success: 'MAC calculated successfully',
      error: {
        invalidKeyK: 'Key (K) must be 16 or 32 hex characters',
        invalidKeyKPrime: 'Key K\' must be 16 hex characters',
        emptyData: 'Data is required',
        invalidDataFormat: 'Invalid data format',
        invalidTruncation: 'Truncation must be between 1 and 8',
        calculationFailed: 'Failed to calculate MAC',
      },
    },
    as2805: {
      title: 'AS2805 MACs',
      description: 'Calculate Message Authentication Code using AS2805.4.1 standard.',
      infoTitle: 'About AS2805 MACs',
      infoDescription1: 'AS2805.4.1 defines MAC algorithms used in Australian payment systems.',
      infoDescription2: 'Method 2 uses DES CBC-MAC with final 3DES encryption.',
      algorithm: 'MAC Algorithm:',
      algorithmMethod1: 'AS2805.4.1 MAC Method 1',
      algorithmMethod2: 'AS2805.4.1 MAC Method 2',
      keyKL: 'Key (K|KL):',
      keyKLPlaceholder: '0123456789ABCDEF',
      keyKR: 'Key (KR):',
      keyKRPlaceholder: 'FEDCBA9876543210',
      data: 'Data:',
      dataPlaceholder: 'Enter hex data',
      truncation: 'Truncation:',
      truncationPlaceholder: '4',
      calculate: 'Calculate MAC',
      result: 'MAC:',
      hexChars: 'hex chars',
      copied: 'Copied!',
      success: 'MAC calculated successfully',
      error: {
        invalidKeyKL: 'Key (K|KL) must be 16 hex characters',
        invalidKeyKR: 'Key (KR) must be 16 hex characters',
        emptyData: 'Data is required',
        invalidDataFormat: 'Invalid data format',
        invalidTruncation: 'Truncation must be between 1 and 8',
        calculationFailed: 'Failed to calculate MAC',
      },
    },
    tdescbc: {
      title: 'TDES CBC-MAC',
      infoTitle: 'About TDES CBC-MAC',
      info: 'Calculate MAC using Triple DES in CBC mode with ISO 9797-1 padding',
      description: 'Calculate MAC using Triple DES CBC mode',
      algorithm: 'Algorithm',
      keyK: 'Key (K)',
      padding: 'Padding',
      data: 'Data (Hex)',
      truncation: 'Truncation (bytes)',
      calculate: 'Calculate MAC',
      result: 'MAC Result',
      hexChars: 'hex chars',
      copied: 'Copied!',
      success: 'MAC calculated successfully',
      error: {
        invalidKeyFormat: 'Invalid key format',
        invalidKeyLength: 'Key must be 32 or 48 hex characters',
        emptyData: 'Data is required',
        invalidDataFormat: 'Invalid data format',
        invalidTruncation: 'Truncation must be 1-8 bytes',
      },
    },
    hmac: {
      title: 'HMAC',
      description: 'Calculate Hash-based Message Authentication Code.',
      hashType: 'Hash Type',
      inputTypeLabel: 'Input Type',
      hmacKey: 'HMAC Key',
      data: 'Data',
      keyPlaceholderHex: 'Enter hex key',
      keyPlaceholderAscii: 'Enter ASCII key',
      dataPlaceholderHex: 'Enter hex data',
      dataPlaceholderAscii: 'Enter ASCII data',
      calculate: 'Calculate HMAC',
      result: 'HMAC Result',
      hexChars: 'hex chars',
      copied: 'Copied!',
      success: 'HMAC calculated successfully',
      error: {
        emptyKey: 'Key is required',
        invalidKeyFormat: 'Invalid key format',
        emptyData: 'Data is required',
        invalidDataFormat: 'Invalid data format',
      },
    },
    cmac: {
      title: 'CMAC',
      infoTitle: 'About CMAC',
      info: 'Calculate cipher-based MAC using AES or TDES with NIST SP 800-38B standard',
      description: 'Calculate cipher-based message authentication code',
      encryptionType: 'Encryption Type',
      cmacKey: 'CMAC Key',
      data: 'Data',
      inputTypeLabel: 'Input Type',
      keyPlaceholderHex: 'Enter hex key',
      keyPlaceholderAscii: 'Enter ASCII key',
      dataPlaceholderHex: 'Enter hex data',
      dataPlaceholderAscii: 'Enter ASCII data',
      aesCmac96: 'AES CMAC 96 (truncate to 12 bytes)',
      calculate: 'Calculate CMAC',
      result: 'CMAC Result',
      hexChars: 'hex chars',
      copied: 'Copied!',
      success: 'CMAC calculated successfully',
      error: {
        emptyKey: 'Key is required',
        invalidKeyFormat: 'Invalid key format',
        invalidKeyLength: 'Invalid key length',
        emptyData: 'Data is required',
        invalidDataFormat: 'Invalid data format',
      },
    },
    retail: {
      title: 'Retail MAC',
      description: 'Calculate Retail MAC using DES or Triple DES.',
      algorithm: 'Algorithm',
      finalize: 'Finalize',
      keyK: 'Key (K)',
      keyKPlaceholder: '0123456789ABCDEF',
      keyKPrime: 'Key (K\')',
      keyKPrimePlaceholder: 'FEDCBA9876543210',
      data: 'Data (Hex)',
      dataPlaceholder: 'Enter hex data',
      truncation: 'Truncation (bytes)',
      truncationPlaceholder: '1-8',
      calculate: 'Calculate MAC',
      result: 'MAC Result',
      hexChars: 'hex chars',
      copied: 'Copied!',
      success: 'MAC calculated successfully',
      error: {
        invalidKeyK: 'Key K must be 16 hex characters',
        invalidKeyKPrime: 'Key K\' must be 16 hex characters',
        emptyData: 'Data is required',
        invalidDataFormat: 'Invalid data format',
        invalidTruncation: 'Truncation must be 1-8 bytes',
      },
    },
    zka: {
      title: 'ZKA (German Banking Standard)',
      infoTitle: 'About ZKA',
      info1: 'German banking standard for key management and cryptographic operations',
      info2: 'Includes SK derivation, PIN encryption, and MAC calculation',
      description: 'ZKA cryptographic operations for German banking systems',
    },
  },
  
  tr31: {
    title: 'TR-31 Key Block',
    description: 'Encode and decode TR-31/ANSI X9.143 key blocks with KBPK protection.',
    keyBlock: 'TR-31 Key Block',
    keyBlockPlaceholder: 'e.g., B0112P0TE00N0000...',
    parseKeyBlock: 'Parse Key Block',
    header: 'Key Block Header',
    version: 'Version',
    keyLength: 'Length',
    keyUsage: 'Key Usage',
    mode: 'Mode',
    keyVersion: 'Key Version',
    exportability: 'Exportability',
    characters: 'characters',
    errorTooShort: 'TR-31 key block length insufficient',
    errorParsing: 'Parsing failed, please check TR-31 format',
    exportable: 'Exportable',
    nonExportable: 'Non-exportable',
    sensitive: 'Sensitive',
    keyBlockFormatHint: 'TR-31 Key Block format (e.g., B0112P0TE00N...), system will auto-validate format',
  },

  tr31KeyBlock: {
    title: 'TR-31 Key Block',
    description: 'Encode and decode TR-31/ANSI X9.143 key blocks with KBPK protection',
    infoTitle: 'About TR-31 Key Block',
    infoContent1: 'TR-31 (ANSI X9.143) is the industry standard for secure cryptographic key exchange.',
    infoContent2: 'Key blocks contain encrypted key data wrapped with metadata (usage, algorithm, exportability).',
    infoContent3: 'KBPK (Key Block Protection Key) protects the wrapped key using TDES or AES encryption.',
    kbpkPlaceholder: 'Enter KBPK (Key Block Protection Key) - 32/48 hex for TDES, 32/48/64 hex for AES',
    keyBlockVersion: 'Key Block version',
    tabEncode: 'Encode',
    tabDecode: 'Decode',
    plainKey: 'Plain Key',
    plainKeyPlaceholder: 'Enter plain key in hex (16/24/32 bytes)',
    header: 'Header',
    versionId: 'Version Id',
    keyUsage: 'Key Usage',
    algorithm: 'Algorithm',
    modeOfUse: 'Mode of Use',
    keyVersionNum: 'Key version#',
    exportability: 'Exportability',
    optKeyBlocks: '# Opt. KeyBlocks',
    reserved: 'Reserved',
    optionalHeadersSection: 'Optional Headers',
    optionalHeaders: 'Optional Headers',
    encode: 'Encode',
    decode: 'Decode',
    keyBlock: 'Key block',
    keyBlockPlaceholder: 'Enter TR-31 key block data (e.g., D0144B1AX00E0000...)',
    encodeResult: 'Encoded Key Block',
    decodeResult: 'Decoded Key Block',
    headerInfo: 'Header',
    encodeSuccess: 'Key block encoded successfully',
    decodeSuccess: 'Key block decoded successfully',
    errorInvalidKey: 'Invalid plain key format',
    errorInvalidKbpk: 'Invalid KBPK format (minimum 32 hex characters)',
    errorKeyBlockShort: 'Key block is too short',
    errorEncode: 'Encoding failed',
    errorDecode: 'Decoding failed',
  },
  
  placeholder: {
    title: 'Coming Soon',
    description: 'This tool is under construction. Stay tuned!',
  },

  hash: {
    title: 'Hash Calculator',
    description: 'Calculate hash values using various algorithms like MD5, SHA-1, SHA-256, SHA-512, etc.',
    dataInput: 'Data Input',
    hexadecimal: 'Hexadecimal',
    hashType: 'Hash Type',
    inputData: 'Input Data',
    hashResult: 'Hash Result',
    asciiPlaceholder: 'Enter text data...',
    hexPlaceholder: 'Enter hexadecimal data...',
    byteLength: 'bytes',
    calculate: 'Calculate Hash',
    algorithmInfo: 'Algorithm Information',
    outputLength: 'Output Length',
    errorNoInput: 'Please enter input data',
    errorInvalidHex: 'Invalid hexadecimal input',
    errorOddHex: 'Hexadecimal input must have even number of characters',
    errorCalculation: 'Failed to calculate hash',
    faqTitle: 'Hash Calculator FAQ',
    faq1Question: 'What is a hash function?',
    faq1Answer: 'A hash function is a mathematical algorithm that converts input data of any size into a fixed-size output (hash value). It is deterministic and one-way.',
    faq2Question: 'Which hash algorithm should I use?',
    faq2Answer: 'For security purposes, use SHA-256 or SHA-512. MD5 and SHA-1 are considered insecure for cryptographic use but can be used for checksums.',
    usageTitle: 'How to Use',
    usage1: 'Select input type (ASCII text or Hexadecimal)',
    usage2: 'Choose a hash algorithm from the dropdown',
    usage3: 'Enter your data in the input field',
    usage4: 'Click "Calculate Hash" to generate the hash value',
    hashInfo: 'Hash functions are one-way - cannot be reversed',
    inputLength: 'Input',
  },

  encoding: {
    title: 'Character Encoding',
    description: 'Convert between different character encodings and formats',
    encodingType: 'Encoding',
    data: 'Data',
    convert: 'Convert',
    result: 'Conversion Result',
    conversionInfo: 'Conversion Information',
    ebcdicInfo: 'EBCDIC is used by IBM mainframes',
    atmInfo: 'ATM format uses space-separated decimal values (0-255)',
    errorNoInput: 'Please enter input data',
    errorInvalidHex: 'Invalid hexadecimal input',
    errorConversion: 'Conversion failed',
    placeholderBinary: 'Enter data (e.g., 57652C206174...)',
    placeholderHex: 'Enter hexadecimal data',
    placeholderText: 'Enter ASCII text',
    placeholderAtm: 'Enter decimal values separated by spaces (e.g., 065 066 067)',
    faqTitle: 'Character Encoding FAQ',
    faq1Question: 'What is character encoding?',
    faq1Answer: 'Character encoding is a system that pairs each character with a unique number or sequence of bytes, allowing computers to store and transmit text.',
    faq2Question: 'What is EBCDIC?',
    faq2Answer: 'EBCDIC (Extended Binary Coded Decimal Interchange Code) is an 8-bit character encoding used mainly on IBM mainframe and midrange computer systems.',
    usageTitle: 'How to Use',
    usage1: 'Select the conversion type from the dropdown',
    usage2: 'Enter your data in the appropriate format',
    usage3: 'Click "Convert" to see the result',
  },

  bcd: {
    title: 'Binary Coded Decimal (BCD)',
    description: 'Encode decimal numbers to BCD or decode BCD back to decimal',
    encode: 'Encode',
    decode: 'Decode',
    inputFormat: 'Input',
    binary: 'Binary',
    hexadecimal: 'Hexadecimal',
    data: 'Data',
    info: 'BCD Information',
    encodeInfo1: 'Each decimal digit (0-9) is encoded as 4 bits',
    encodeInfo2: 'Example: 25 → 0010 0101 (binary) / 25 (hex)',
    decodeInfo1: 'Each 4-bit nibble must be 0-9 (not A-F)',
    decodeInfo2: 'Example: 0010 0101 → 25',
    encodeResult: 'BCD Encoded Result',
    decodeResult: 'Decoded Decimal',
    errorNoInput: 'Please enter input data',
    errorInvalidDecimal: 'Invalid input: only digits 0-9 are allowed',
    errorInvalidBinary: 'Invalid binary input (must be 0s and 1s, length multiple of 4)',
    errorInvalidHex: 'Invalid hexadecimal input',
    errorConversion: 'Conversion failed',
    placeholderEncode: 'Enter decimal number (e.g., 12345)',
    placeholderBinary: 'Enter BCD binary (e.g., 0010 0101)',
    placeholderHex: 'Enter BCD hexadecimal (e.g., 25)',
    faqTitle: 'BCD FAQ',
    faq1Question: 'What is BCD?',
    faq1Answer: 'Binary Coded Decimal (BCD) is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of bits, usually four.',
    faq2Question: 'Why is BCD used?',
    faq2Answer: 'BCD is used in financial and commercial applications where decimal precision is important, and in systems that need to display decimal digits directly.',
    usageTitle: 'How to Use',
    usage1: 'Choose "Encode" to convert decimal to BCD',
    usage2: 'Choose "Decode" to convert BCD back to decimal',
    usage3: 'For decoding, select Binary or Hexadecimal input format',
  },

  checkDigits: {
    title: 'Check Digits',
    description: 'Verify or generate check digits using various algorithms',
    operation: 'Operation',
    check: 'Check',
    generate: 'Generate',
    hashType: 'Hash type',
    input: 'Input',
    info: 'Algorithm Information',
    luhnInfo: "Luhn algorithm (MOD 10) - Used for credit cards, IMEI, etc.",
    amexInfo: "Amex SE Number (MOD 9) - Sum of digits modulo 9",
    checkInfo: 'Enter the complete number including the check digit',
    generateInfo: 'Enter the number without the check digit',
    checkResult: 'Verification Result',
    generateResult: 'Generated Check Digit',
    validResult: 'Valid - Check digit is correct',
    invalidResult: 'Invalid - Check digit is incorrect',
    fullNumber: 'Full number',
    errorNoInput: 'Please enter a number',
    errorCalculation: 'Calculation failed',
    placeholderCheck: 'Enter number with check digit (e.g., 79927398713)',
    placeholderGenerate: 'Enter number without check digit (e.g., 7992739871)',
    faqTitle: 'Check Digits FAQ',
    faq1Question: 'What is a check digit?',
    faq1Answer: 'A check digit is a digit added to a number for error detection, calculated using a specific algorithm.',
    faq2Question: 'What is the Luhn algorithm?',
    faq2Answer: 'The Luhn algorithm (MOD 10) is a checksum formula used to validate credit card numbers, IMEI numbers, and other identification numbers.',
    usageTitle: 'How to Use',
    usage1: 'Select "Check" to verify a number with check digit',
    usage2: 'Select "Generate" to calculate the check digit',
    usage3: 'Choose the appropriate algorithm for your use case',
  },

  base64: {
    title: 'Base64',
    description: 'Encode data to Base64 or decode Base64 back to original format',
    encode: 'Encode',
    decode: 'Decode',
    inputEncoding: 'Input Encoding',
    outputEncoding: 'Output Encoding',
    hexadecimal: 'HEXADECIMAL',
    data: 'Data',
    info: 'Base64 Information',
    encodeInfo1: 'Base64 encodes binary data into ASCII characters',
    encodeInfo2: 'Output is ~33% larger than input',
    decodeInfo1: 'Decodes Base64 back to original data',
    decodeInfo2: 'Choose output format: ASCII text or Hexadecimal',
    encodeResult: 'Base64 Encoded Result',
    decodeResult: 'Decoded Result',
    errorNoInput: 'Please enter input data',
    errorInvalidHex: 'Invalid hexadecimal input',
    errorInvalidBase64: 'Invalid Base64 input',
    errorEncode: 'Encoding failed',
    errorDecode: 'Decoding failed',
    placeholderAscii: 'Enter text to encode',
    placeholderHex: 'Enter hexadecimal data to encode',
    placeholderBase64: 'Enter Base64 string to decode',
    faqTitle: 'Base64 FAQ',
    faq1Question: 'What is Base64?',
    faq1Answer: 'Base64 is a binary-to-text encoding scheme that represents binary data in ASCII string format using 64 characters.',
    faq2Question: 'Why use Base64?',
    faq2Answer: 'Base64 is commonly used to embed binary data in text-based formats like JSON, XML, or email attachments.',
    usageTitle: 'How to Use',
    usage1: 'Select "Encode" to convert data to Base64',
    usage2: 'Select "Decode" to convert Base64 back to original data',
    usage3: 'Choose input/output encoding: ASCII or Hexadecimal',
  },

  base94: {
    title: 'Base94',
    description: 'Encode data to Base94 or decode Base94 back to original format',
    encode: 'Encode',
    decode: 'Decode',
    inputEncoding: 'Input Encoding',
    outputEncoding: 'Output Encoding',
    hexadecimal: 'HEXADECIMAL',
    data: 'Data',
    info: 'Base94 Information',
    encodeInfo1: 'Uses ASCII printable characters (0x20 space to 0x7E tilde)',
    encodeInfo2: '5:4 ratio - 4 bytes encode to 5 characters (25% overhead)',
    decodeInfo1: 'Decodes Base94 back to original data',
    decodeInfo2: 'Valid characters: space to ~ (ASCII 32-126)',
    encodeResult: 'Base94 Encoded Result',
    decodeResult: 'Decoded Result',
    errorNoInput: 'Please enter input data',
    errorInvalidHex: 'Invalid hexadecimal input',
    errorInvalidBase94: 'Invalid Base94 input',
    errorEncode: 'Encoding failed',
    errorDecode: 'Decoding failed',
    placeholderAscii: 'Enter text to encode',
    placeholderHex: 'Enter hexadecimal data to encode',
    placeholderBase94: 'Enter Base94 string to decode',
    faqTitle: 'Base94 FAQ',
    faq1Question: 'What is Base94?',
    faq1Answer: 'Base94 is a binary-to-text encoding that uses all 94 printable ASCII characters (! to ~), providing more efficient encoding than Base64.',
    faq2Question: 'Why use Base94 instead of Base64?',
    faq2Answer: 'Base94 has less overhead (~22%) compared to Base64 (~33%), resulting in smaller encoded output for the same data.',
    usageTitle: 'How to Use',
    usage1: 'Select "Encode" to convert data to Base94',
    usage2: 'Select "Decode" to convert Base94 back to original data',
    usage3: 'Choose input/output encoding: ASCII or Hexadecimal',
  },

  messageParser: {
    title: 'Message Parser',
    description: 'Parse ATM and financial transaction messages',
    parseMode: 'Parse Mode',
    hexData: 'Hex Data',
    info: 'Parse Mode Information',
    ndcDesc: 'NCR NDC/DDC protocol for ATM communication',
    wincorDesc: 'Wincor Nixdorf protocol for ATM communication',
    iso8583Desc: 'ISO 8583:1987 financial transaction message format',
    hexInputInfo: 'Input must be valid hexadecimal data',
    placeholder: 'Enter hexadecimal message data to parse...',
    parsedResult: 'Parsed Result',
    fields: 'fields',
    fieldName: 'Field',
    length: 'Length',
    value: 'Value',
    errorNoInput: 'Please enter hex data',
    errorInvalidHex: 'Invalid hexadecimal input',
    errorParseFailed: 'Failed to parse message',
    faqTitle: 'Message Parser FAQ',
    faq1Question: 'What is ATM NDC?',
    faq1Answer: 'NDC (NCR Direct Connect) is a communication protocol used by NCR ATMs to communicate with host systems.',
    faq2Question: 'What is ISO 8583?',
    faq2Answer: 'ISO 8583 is an international standard for financial transaction card originated messages, used for card payment transactions.',
    usageTitle: 'How to Use',
    usage1: 'Select the appropriate parse mode (ATM_NDC, ATM_WINCOR, or ISO_8583_1987)',
    usage2: 'Enter the hexadecimal message data in the input field',
    usage3: 'Click Parse to view the parsed fields and their values',
  },

  rsaDer: {
    title: 'RSA DER Public Key',
    description: 'Encode/Decode RSA public key in DER ASN.1 format',
    info: 'RSA DER Information',
    encode: 'Encode',
    decode: 'Decode',
    modulus: 'Modulus',
    modulusEncoding: 'Modulus Encoding',
    exponent: 'Exponent',
    exponentEncoding: 'Exponent Encoding',
    modulusNegative: 'Modulus Negative (unsigned encoding)',
    outputEncoding: 'Output Encoding',
    inputEncoding: 'Input Encoding',
    derInput: 'DER/PEM Input',
    modulusPlaceholder: 'Enter modulus (hex or base64)',
    exponentPlaceholder: 'Enter exponent (e.g., 010001 for 65537)',
    derInputPlaceholder: 'Enter DER (hex/base64) or PEM format public key',
    encodeInfo: 'RSA Public Key Encoding',
    encodeInfo1: 'Encode RSA modulus and exponent to DER/PEM format',
    encodeInfo2: 'Supports both signed and unsigned integer encoding',
    decodeInfo: 'RSA Public Key Decoding',
    decodeInfo1: 'Decode DER/PEM format to extract modulus and exponent',
    decodeInfo2: 'Supports hex, base64, and PEM input formats',
    encodeResult: 'Encoded Result',
    decodeResult: 'Decoded Result',
    errorNoModulus: 'Please enter modulus',
    errorNoExponent: 'Please enter exponent',
    errorNoInput: 'Please enter DER data',
    errorInvalidModulusHex: 'Invalid modulus hex',
    errorInvalidModulusBase64: 'Invalid modulus base64',
    errorInvalidExponentHex: 'Invalid exponent hex',
    errorInvalidExponentBase64: 'Invalid exponent base64',
    errorInvalidHex: 'Invalid hex input',
    errorInvalidBase64: 'Invalid base64 input',
    errorEncode: 'Encoding failed',
    errorDecode: 'Decoding failed',
    faqTitle: 'RSA DER Public Key FAQ',
    faq1Question: 'What is DER encoding?',
    faq1Answer: 'DER (Distinguished Encoding Rules) is a binary format for encoding ASN.1 data structures, commonly used for cryptographic keys and certificates.',
    faq2Question: 'What is PEM format?',
    faq2Answer: 'PEM is a Base64 encoded version of DER with header and footer lines, making it easier to copy and paste in text form.',
    usageTitle: 'How to Use',
    usage1: 'Encode: Enter modulus and exponent to generate DER/PEM encoded public key',
    usage2: 'Decode: Enter DER or PEM format public key to extract modulus and exponent',
    usage3: 'Supports hex and base64 input/output formats',
  },

  uuid: {
    title: 'UUID Generator',
    description: 'Generate Universally Unique Identifiers (UUID)',
    variant: 'Variant',
    count: 'Count',
    info: 'UUID Information',
    infoFormat: 'Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36 characters)',
    v1Desc: 'Time-based UUID using timestamp and random node',
    v4Desc: 'Random UUID - most commonly used',
    v3Desc: 'Name-based UUID using MD5 hash',
    v5Desc: 'Name-based UUID using SHA-1 hash',
    generatedUUIDs: 'Generated UUIDs',
    copyAll: 'Copy All',
    errorInvalidCount: 'Count must be between 1 and 100',
    errorGenerate: 'Generation failed',
    withoutHyphen: 'Without "-"',
    maxCount: 'Max 100',
    faqTitle: 'UUID FAQ',
    faq1Question: 'What is UUID?',
    faq1Answer: 'UUID (Universally Unique Identifier) is a 128-bit identifier that is unique across space and time, commonly used in distributed systems.',
    faq2Question: 'Which UUID version should I use?',
    faq2Answer: 'Version 4 (random) is most commonly used. Version 1 is time-based, while versions 3 and 5 are name-based using MD5 and SHA-1 respectively.',
    usageTitle: 'How to Use',
    usage1: 'Select the UUID variant/version',
    usage2: 'Enter the number of UUIDs to generate (1-100)',
    usage3: 'Click Generate to create UUIDs',
  },

  cipher: {
    title: 'AES Encryption/Decryption',
    description: 'Encrypt and decrypt data using AES algorithm with various modes',
    algorithm: 'Algorithm',
    mode: 'Mode',
    dataInput: 'Data Input',
    hexadecimal: 'Hexadecimal',
    key: 'Key',
    data: 'Data',
    hexChars: 'hex characters',
    dataPlaceholderHex: 'Enter hexadecimal data',
    dataPlaceholderAscii: 'Enter ASCII text',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    encryptResult: 'Encrypted Result',
    decryptResult: 'Decrypted Result',
    aesInfo: 'AES Information',
    keyLengthInfo: 'Key length must match the selected algorithm',
    ivInfo: 'IV (Initialization Vector) must be 16 bytes',
    paddingInfo: 'Using PKCS7 padding',
    errorInvalidKeyHex: 'Key must be valid hexadecimal',
    errorKeyLength: 'Key length must be {length} bytes for {algorithm}',
    errorDataRequired: 'Data is required',
    errorInvalidDataHex: 'Data must be valid hexadecimal',
    errorInvalidIvHex: 'IV must be valid hexadecimal',
    errorIvLength: 'IV length must be {length} bytes',
    errorEncryption: 'Encryption failed',
    errorDecryption: 'Decryption failed',
    errorInvalidCiphertext: 'Ciphertext must be valid hexadecimal',
    ivNotRequired: 'IV is not required for ECB/KCV mode',
    kcvInfo: 'KCV: Encrypt zeros and take first 6 hex characters',
    calculateKcv: 'Calculate KCV',
    noPaddingInfo: 'No padding - data length must be multiple of 16 bytes',
    errorDataLength: 'Data length must be multiple of 16 bytes',
    kcvNoDataNeeded: 'No data needed for KCV calculation',
    kcvDataHint: 'KCV is calculated using zeros, no data input needed',
    errorKcvCalculation: 'KCV calculation failed',
    kcvResult: 'KCV Result',
  },

  des: {
    title: 'DES / 3DES Encryption/Decryption',
    description: 'Encrypt and decrypt data using DES or 3DES algorithm with various modes and padding',
    algorithm: 'Algorithm',
    mode: 'Mode',
    dataInput: 'Data Input',
    hexadecimal: 'Hexadecimal',
    padding: 'Padding',
    key: 'Key',
    data: 'Data',
    hexChars: 'hex characters',
    dataPlaceholderHex: 'Enter hexadecimal data',
    dataPlaceholderAscii: 'Enter ASCII text',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    encryptResult: 'Encrypted Result',
    decryptResult: 'Decrypted Result',
    desInfo: 'DES/3DES Information',
    keyLengthInfoDes: 'DES requires an 8-byte (64-bit) key',
    keyLengthInfo3Des: '3DES requires a 16 or 24-byte key',
    ivInfo: 'IV (Initialization Vector) must be 8 bytes',
    blockSizeInfo: 'Block size is 8 bytes',
    errorInvalidKeyHex: 'Key must be valid hexadecimal',
    errorKeyLengthDes: 'DES key length must be 8 bytes',
    errorKeyLength3Des: '3DES key length must be 16 or 24 bytes',
    errorDataRequired: 'Data is required',
    errorInvalidDataHex: 'Data must be valid hexadecimal',
    errorDataLength: 'Data length must be multiple of 8 bytes when using no padding',
    errorInvalidIvHex: 'IV must be valid hexadecimal',
    errorIvLength: 'IV length must be {length} bytes',
    errorEncryption: 'Encryption failed',
    errorDecryption: 'Decryption failed',
    errorInvalidCiphertext: 'Ciphertext must be valid hexadecimal',
    ivNotRequired: 'IV is not required for ECB mode',
    paddingNone: 'No padding',
    paddingZeros: 'Pad with 0x00',
    paddingSpaces: 'Pad with space 0x20',
    paddingANSIX923: 'Last byte is padding length, rest filled with 0x00',
    paddingISO10126: 'Last byte is padding length, rest filled with random bytes',
    paddingPKCS5: 'Each padding byte value equals the padding length',
    paddingPKCS7: 'Same as PKCS#5',
    paddingISO7816: 'Add 0x80, then pad with 0x00',
    paddingRijndael: 'Same as Zero padding',
    paddingISO9797M1: 'Pad with 0x00 to block size',
    paddingISO9797M2: 'Same as ISO 7816-4',
    mode8BitNote: 'Note: 8-bit mode processes 1 byte at a time',
    mode64BitNote: '64-bit mode processes full block (8 bytes) at a time',
  },

  rsa: {
    title: 'RSA Encryption/Decryption',
    description: 'RSA asymmetric encryption, decryption, signing and verification',
    rsaInfo: 'RSA Information',
    rsaInfo1: 'RSA is an asymmetric cryptographic algorithm',
    rsaInfo2: 'Key sizes: 1024, 2048, 4096 bits (2048+ recommended)',
    rsaInfo3: 'PKCS#1 v1.5 and OAEP padding supported',
    tabKeys: 'Keys',
    tabEncrypt: 'Encrypt',
    tabDecrypt: 'Decrypt',
    tabSign: 'Sign',
    tabVerify: 'Verify',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA modulus in hexadecimal',
    privateExpPlaceholder: 'RSA private exponent in hexadecimal',
    keyLength: 'Key Length',
    generateKeys: 'Generate Keys',
    importKeys: 'Import Keys',
    clearKeys: 'Clear',
    keyGenerated: 'Key pair generated successfully',
    keysCleared: 'Keys cleared',
    keyImported: 'Public key imported successfully',
    privateKeyImportNote: 'Private key import requires full CRT parameters. Use "Generate Keys" for full functionality.',
    padding: 'Padding',
    hashAlgorithm: 'Hash Algorithm',
    data: 'Data',
    dataToEncrypt: 'Data to Encrypt',
    dataPlaceholderAscii: 'Enter text data',
    encodingMethod: 'Encoding method',
    private: 'Private',
    public: 'Public',
    inputDataFormat: 'Input data format',
    hexadecimal: 'Hexadecimal',
    paddingMethod: 'Padding method',
    noPadding: 'No Padding',
    errorDataRequired: 'Data is required',
    privateEncryptNote: 'Note: Using public key for encryption demo',
    dataToSign: 'Data to Sign',
    dataToVerify: 'Data to Verify',
    ciphertextToDecrypt: 'Ciphertext to Decrypt',
    signatureToVerify: 'Signature',
    dataPlaceholder: 'Enter hexadecimal data',
    ciphertextPlaceholder: 'Enter encrypted hexadecimal data',
    signaturePlaceholder: 'Enter signature in hexadecimal',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    sign: 'Sign',
    verify: 'Verify',
    encryptedResult: 'Encrypted Result',
    encryptionFinished: 'Data encryption operation finished',
    decryptionFinished: 'Data decryption operation finished',
    decodingMethod: 'Decoding method',
    copyResult: 'Copy Result',
    result: 'RESULT',
    decryptedResult: 'Decrypted Result',
    signatureResult: 'Signature',
    signatureValid: '✓ Signature is valid',
    signatureInvalid: '✗ Signature is invalid',
    encryptInfo: 'RSA Encryption',
    encryptDesc: 'Encrypt data using the public key. Data size is limited by key size.',
    decryptInfo: 'RSA Decryption',
    decryptDesc: 'Decrypt data using the private key.',
    signInfo: 'RSA Signature',
    signDesc: 'Sign data using the private key (RSA-PSS).',
    verifyInfo: 'RSA Signature Verification',
    verifyDesc: 'Verify signature using the public key (RSA-PSS).',
    oaepDesc1: 'OAEP is a padding scheme used with RSA encryption',
    oaepDesc2: 'More secure than PKCS#1 v1.5 padding',
    oaepDesc3: 'Prevents chosen-ciphertext attacks',
    oaepDesc4: 'Recommended for new applications',
    oaepStructure: 'OAEP Structure',
    maxDataSize: 'Maximum Data Size',
    errorKeyGen: 'Key generation failed',
    errorKeyImport: 'Key import failed',
    errorInvalidModulus: 'Invalid modulus',
    errorInvalidPublicExp: 'Invalid public exponent',
    errorNoPublicKey: 'Please generate or import a public key first',
    errorNoPrivateKey: 'Please generate a key pair first (private key required)',
    errorInvalidData: 'Invalid data (must be hexadecimal)',
    errorInvalidCiphertext: 'Invalid ciphertext (must be hexadecimal)',
    errorInvalidSignature: 'Invalid signature (must be hexadecimal)',
    errorEncryption: 'Encryption failed',
    errorDecryption: 'Decryption failed',
    errorSign: 'Signing failed',
    errorVerify: 'Verification failed',
  },

  ecc: {
    title: 'ECC (ECDSA)',
    description: 'Elliptic Curve Cryptography - Digital Signature Algorithm',
    infoTitle: 'About ECC/ECDSA',
    infoContent1: 'Elliptic Curve Cryptography provides strong security with smaller key sizes',
    infoContent2: 'Supports P-256, P-384, P-521 curves for digital signatures',
    infoContent3: 'ECDSA signatures can verify data authenticity and integrity',
  },

  sslCert: {
    title: 'SSL Certificates (X509)',
    description: 'Generate RSA keys, create CSRs, self-signed certificates, and parse X.509 certificates',
    infoTitle: 'X.509 Certificate Information',
    info1: 'X.509 is the standard format for public key certificates',
    info2: 'Used in TLS/SSL, email signing, and code signing',
    info3: 'CSR (Certificate Signing Request) is used to request a certificate from a CA',
    // Tabs
    tabKeys: 'Keys',
    tabCSRs: 'CSRs',
    tabReadCSR: 'Read CSR',
    tabSelfSigned: 'Self-signed Certificates',
    tabReadCert: 'Read Certificate',
    // Keys tab
    publicExponent: 'Public Exp.(e)',
    keyLength: 'Key Length',
    passPhrase: 'Pass phrase',
    passPhrasePlaceholder: 'Enter pass phrase to encrypt private key',
    generateKeys: 'Generate Keys',
    privateKey: 'Private Key',
    keyGenerated: 'Key pair generated successfully',
    generating: 'Generating RSA key pair...',
    // CSR tab
    privateKeyPlaceholder: 'Paste encrypted PEM private key',
    version: 'Version',
    country: 'Country Name',
    state: 'State (Province)',
    locality: 'Locality Name',
    organization: 'Organization',
    unit: 'Unit',
    commonName: 'Common Name',
    email: 'Email address',
    generateCSR: 'Generate CSR',
    generatedCSR: 'Generated CSR',
    csrGenerated: 'Certificate Signing Request generated',
    inputPK: 'Input PK',
    certificateSigningRequest: 'Certificate Signing Request',
    generatingCSR: 'Generating CSR...',
    // Read CSR tab
    inputCSR: 'Input CSR',
    csrPlaceholder: 'Paste PEM encoded CSR (-----BEGIN CERTIFICATE REQUEST-----)',
    parseCSR: 'Parse CSR',
    parsedCSRInfo: 'Parsed CSR Information',
    csrParsed: 'CSR parsed successfully',
    csrRead: 'Certificate Signing Request Read',
    pemData: 'PEM Data',
    publicKey: 'Public Key',
    // Self-signed tab
    validityBefore: 'Validity Before',
    validityAfter: 'Validity After',
    days: 'days',
    serialNumber: 'Serial Number',
    generateCert: 'Generate Certificate',
    generatedCert: 'Generated Certificate',
    certGenerated: 'Certificate generated',
    generatingCert: 'Generating certificate...',
    certificate: 'Certificate',
    // Read Certificate tab
    inputCert: 'Input Cert.',
    certPlaceholder: 'Paste PEM encoded certificate (-----BEGIN CERTIFICATE-----)',
    parseCert: 'Parse Certificate',
    parsedCertInfo: 'Parsed Certificate Information',
    certParsed: 'Certificate parsed successfully',
    validFrom: 'Valid From',
    validTo: 'Valid To',
    issuer: 'Issuer',
    subject: 'Subject',
    extensions: 'Extensions',
    // Errors
    errorPassPhraseRequired: 'Pass phrase is required',
    errorPrivateKeyRequired: 'Private key is required',
    errorCommonNameRequired: 'Common Name is required',
    errorInvalidPrivateKey: 'Invalid private key or pass phrase',
    errorCSRRequired: 'CSR is required',
    errorCertRequired: 'Certificate is required',
    errorKeyGen: 'Key generation failed',
    errorCSRGen: 'CSR generation failed',
    errorCSRParse: 'CSR parsing failed',
    errorCertGen: 'Certificate generation failed',
    errorCertParse: 'Certificate parsing failed',
  },

  keyshareGenerator: {
    title: 'Keyshare Generator',
    description: 'Enter a key to split into multiple shares with KCV verification',
    infoTitle: 'About Keyshare Generator',
    infoContent: 'Split a cryptographic key into multiple shares using XOR operation.',
    infoContent2: 'Each share can be distributed to different custodians for key ceremonies.',
    mode: 'Mode',
    insecure: 'Insecure',
    secure: 'Secure',
    parity: 'Parity',
    ignore: 'Ignore',
    forceOdd: 'Force Odd',
    combinedKey: 'Combined Key',
    threePartKey: 'Three Part Key',
    twoPartKey: 'Two Part Key',
    parityAdjusted: 'Parity Adjusted',
    setPinFirst: 'Please set a 4-digit PIN first',
    keyRevealed: 'Key Share Revealed',
    wrongPin: 'Incorrect PIN',
    enterPin: 'Enter PIN',
    enterPinToReveal: 'Enter 4-digit PIN to reveal key share',
    unlock: 'Unlock',
    regenerate: 'Regenerate',
  },

  futurexKeys: {
    title: 'Futurex Keys Encryption/Decryption',
    description: 'Encrypt and decrypt keys using Futurex HSM key variant methodology',
    infoTitle: 'About Futurex Keys',
    infoContent1: 'Encrypt/decrypt keys using Futurex HSM key variants.',
    infoContent2: 'Modifier (0-F) creates different key variants from MFK.',
    infoContent3: 'MFK (Master File Key) is the base encryption key.',
    tabEncrypt: 'Key Encryption / Decryption',
    tabLookup: 'Key Lookup',
    key: 'Key',
    modifier: 'Modifier',
    modifierHint: 'Key variant selector (0-F)',
    mfk: 'MFK (Master File Key)',
    customMfk: 'Custom MFK...',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    encryptedKey: 'Encrypted Key',
    decryptedKey: 'Decrypted Key',
    encryptedKeyInput: 'Encrypted Key',
    lookup: 'Lookup All Modifiers',
    lookupResults: 'Lookup Results',
    encryptSuccess: 'Key encrypted successfully',
    decryptSuccess: 'Key decrypted successfully',
    errorInvalidKey: 'Invalid key format',
    errorKeyLength: 'Key must be 16, 24, or 32 bytes',
    errorInvalidMfk: 'Invalid MFK format (must be at least 32 hex characters)',
    errorEncrypt: 'Encryption failed',
    errorDecrypt: 'Decryption failed',
    errorLookup: 'Lookup failed',
    noResults: 'No valid decryption found',
    // Result display
    encryptResult: 'Key Encryption Result',
    decryptResult: 'Key Decryption Result',
    plainKey: 'Plain Key',
    encryptedKeyLabel: 'Encrypted Key',
    parityDetected: 'Parity detected',
    mfkLabel: 'MFK',
    keyModifier: 'Key modifier',
    decodedKey: 'Decoded Key',
    kcvLabel: 'KCV',
    // Key Lookup
    checkKcv: 'Check KCV?',
    type: 'Type',
    typeAny: 'Any',
    typeFuturex: 'Futurex',
    typeIbm: 'IBM',
    typeAtalla: 'Atalla',
    typeVisa: 'VISA',
    parityLabel: 'Parity',
    parityAny: 'Any',
    parityOdd: 'Odd',
    parityEven: 'Even',
    keyPlaceholder: 'Enter encrypted key to lookup',
    kcvPlaceholder: 'Enter KCV to match (6 hex chars)',
    errorInvalidKcv: 'Invalid KCV format (must be at least 6 hex characters)',
  },

  atallaKeys: {
    title: 'Atalla Keys (AKB)',
    description: 'Encrypt and decrypt keys using Atalla HSM AKB format',
    infoTitle: 'About Atalla Keys',
    infoContent1: 'Encrypt/decrypt keys using Atalla Key Block (AKB) format.',
    infoContent2: 'AKB header (8 chars) defines the key variant.',
    infoContent3: 'MFK (Master File Key) is the base encryption key.',
    tabEncrypt: 'Key Encryption',
    tabDecode: 'AKB Decode',
    key: 'Key',
    akbHeader: 'AKB header',
    akbHeaderHint: 'Atalla Key Block header (8 characters)',
    mfkKey: 'MFK Key',
    mfkPlaceholder: 'Enter MFK (48 hex characters)',
    keyPlaceholder: 'Enter hex key (16/24/32 bytes)',
    encrypt: 'Encrypt',
    decode: 'Decode',
    akb: 'AKB',
    akbPlaceholder: 'Enter AKB (header,encrypted_data)',
    checkKcv: 'Check KCV?',
    kcvS: 'KCV (S)',
    kcvPlaceholder: 'Enter expected KCV',
    parity: 'Parity',
    parityAny: 'Any',
    parityOdd: 'Odd',
    parityEven: 'Even',
    encryptSuccess: 'Key encrypted successfully',
    decodeSuccess: 'AKB decoded successfully',
    errorInvalidKey: 'Invalid key format',
    errorKeyLength: 'Key must be 16, 24, or 32 bytes',
    errorHeaderLength: 'AKB header must be 8 characters',
    errorInvalidMfk: 'MFK must be at least 48 hex characters',
    errorInvalidAkb: 'Invalid AKB format (must contain header,data)',
    errorInvalidAkbData: 'Invalid encrypted data in AKB',
    errorInvalidKcv: 'Invalid KCV format',
    errorEncrypt: 'Encryption failed',
    errorDecode: 'Decoding failed',
    kcvMismatch: 'KCV does not match',
    macMismatch: 'MAC verification failed',
    parityMismatch: 'Parity does not match',
    decodeFailed: 'Failed to decode AKB',
    encryptResult: 'Encryption Result',
    decodeResult: 'Decode Result',
    plainKey: 'Plain Key',
    encryptedAkb: 'Encrypted AKB',
    kcv: 'KCV',
    header: 'Header',
    decodedKey: 'Decoded Key',
    parityDetected: 'Parity',
  },

  safenetKeys: {
    title: 'SafeNet Keys Encryption/Decoding',
    description: 'Encrypt and decrypt keys using SafeNet HSM key variant methodology',
    infoTitle: 'About SafeNet Keys',
    infoContent1: 'Encrypt/decrypt keys using SafeNet HSM methodology.',
    infoContent2: 'Key format defines the encryption type (ECB/CBC).',
    infoContent3: 'Variant determines key usage (DPK, PPK, MPK, etc.).',
    tabEncrypt: 'Key Encryption / Decryption',
    tabLookup: 'Key Lookup',
    key: 'Key',
    keyFormat: 'Key format',
    variant: 'Variant',
    kmKey: 'KM Key',
    kmKeyPlaceholder: 'Enter KM Key (32 hex characters)',
    keyPlaceholder: 'Enter hex key',
    lookupKeyPlaceholder: 'Enter encrypted key to lookup',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    lookup: 'Lookup',
    encryptSuccess: 'Key encrypted successfully',
    decryptSuccess: 'Key decrypted successfully',
    decryptFailed: 'Decryption failed',
    errorInvalidKey: 'Invalid key format',
    errorInvalidKmKey: 'KM Key must be at least 16 bytes',
    errorInvalidKcv: 'Invalid KCV format',
    errorEncrypt: 'Encryption failed',
    errorDecrypt: 'Decryption failed',
    errorLookup: 'Lookup failed',
    noResults: 'No matching keys found',
    encryptResult: 'Encryption Result',
    decryptResult: 'Decryption Result',
    plainKey: 'Plain Key',
    encryptedKeyLabel: 'Encrypted Key',
    decodedKey: 'Decoded Key',
    kcvLabel: 'KCV',
    parityDetected: 'Parity',
    checkKcv: 'Check KCV?',
    kcv: 'KCV',
    kcvPlaceholder: 'Enter expected KCV',
    parity: 'Parity',
    parityAny: 'Any',
    parityOdd: 'Odd',
    parityEven: 'Even',
  },

  thalesKeys: {
    title: 'Thales Keys Encryption/Decoding',
    description: 'Encrypt and decrypt keys using Thales HSM LMK key variant methodology',
    infoTitle: 'About Thales Keys',
    infoContent1: 'Encrypt/decrypt keys using Thales HSM LMK methodology.',
    infoContent2: 'Key scheme defines the key length and encryption type.',
    infoContent3: 'Variant determines the XOR mask applied to LMK.',
    tabEncrypt: 'Key Encryption / Decryption',
    tabLookup: 'Key Lookup',
    key: 'Key',
    keyScheme: 'Key Scheme',
    lmkSize: 'LMK size',
    double: 'Double',
    triple: 'Triple',
    lmkPair: 'LMK Pair',
    lmkKey: 'LMK Key',
    variant: 'Variant',
    keyPlaceholder: 'Enter hex key',
    lookupKeyPlaceholder: 'Enter encrypted key to lookup (with or without scheme prefix)',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    lookup: 'Lookup',
    encryptSuccess: 'Key encrypted successfully',
    decryptSuccess: 'Key decrypted successfully',
    decryptFailed: 'Decryption failed',
    errorInvalidKey: 'Invalid key format',
    errorInvalidLmkKey: 'Invalid LMK Key',
    errorInvalidKcv: 'Invalid KCV format',
    errorEncrypt: 'Encryption failed',
    errorDecrypt: 'Decryption failed',
    errorLookup: 'Lookup failed',
    noResults: 'No matching keys found',
    encryptResult: 'Encryption Result',
    decryptResult: 'Decryption Result',
    plainKey: 'Plain Key',
    encryptedKeyLabel: 'Encrypted Key',
    decodedKey: 'Decoded Key',
    kcvLabel: 'KCV',
    parityDetected: 'Parity',
    checkKcv: 'Check KCV?',
    kcv: 'KCV',
    kcvPlaceholder: 'Enter expected KCV',
    parity: 'Parity',
    parityAny: 'Any',
    parityOdd: 'Odd',
    parityEven: 'Even',
  },

  thalesKeyBlock: {
    title: 'Thales Key Block',
    description: 'Encode and decode Thales proprietary key blocks',
    infoTitle: 'About Thales Key Block',
    infoContent1: 'Encode and decode Thales proprietary key blocks.',
    infoContent2: 'Similar to TR-31 but with Thales-specific format.',
    infoContent3: 'Uses KBPK (Key Block Protection Key) for encryption.',
    tabEncode: 'Encode',
    tabDecode: 'Decode',
    plainKey: 'Plain Key',
    versionId: 'Version Id',
    keyUsage: 'Key Usage',
    algorithm: 'Algorithm',
    modeOfUse: 'Mode of Use',
    keyVersionNum: 'Key version#',
    exportability: 'Exportability',
    optKeyBlocks: '# Opt. KeyBlocks',
    lmkId: 'LMK ID',
    optionalHeaders: 'Optional Headers',
    encode: 'Encode',
    decode: 'Decode',
    keyBlock: 'Key block',
    encodeResult: 'Encoded Key Block',
    decodeResult: 'Decoded Key Block',
  },

  fpe: {
    title: 'Format-Preserving Encryption',
    description: 'Encrypt data while preserving its format and length (NIST SP 800-38G)',
    radix: 'Radix',
    encryptionType: 'Encryption Type',
    keyInput: 'Key Input',
    useTweak: 'Use Tweak?',
    fpeInfo: 'FPE Information',
    formatPreserving: 'Format-Preserving: Output has the same format and length as input',
    radixInfo: 'Current radix defines the valid character set for data',
    tweakInfo: 'Tweak provides additional input for encryption (like an IV)',
    minLength: 'Minimum data length: 2 characters',
    dataPlaceholder: 'Enter data with valid radix characters',
    tweakPlaceholderFF1: 'Enter tweak in hexadecimal (any length)',
    tweakPlaceholderFF3: '16 hex characters (8 bytes)',
    resultLength: 'Length',
    characters: 'characters',
    algorithm: 'Algorithm',
    errorInvalidKeyHex: 'Key must be valid hexadecimal',
    errorKeyLength: 'Key length must be {length} bytes for {algorithm}',
    errorDataRequired: 'Data is required',
    errorDataTooShort: 'Data must be at least 2 characters',
    errorInvalidDataForRadix: 'Data contains invalid characters for radix {radix}',
    errorInvalidTweakHex: 'Tweak must be valid hexadecimal',
    errorTweakLength: 'Tweak length must be {length} bytes for {algorithm}',
    errorEncryption: 'Encryption failed',
    errorDecryption: 'Decryption failed',
    algorithmNotImplemented: 'This algorithm is not fully implemented yet',
  },

  // SEO Content
  seo: {
    home: {
      title: 'HSM Kit - Free Online Encryption & Key Management Tools',
      description: 'Free online cryptographic tools for HSM key management. Support Thales, Futurex, Atalla, SafeNet HSMs. Calculate KCV, encode TR-31 key blocks, generate secure keys, encrypt with AES/DES/RSA. All calculations performed client-side. 100% free, no registration required.',
      keywords: 'HSM tools, Thales HSM, Futurex HSM, Atalla AKB, SafeNet keys, encryption toolkit, key management, KCV calculator, TR-31 key block, AES encryption, DES encryption, RSA encryption, PIN block, key generator, cryptography tools, payment security, LMK encryption, online encryption tools, free cryptography tools',
      faqTitle: 'Frequently Asked Questions',
      usageTitle: 'About HSM Kit',
      faqs: [
        { question: 'Is HSM Kit free to use?', answer: 'Yes, HSM Kit is 100% free with 44+ cryptographic tools. No registration, login, or payment required. All features are available instantly.' },
        { question: 'Is my data secure?', answer: 'Absolutely. All operations run entirely in your browser using JavaScript. Your keys, PINs, and sensitive data never leave your device - zero server communication.' },
        { question: 'What HSM vendors are supported?', answer: 'HSM Kit supports Thales (LMK encryption, key blocks), Futurex (MFK variants), Atalla (AKB format), and SafeNet (KM key variants) HSM key operations.' },
        { question: 'What encryption algorithms are supported?', answer: 'We support AES (128/192/256-bit), DES, 3DES, RSA, ECC/ECDSA, and Format-Preserving Encryption (FPE FF1/FF3-1). Multiple modes and padding options available.' },
        { question: 'Can I use HSM Kit for payment security?', answer: 'Yes! HSM Kit includes professional tools for PIN Block generation (ISO 9564), TR-31/Thales key blocks, KCV calculation, key share generation, and HSM key encryption/decryption.' },
        { question: 'What encoding tools are available?', answer: 'Base64, Base94, BCD, character encoding (ASCII/EBCDIC/Hex), ASN.1/DER parsing, UUID generation, hash calculation (MD5/SHA/BLAKE2), and check digit verification.' },
      ],
      usage: [
        'HSM Kit is a comprehensive suite of 44+ cryptographic tools designed for security professionals, developers, and anyone working with encryption and payment systems.',
        'All tools work entirely in your browser - zero server communication means your sensitive data, keys, and PINs never leave your device.',
        'Professional-grade HSM tools supporting Thales, Futurex, Atalla, and SafeNet key operations, TR-31 key blocks, and KCV calculations.',
        'Perfect for testing, development, and educational purposes in cryptography, payment security, and HSM key management.',
      ],
    },
    as2805: {
      title: 'AS2805 Payment Tools: Terminal Keys, PIN Block, MAC, OWF | HSM Kit',
      description: 'Comprehensive AS2805 utilities: Terminal Key Set generation, PIN Block translation, ISO9797-1 M2 TDES-CBC MAC, and OWF (HMAC-SHA256). Fully client-side, no data leaves your device.',
      keywords: 'AS2805, AS2805.4.1, Terminal Key Set, PIN Block translation, MAC, OWF, ISO9797-1 M2, TDES CBC-MAC, HMAC-SHA256, ZPK, TPK, KEK Flag 1,2,3, Key Scheme KEK B,C,H,F,G, Key Scheme LMK 0,T,U,X,Y,Z, KCV type 0,1,2, payments security',
      faqTitle: 'AS2805 FAQ',
      usageTitle: 'How to Use',
      faqs: [
        { question: 'What is AS2805?', answer: 'AS2805 is a payments standard widely used in Australia for financial messaging and security operations.' },
        { question: 'Are computations client-side?', answer: 'Yes. All operations run entirely in your browser; nothing is sent to servers.' },
        { question: 'Which KEK Flag values are supported?', answer: '1, 2, and 3.' },
        { question: 'Which Key Scheme KEK values are supported?', answer: 'B, C, H, F, and G.' },
        { question: 'Which Key Scheme LMK values are supported?', answer: '0, T, U, X, Y, and Z.' },
        { question: 'Which KCV types are supported?', answer: '0, 1, and 2.' },
        { question: 'Which MAC algorithm is used?', answer: 'ISO9797-1 Padding Method 2 with TDES CBC-MAC (last block).'},
        { question: 'Which OWF algorithm is used?', answer: 'HMAC-SHA256 producing a 32-byte digest (hex).' },
      ],
      usage: [
        'Terminal Key Set: select KEK Flag (1/2/3).',
        'Enter KEKr key in hex; length is shown above the input.',
        'Choose Key Scheme KEK (B/C/H/F/G) and Key Scheme LMK (0/T/U/X/Y/Z).',
        'Select KCV Type (0/1/2) and click Generate to produce KCV, ZPK, and TPK.',
        'PIN Block Translation: input System ZPK and Terminal TPK in hex with real-time length indicators.',
        'Enter STAN and Transaction Amount as needed, choose incoming/outgoing formats (e.g., 46 → 01).',
        'Provide Incoming PIN Block (16 hex) and Account Number (12–19 digits), then click Translate.',
        'MAC: input key (16/32/48 hex) and data (hex). The tool applies ISO9797-1 M2 padding and computes TDES CBC-MAC.',
        'OWF: input key (16/32/48/64 hex) and data (hex). The tool computes HMAC-SHA256.',
        'Use the copy button on result cards to quickly copy outputs.',
      ],
    },
    asn1: {
      title: 'ASN.1 Parser Online - Free DER/BER Structure Decoder | HSM Kit',
      description: 'Free online ASN.1 parser and decoder. Parse ASN.1 DER/BER structures, decode X.509 certificates, analyze PKCS formats. Supports hex, Base64, and PEM input with RFC definition matching. 100% client-side processing.',
      keywords: 'ASN.1 parser, DER decoder, BER decoder, X.509 certificate parser, PKCS decoder, ASN1 online tool, certificate analyzer, PEM parser, Base64 decoder, ASN.1 decoder, certificate parser, PKCS parser',
      faqTitle: 'ASN.1 Parser FAQ',
      usageTitle: 'How to Use ASN.1 Parser',
      faqs: [
        { question: 'What is ASN.1?', answer: 'ASN.1 (Abstract Syntax Notation One) is a standard interface description language for defining data structures that can be serialized and deserialized. It\'s widely used in cryptography, telecommunications, and network protocols.' },
        { question: 'What formats does this parser support?', answer: 'This parser supports DER (Distinguished Encoding Rules) and BER (Basic Encoding Rules) encoded ASN.1 structures. You can input data in hexadecimal, Base64, or PEM format.' },
        { question: 'Can I parse X.509 certificates?', answer: 'Yes, this tool can parse X.509 certificates, CSRs, PKCS#7/8/12 structures, and other certificate formats that use ASN.1 encoding.' },
        { question: 'What is the hex dump feature?', answer: 'The hex dump feature shows the raw bytes of the ASN.1 structure alongside the parsed tree view, making it easier to understand the binary encoding.' },
      ],
      usage: [
        'Paste your ASN.1 encoded data in hexadecimal, Base64, or PEM format into the input field.',
        'Click "Parse" to decode the structure and view the hierarchical tree representation.',
        'Enable "with hex dump" to see the raw bytes alongside the parsed structure.',
        'Use "with definitions" to match the structure against known RFC definitions like X.509, PKCS, etc.',
      ],
    },
    aes: {
      title: 'AES Encryption/Decryption Online - Free AES Calculator | HSM Kit',
      description: 'Free online AES encryption and decryption tool. Supports AES-128, AES-192, AES-256 with ECB, CBC, CFB, OFB, CTR modes. Calculate KCV, encrypt/decrypt hex or text data securely in your browser. 100% client-side, no data sent to server.',
      keywords: 'AES encryption, AES decryption, AES-128, AES-192, AES-256, AES calculator, AES online tool, AES ECB, AES CBC, AES CFB, AES OFB, AES CTR, AES KCV, Advanced Encryption Standard, symmetric encryption',
      faqTitle: 'AES Encryption FAQ',
      usageTitle: 'How to Use AES Encryption Tool',
      faqs: [
        { question: 'What is AES encryption?', answer: 'AES (Advanced Encryption Standard) is a symmetric block cipher that has become the global standard for encryption. It encrypts data in 128-bit blocks using keys of 128, 192, or 256 bits.' },
        { question: 'Which AES mode should I use?', answer: 'CBC mode is commonly recommended for most applications. ECB mode should be avoided for encrypting data larger than one block as it reveals patterns. CTR mode is good for streaming data.' },
        { question: 'What key sizes does AES support?', answer: 'AES supports three key sizes: AES-128 (16 bytes), AES-192 (24 bytes), and AES-256 (32 bytes). Longer keys provide stronger security.' },
        { question: 'What is IV in AES encryption?', answer: 'IV (Initialization Vector) is a random value used with modes like CBC, CFB, OFB, and CTR to ensure that identical plaintexts produce different ciphertexts. IV should be unique but doesn\'t need to be secret.' },
      ],
      usage: [
        'Select the AES key size (128, 192, or 256 bits) and encryption mode (ECB, CBC, etc.).',
        'Enter your encryption key in hexadecimal format.',
        'For modes other than ECB, provide an IV (16 bytes in hex).',
        'Enter your data to encrypt or decrypt and click the corresponding button.',
      ],
    },
    des: {
      title: 'DES/3DES Encryption Online - Free Triple DES Calculator | HSM Kit',
      description: 'Free online DES and Triple DES (3DES) encryption and decryption tool. Supports DES, 2-key 3DES, 3-key 3DES with ECB/CBC modes. Multiple padding options including PKCS5, ISO 7816, and more. 100% client-side, secure processing.',
      keywords: 'DES encryption, 3DES encryption, Triple DES, DES decryption, DES calculator, 3DES online tool, TDES, DES ECB, DES CBC, PKCS5 padding, Data Encryption Standard, payment encryption',
      faqTitle: 'DES/3DES Encryption FAQ',
      usageTitle: 'How to Use DES/3DES Tool',
      faqs: [
        { question: 'What is the difference between DES and 3DES?', answer: 'DES uses a single 56-bit key (8 bytes with parity) while 3DES applies the DES algorithm three times with two or three different keys (16 or 24 bytes), providing much stronger security.' },
        { question: 'Is DES still secure?', answer: 'Single DES is considered insecure and deprecated. 3DES is still used in legacy systems, especially in the payment industry, but AES is recommended for new applications.' },
        { question: 'What are parity bits in DES keys?', answer: 'In DES, each byte of the key has one parity bit (the least significant bit), making effective key length 56 bits from 64 bits. This tool can auto-adjust parity bits for you.' },
        { question: 'Which padding should I use?', answer: 'PKCS5/PKCS7 is the most common choice. ISO 9797 is often used in banking applications. The choice should match what your counterparty expects.' },
      ],
      usage: [
        'Select DES (8 bytes key) or 3DES (16 or 24 bytes key).',
        'Choose the encryption mode (ECB or CBC) and padding method.',
        'Enter your key in hexadecimal format.',
        'For CBC mode, provide an IV (8 bytes in hex).',
        'Enter data and click Encrypt or Decrypt.',
      ],
    },
    rsa: {
      title: 'RSA Encryption Online - Free RSA Calculator & Key Generator | HSM Kit',
      description: 'Free online RSA encryption, decryption, signing, and verification tool. Generate RSA key pairs (1024-4096 bit), encrypt with public key, sign with private key. Supports PKCS#1 and OAEP padding. All operations client-side.',
      keywords: 'RSA encryption, RSA decryption, RSA key generator, RSA calculator, RSA online tool, RSA signing, RSA verification, public key encryption, PKCS1, OAEP, asymmetric encryption, digital signature',
      faqTitle: 'RSA Encryption FAQ',
      usageTitle: 'How to Use RSA Tool',
      faqs: [
        { question: 'What is RSA encryption?', answer: 'RSA is an asymmetric encryption algorithm that uses a pair of keys - a public key for encryption and a private key for decryption. It\'s widely used for secure data transmission and digital signatures.' },
        { question: 'What key size should I use?', answer: 'For current security standards, 2048-bit keys are considered minimum. 4096-bit keys are recommended for long-term security. 1024-bit keys are deprecated.' },
        { question: 'What is the difference between PKCS#1 and OAEP?', answer: 'PKCS#1 v1.5 is an older padding scheme. OAEP (Optimal Asymmetric Encryption Padding) is more secure and recommended for new applications as it prevents certain attacks.' },
        { question: 'What is the maximum data size for RSA encryption?', answer: 'RSA can only encrypt data smaller than the key size minus padding overhead. For 2048-bit key with OAEP-SHA256, maximum is about 190 bytes. Use hybrid encryption for larger data.' },
      ],
      usage: [
        'Generate a new RSA key pair or import existing keys.',
        'For encryption: enter plaintext and click Encrypt (uses public key).',
        'For decryption: enter ciphertext and click Decrypt (requires private key).',
        'For signing: enter data hash and click Sign (requires private key).',
        'For verification: enter data, signature, and click Verify (uses public key).',
      ],
    },
    ecc: {
      title: 'ECC/ECDSA Online Tool - Elliptic Curve Cryptography | HSM Kit',
      description: 'Free online ECC (Elliptic Curve Cryptography) tool. Generate ECDSA key pairs, sign and verify data with secp256k1, P-256, P-384 curves. Compact keys with strong security for modern applications. 100% browser-based.',
      keywords: 'ECC encryption, ECDSA, elliptic curve, secp256k1, P-256, P-384, ECC key generator, ECDSA signing, ECDSA verification, Bitcoin cryptography, Ethereum cryptography, digital signature',
      faqTitle: 'ECC/ECDSA FAQ',
      usageTitle: 'How to Use ECC/ECDSA Tool',
      faqs: [
        { question: 'What is ECC?', answer: 'Elliptic Curve Cryptography (ECC) is an approach to public-key cryptography based on the algebraic structure of elliptic curves. It provides equivalent security to RSA with much smaller key sizes.' },
        { question: 'What is secp256k1?', answer: 'secp256k1 is the elliptic curve used by Bitcoin and Ethereum for their digital signatures. It offers a good balance of security and performance.' },
        { question: 'Why use ECC over RSA?', answer: 'ECC provides the same security level as RSA with much smaller keys (256-bit ECC ≈ 3072-bit RSA), resulting in faster operations and less storage/bandwidth requirements.' },
        { question: 'What is ECDSA?', answer: 'ECDSA (Elliptic Curve Digital Signature Algorithm) is the signature algorithm based on ECC. It\'s used to create digital signatures that can verify data authenticity.' },
      ],
      usage: [
        'Select the elliptic curve (secp256k1, P-256, or P-384).',
        'Generate a new key pair or import existing keys.',
        'For signing: enter data (or its hash) and click Sign.',
        'For verification: enter original data, signature, and click Verify.',
      ],
    },
    fpe: {
      title: 'Format-Preserving Encryption (FPE) Online - FF1/FF3-1 Tool | HSM Kit',
      description: 'Free online Format-Preserving Encryption tool implementing NIST SP 800-38G. Encrypt data while preserving format and length. Ideal for tokenizing credit card numbers, SSNs, and other structured data. PCI DSS compliant.',
      keywords: 'FPE, format preserving encryption, FF1, FF3, FF3-1, NIST 800-38G, tokenization, credit card encryption, data masking, PCI DSS, data tokenization, structured data encryption',
      faqTitle: 'Format-Preserving Encryption FAQ',
      usageTitle: 'How to Use FPE Tool',
      faqs: [
        { question: 'What is Format-Preserving Encryption?', answer: 'FPE is an encryption method that produces ciphertext in the same format and length as the plaintext. For example, a 16-digit credit card number encrypts to another 16-digit number.' },
        { question: 'What is the difference between FF1 and FF3-1?', answer: 'Both are NIST-approved FPE algorithms. FF1 supports variable-length tweaks while FF3-1 uses a fixed 56-bit tweak. FF3-1 is generally faster but has more constraints.' },
        { question: 'What is tokenization?', answer: 'Tokenization replaces sensitive data with non-sensitive placeholders (tokens). FPE is often used for tokenization because the tokens maintain the original data format.' },
        { question: 'Is FPE compliant with PCI DSS?', answer: 'Yes, FPE using NIST SP 800-38G approved algorithms (FF1, FF3-1) is accepted for PCI DSS compliance when implemented correctly.' },
      ],
      usage: [
        'Select the FPE algorithm (FF1 or FF3-1) and radix (number base).',
        'Enter your AES key (16, 24, or 32 bytes in hex).',
        'Optionally provide a tweak value for additional security.',
        'Enter plaintext data and click Encrypt to generate format-preserved ciphertext.',
      ],
    },
    keyGenerator: {
      title: 'Secure Key Generator Online - Random AES/DES Key Generator | HSM Kit',
      description: 'Free online cryptographic key generator. Generate secure random keys for AES, DES, 3DES encryption. Key combination (XOR), parity adjustment, and key validation tools included. Cryptographically secure random generation.',
      keywords: 'key generator, random key, AES key generator, DES key generator, 3DES key generator, cryptographic key, secure random, key combination, XOR keys, parity bits, secure key generation, random key generator',
      faqTitle: 'Key Generator FAQ',
      usageTitle: 'How to Use Key Generator',
      faqs: [
        { question: 'How are the random keys generated?', answer: 'Keys are generated using the Web Crypto API (crypto.getRandomValues), which provides cryptographically secure random numbers suitable for encryption keys.' },
        { question: 'What is key combination (XOR)?', answer: 'Key combination allows you to XOR multiple key components together to form a complete key. This is commonly used in ceremonies where multiple custodians each hold a component.' },
        { question: 'What are parity bits?', answer: 'In DES/3DES keys, each byte has a parity bit for error detection. This tool can automatically adjust parity bits to odd parity as required by the DES standard.' },
        { question: 'What key lengths are supported?', answer: 'The generator supports DES (8 bytes/64 bits), 2-key 3DES (16 bytes/128 bits), 3-key 3DES (24 bytes/192 bits), and AES-128/192/256.' },
      ],
      usage: [
        'Select the desired key length from the dropdown.',
        'Click "Generate" to create a new random key.',
        'Use the Key Combination tab to XOR multiple components together.',
        'Use the Parity tab to adjust DES/3DES key parity bits.',
        'Use Validation tab to check if a key has correct format and parity.',
      ],
    },
    keyshare: {
      title: 'Keyshare Generator Online - Split Keys into Components | HSM Kit',
      description: 'Free online keyshare generator for splitting cryptographic keys into multiple components. Enter a key to automatically generate 2-part or 3-part shares with KCV verification. Essential for key ceremonies and custodian distribution. Secure mode with PIN protection.',
      keywords: 'keyshare generator, key split, key components, XOR keys, key ceremony, key custodian, KCV verification, DES key share, AES key share, payment security, key distribution, key splitting, key custody',
      faqTitle: 'Keyshare Generator FAQ',
      usageTitle: 'How to Use Keyshare Generator',
      faqs: [
        { question: 'What is key sharing?', answer: 'Key sharing splits a cryptographic key into multiple components (shares) using XOR operation. All components XORed together reconstruct the original key. This enhances security by distributing key custody.' },
        { question: 'What is the difference between Insecure and Secure mode?', answer: 'In Insecure mode, generated key shares are displayed directly. In Secure mode, shares are hidden and protected by a 4-digit PIN - you must enter the correct PIN to reveal each share.' },
        { question: 'How are key shares generated?', answer: 'When you enter a Combined Key, the system generates random shares where: Part1 ⊕ Part2 ⊕ Part3 = Combined Key (for 3-part), or Part1 ⊕ Part2 = Combined Key (for 2-part).' },
        { question: 'What is KCV (Key Check Value)?', answer: 'KCV is a checksum calculated by encrypting zeros with the key. Each share and the combined key has its own KCV for verification without revealing the actual key value.' },
        { question: 'What does Force Odd parity do?', answer: 'Force Odd adjusts each byte of DES/3DES keys to have odd parity (odd number of 1 bits), as required by the DES standard for proper operation.' },
      ],
      usage: [
        'Enter your cryptographic key in the Combined Key field.',
        'The system automatically calculates the KCV and generates key shares.',
        'Three Part Key: 3 shares that XOR together equal the combined key.',
        'Two Part Key: 2 shares that XOR together equal the combined key.',
        'In Secure mode: Set a 4-digit PIN for each share, then click unlock to reveal.',
      ],
    },
    futurexKeys: {
      title: 'Futurex Keys Encryption/Decryption Online - HSM Key Variant Tool | HSM Kit',
      description: 'Free online Futurex HSM key encryption and decryption tool. Encrypt and decrypt keys using MFK (Master File Key) with modifier variants (0-F, 1A-1F). Supports Futurex, IBM, Atalla, and VISA key variant methods. Key Lookup finds the correct modifier by KCV matching. 100% client-side.',
      keywords: 'Futurex HSM, key encryption, key decryption, MFK, master file key, key variant, modifier, HSM tools, payment security, key management, IBM HSM, Atalla HSM, VISA PVK, KCV check, 3DES encryption, key lookup, HSM key management',
      faqTitle: 'Futurex Keys FAQ',
      usageTitle: 'How to Use Futurex Keys Tool',
      faqs: [
        { question: 'What is Futurex key encryption?', answer: 'Futurex HSMs use a specific key encryption methodology where keys are encrypted using variants of a Master File Key (MFK) combined with a modifier (0-F, 1A-1F). The variant key is created by XORing the MFK with the modifier byte.' },
        { question: 'What is the Modifier?', answer: 'The modifier (0-F, 1A-1F) is used to create different key variants from the MFK. Each modifier produces a unique encryption key for different purposes such as PIN keys, MAC keys, or data encryption keys.' },
        { question: 'What is MFK (Master File Key)?', answer: 'MFK is the base master key used in Futurex HSMs. It is typically a triple-length 3DES key (48 hex characters). The MFK is combined with a modifier to create variant keys for encrypting/decrypting other keys.' },
        { question: 'What is Key Lookup?', answer: 'Key Lookup tries all modifiers (0-F, 1A-1F) to decrypt an encrypted key. You can filter results by KCV (Key Check Value) and parity type (Odd/Even) to find the exact modifier used for encryption.' },
        { question: 'What are the different HSM types?', answer: 'Different HSM vendors use different key variant methods: Futurex uses full-byte XOR, IBM uses position-specific XOR, Atalla uses AKB method, and VISA uses PVK method with first 8 bytes.' },
        { question: 'What is KCV and how is it used?', answer: 'KCV (Key Check Value) is calculated by encrypting zeros with the key. In Key Lookup, you can enter an expected KCV to filter results and find which modifier produces a key with that specific KCV.' },
      ],
      usage: [
        'Key Encryption: Enter a plaintext key in hex, select modifier and MFK, click Encrypt.',
        'Key Decryption: Enter an encrypted key in hex, select modifier and MFK, click Decrypt.',
        'Result shows: input key, detected parity, MFK used, modifier, output key, and KCV.',
        'Key Lookup: Enter encrypted key, optionally set KCV filter and parity filter.',
        'Select HSM type (Any/Futurex/IBM/Atalla/VISA) and click Lookup to try all modifiers.',
        'Results show all matching decryptions with modifier, decoded key, KCV, and parity.',
      ],
    },
    atallaKeys: {
      title: 'Atalla Keys (AKB) Online - HSM Key Encryption/Decryption Tool | HSM Kit',
      description: 'Free online Atalla HSM key encryption and decryption tool. Encrypt and decrypt keys using AKB (Atalla Key Block) format with MFK and 8-character header. Supports KCV verification and parity checking. All processing in browser.',
      keywords: 'Atalla HSM, AKB, Atalla Key Block, key encryption, key decryption, MFK, master file key, HSM tools, payment security, key management, KCV verification, 3DES encryption, MAC verification, Atalla key management',
      faqTitle: 'Atalla Keys (AKB) FAQ',
      usageTitle: 'How to Use Atalla Keys Tool',
      faqs: [
        { question: 'What is AKB (Atalla Key Block)?', answer: 'AKB is a key block format used by Atalla HSMs. It consists of an 8-character header (e.g., 1PUNE000), encrypted key data, and a MAC for integrity verification. The header defines the key variant used for encryption.' },
        { question: 'What is the AKB header?', answer: 'The AKB header is an 8-character prefix that defines the key variant used for encryption. Common examples include 1PUNE000. Different headers indicate different key types or usage purposes.' },
        { question: 'What is MFK (Master File Key)?', answer: 'MFK is the base master key used in Atalla HSMs. It is a triple-length 3DES key (48 hex characters). The MFK is XORed with the header ASCII values to create the variant key for encryption/decryption.' },
        { question: 'How does AKB encryption work?', answer: 'The AKB header is converted to ASCII hex values and XORed with the MFK to create a variant key. This variant key encrypts the target key using 3DES ECB mode. A MAC is calculated over header + encrypted key for integrity.' },
        { question: 'What is the AKB format?', answer: 'AKB format is: header,encrypted_key,mac (74 characters total). Header is 8 chars, encrypted key is 48 hex chars (24 bytes), and MAC is 16 hex chars (8 bytes), separated by commas.' },
        { question: 'How to verify a decoded key?', answer: 'Use KCV (Key Check Value) verification. Enter the expected KCV when decoding - if the calculated KCV matches, the key was correctly decrypted with the right MFK.' },
      ],
      usage: [
        'Key Encryption: Enter a plaintext key (16/24/32 bytes), set AKB header (default: 1PUNE000), enter MFK, click Encrypt.',
        'Result shows: Plain Key, KCV, AKB Header, MFK Variant, Key under MFK, MAC, and complete AKB.',
        'AKB Decode: Enter AKB string (header,encrypted_key,mac format), enter MFK, click Decode.',
        'Optional: Enable Check KCV and enter expected KCV to verify decryption.',
        'Optional: Set Parity filter (Any/Odd/Even) to filter results by key parity.',
        'Result shows: AKB, Header, Decoded Key, KCV, and Parity.',
      ],
    },
    safenetKeys: {
      title: 'SafeNet Keys Encryption/Decryption Online - HSM Key Variant Tool | HSM Kit',
      description: 'Free online SafeNet HSM key encryption and decryption tool. Encrypt and decrypt keys using KM Key with Key Format and Variant options. Supports DPK, PPK, MPK, KPK variants. Key Lookup finds the correct variant by KCV matching. Secure browser-based processing.',
      keywords: 'SafeNet HSM, key encryption, key decryption, KM Key, key variant, DPK, PPK, MPK, KPK, HSM tools, payment security, key management, KCV verification, 3DES encryption, key lookup, SafeNet key management',
      faqTitle: 'SafeNet Keys FAQ',
      usageTitle: 'How to Use SafeNet Keys Tool',
      faqs: [
        { question: 'What is SafeNet key encryption?', answer: 'SafeNet HSMs use a specific key encryption methodology where keys are encrypted using variants of a Key Management Key (KM Key). The variant is determined by the key usage type (DPK, PPK, MPK, etc.).' },
        { question: 'What are Key Formats?', answer: 'Key Format defines the encryption method and key length: 00=Clear, 10/20=Single DES, 11/21=Double DES3, 12/22=Triple DES3. Formats 1x use ECB mode, 2x use CBC mode.' },
        { question: 'What are Variants?', answer: 'Variants determine key usage: 00=DPK (Data Protection), 01=PPK (PIN Protection), 02=MPK (MAC Protection), 03=KPK (Key Protection), 04=KTK (Key Transport), 05=KEK (Key Encryption). Each variant XORs the KM Key with a specific mask.' },
        { question: 'What is KM Key?', answer: 'KM Key (Key Management Key) is the master key used in SafeNet HSMs. It is typically a double-length 3DES key (32 hex characters). The KM Key is XORed with variant masks to create encryption keys.' },
        { question: 'What is Key Lookup?', answer: 'Key Lookup tries all variants (DPK, PPK, MPK, etc.) to decrypt an encrypted key. You can filter results by KCV and parity to find the exact variant used for encryption.' },
      ],
      usage: [
        'Key Encryption: Enter a plaintext key, select Key Format and Variant, enter KM Key, click Encrypt.',
        'Key Decryption: Enter an encrypted key, select Key Format and Variant, enter KM Key, click Decrypt.',
        'Result shows: Plain/Encrypted Key, KCV, Parity, Key Format, Variant, Variant Key, and output.',
        'Key Lookup: Enter encrypted key, optionally set KCV filter and parity filter.',
        'Enter KM Key and click Lookup to try all variants and find matching decryptions.',
        'Results show all matching variants with decoded key, KCV, and parity.',
      ],
    },
    thalesKeys: {
      title: 'Thales Keys (LMK) Online - HSM Key Encryption/Decryption Tool | HSM Kit',
      description: 'Free online Thales HSM key encryption and decryption tool. Encrypt and decrypt keys using LMK (Local Master Key) with Key Scheme and Variant options. Supports multiple LMK pairs and variant masks. Key Lookup finds matching decryptions. 100% client-side.',
      keywords: 'Thales HSM, LMK, Local Master Key, key encryption, key decryption, key scheme, key variant, LMK pair, HSM tools, payment security, key management, KCV verification, 3DES encryption, key lookup, Thales key management',
      faqTitle: 'Thales Keys (LMK) FAQ',
      usageTitle: 'How to Use Thales Keys Tool',
      faqs: [
        { question: 'What is Thales key encryption?', answer: 'Thales HSMs use LMK (Local Master Key) based encryption where keys are encrypted using variants of LMK pairs. The variant is determined by a XOR mask applied to the LMK.' },
        { question: 'What is Key Scheme?', answer: 'Key Scheme defines the key length and format: 0=Clear, U=Single length ECB, T=Double length ECB, X=Triple length ECB, Y=Double length variant, Z=Triple length variant. The scheme prefix is added to encrypted keys.' },
        { question: 'What are LMK Pairs?', answer: 'LMK Pairs are pairs of master keys used for different purposes: 00-01 for ZMK/ZPK/TMK/TPK, 02-03 for PVK/CVK/BDK, 04-05 for TAK, 14-15 for ZEK/DEK, etc. Each pair encrypts specific key types.' },
        { question: 'What are Variants?', answer: 'Variants (0-8) determine XOR masks applied to LMK: 0=No variant, 1=A6, 2=5A, 3=6A, 4=DE, 5=2B, 6=50, 7=74, 8=9C. The mask is XORed with each 8-byte block of the LMK.' },
        { question: 'What is LMK Size?', answer: 'LMK Size determines the length of the LMK: Double (16 bytes/32 hex) or Triple (24 bytes/48 hex). Most Thales HSMs use double-length LMKs extended to triple-length for 3DES encryption.' },
        { question: 'What is Key Lookup?', answer: 'Key Lookup tries all variants to decrypt an encrypted key. You can filter results by KCV (Key Check Value) and parity type (Odd/Even) to find the exact variant used for encryption.' },
      ],
      usage: [
        'Key Encryption: Enter a plaintext key, select Key Scheme, LMK Size, LMK Pair, enter LMK Key, select Variant, click Encrypt.',
        'Key Decryption: Enter an encrypted key (with or without scheme prefix), configure LMK settings, click Decrypt.',
        'Result shows: Plain/Encrypted Key, KCV, Parity, Key Scheme, LMK Pair, Variant, and output.',
        'Key Lookup: Enter encrypted key, optionally set KCV filter and parity filter.',
        'Click Lookup to try all variants and find matching decryptions.',
        'Results show all matching variants with decoded key, KCV, and parity.',
      ],
    },
    thalesKeyBlock: {
      title: 'Thales Key Block Online - Encode/Decode Proprietary Key Blocks | HSM Kit',
      description: 'Free online Thales Key Block encoder and decoder. Encode and decode Thales proprietary key blocks using KBPK (Key Block Protection Key). Supports 3DES and AES KBPK, various key usages, algorithms, and exportability options. All processing in browser.',
      keywords: 'Thales Key Block, KBPK, Key Block Protection Key, key block encoder, key block decoder, HSM tools, payment security, key management, 3DES, AES, key usage, exportability, Thales key block format',
      faqTitle: 'Thales Key Block FAQ',
      usageTitle: 'How to Use Thales Key Block Tool',
      faqs: [
        { question: 'What is Thales Key Block?', answer: 'Thales Key Block is a proprietary key block format used by Thales HSMs to securely wrap and transport encryption keys. It includes metadata about the key such as usage, algorithm, and exportability.' },
        { question: 'What is KBPK?', answer: 'KBPK (Key Block Protection Key) is the master key used to encrypt/decrypt key blocks. 3DES KBPK is 24 bytes (48 hex), AES KBPK is 32 bytes (64 hex).' },
        { question: 'What is Key Usage?', answer: 'Key Usage (2 characters) defines how the wrapped key can be used: B0=BDK, C0=CVK, D0=Data Encryption, K0=Key Encryption, M0-M8=MAC keys, P0=PIN Encryption, etc.' },
        { question: 'What is Algorithm?', answer: 'Algorithm (1 character) specifies the cryptographic algorithm: A=AES, D=DES, T=Triple DES, R=RSA, E=Elliptic Curve, H=HMAC.' },
        { question: 'What is Mode of Use?', answer: 'Mode of Use defines allowed operations: B=Encrypt/Decrypt, C=Generate/Verify, D=Decrypt only, E=Encrypt only, G=Generate only, N=No restrictions, X=Key derivation.' },
        { question: 'What is Exportability?', answer: 'Exportability controls key export: E=Exportable in trusted key block, N=Not exportable, S=Sensitive (limited export).' },
      ],
      usage: [
        'Encode: Enter KBPK (3DES or AES), plain key, select Version, Key Usage, Algorithm, Mode of Use, Exportability, click Encode.',
        'The encoded key block contains header metadata + encrypted key + MAC for integrity.',
        'Decode: Enter KBPK and paste the key block data, select ASCII or Hex format, click Decode.',
        'Decoded result shows all header fields, decrypted key, KCV, and MAC.',
      ],
    },
    tr31: {
      title: 'TR-31 Key Block Encoder/Decoder Online - ANSI X9.143 | HSM Kit',
      description: 'Free online TR-31 key block encoder and decoder. Wrap and unwrap cryptographic keys using ANSI X9.143 (TR-31) standard with KBPK protection. Supports Version A-E (TDES/AES), all key usages, algorithms, and exportability options. Perfect for payment security.',
      keywords: 'TR-31, key block, ANSI X9.143, TR31 encoder, TR31 decoder, key block wrapper, KBPK, payment HSM, key usage, key exportability, DUKPT, key management, TDES key wrap, AES key wrap, payment security, HSM key exchange',
      faqTitle: 'TR-31 Key Block FAQ',
      usageTitle: 'How to Use TR-31 Key Block Tool',
      faqs: [
        { question: 'What is TR-31?', answer: 'TR-31 (ANSI X9.143) is the industry standard for secure cryptographic key exchange in payment systems. It wraps encryption keys with metadata (key usage, algorithm, mode of use, exportability) protected by a Key Block Protection Key (KBPK).' },
        { question: 'What are the TR-31 versions?', answer: 'Version A uses TDES variant binding, Version B uses TDES key derivation, Version C uses TDES variant binding (alternate), Version D uses AES key derivation (most secure, recommended), Version E uses AES with CMAC binding.' },
        { question: 'What is KBPK?', answer: 'KBPK (Key Block Protection Key) is the master key used to encrypt/decrypt TR-31 key blocks. For TDES versions (A/B/C), use a 16 or 24-byte key. For AES versions (D/E), use a 16, 24, or 32-byte AES key.' },
        { question: 'What is key usage?', answer: 'Key usage (2 characters) defines the wrapped key purpose: B0/B1=BDK/DUKPT, C0=CVK, D0=Data Encryption, E0-E6=EMV Master Keys, K0/K1=Key Wrapping, M0-M8=MAC Keys, P0/P1=PIN Keys, V0-V4=PIN Verification.' },
        { question: 'What is Mode of Use?', answer: 'Mode of Use defines allowed operations: B=Encrypt/Decrypt, C=Generate/Verify, D=Decrypt only, E=Encrypt only, G=Generate only, N=No restrictions, X=Key derivation.' },
        { question: 'What is Exportability?', answer: 'Exportability controls key export: E=Exportable in trusted key block, N=Not exportable, S=Sensitive (limited export).' },
      ],
      usage: [
        'Encode: Enter KBPK (3DES or AES), plain key, select Version, Key Usage, Algorithm, Mode of Use, Exportability, click Encode.',
        'The encoded key block contains header metadata + encrypted key + MAC for integrity.',
        'Decode: Enter KBPK and paste the key block data, click Decode.',
        'Decoded result shows all header fields (Version, Length, Key Usage, Algorithm, Mode of Use, Key Version, Exportability, Opt. Blocks), encrypted data, MAC, decrypted key, and KCV.',
      ],
    },
    kcv: {
      title: 'KCV Calculator Online - Key Check Value Generator | HSM Kit',
      description: 'Free online KCV (Key Check Value) calculator for AES and DES/3DES keys. Verify encryption key correctness by calculating the check value. Supports auto parity adjustment for DES keys. Essential for payment security and key verification.',
      keywords: 'KCV calculator, key check value, KCV generator, AES KCV, DES KCV, 3DES KCV, CMAC, key verification, payment keys, key check value calculator, HSM key verification',
      faqTitle: 'KCV Calculator FAQ',
      usageTitle: 'How to Use KCV Calculator',
      faqs: [
        { question: 'What is KCV (Key Check Value)?', answer: 'KCV is a checksum used to verify that a cryptographic key has been correctly entered or transmitted. It\'s calculated by encrypting a block of zeros and taking the first 3 bytes of the result.' },
        { question: 'How is KCV calculated for DES/3DES?', answer: 'For DES/3DES: Encrypt 8 bytes of zeros (0x0000000000000000) using ECB mode, then take the first 6 hex characters (3 bytes) of the ciphertext.' },
        { question: 'How is KCV calculated for AES?', answer: 'For AES: Calculate CMAC over 16 bytes of zeros using the key, then take the first 6 hex characters (3 bytes) of the MAC value.' },
        { question: 'What is auto parity adjustment?', answer: 'DES keys require odd parity on each byte. If your key doesn\'t have correct parity, enable auto-adjust to fix it before KCV calculation.' },
      ],
      usage: [
        'Select the algorithm (AES or DES/3DES).',
        'Enter your encryption key in hexadecimal format.',
        'For DES keys, optionally enable auto parity adjustment.',
        'Click "Calculate KCV" to generate the key check value.',
        'Compare the KCV with the expected value to verify key correctness.',
      ],
    },
    pinBlock: {
      title: 'PIN Block Generator Online - ISO 9564 Format 0/1/3/4 | HSM Kit',
      description: 'Free online PIN Block generator supporting ISO 9564 formats (Format 0, 1, 3, 4). Generate PIN blocks for payment transactions, ATM, and POS systems. Essential tool for payment security testing. 100% client-side processing.',
      keywords: 'PIN block, ISO 9564, PIN block format 0, PIN block format 4, payment security, ATM PIN, POS PIN, PIN encryption, card PIN, PIN block generator, payment card security',
      faqTitle: 'PIN Block FAQ',
      usageTitle: 'How to Use PIN Block Generator',
      faqs: [
        { question: 'What is a PIN Block?', answer: 'A PIN Block is a standardized format for encoding a PIN (Personal Identification Number) before encryption. It combines the PIN with a fill pattern or PAN data to create a fixed-length block for encryption.' },
        { question: 'What is Format 0 (ISO 9564-1)?', answer: 'Format 0 XORs the PIN block with the rightmost 12 digits of the PAN (excluding check digit). It\'s the most widely used format in payment systems.' },
        { question: 'What is Format 4 (ISO 9564-1:2017)?', answer: 'Format 4 is the newest format designed for AES encryption. It includes random padding and provides better security than older formats.' },
        { question: 'Why is PAN needed for PIN Block?', answer: 'In Format 0 and some others, the PAN is XORed with the PIN data, binding the PIN to a specific card and preventing certain attacks.' },
      ],
      usage: [
        'Select the PIN Block format (0, 1, 3, or 4).',
        'Enter the PIN (4-12 digits).',
        'For formats that require PAN, enter the card number.',
        'Click "Generate" to create the PIN Block.',
        'Use the generated hex string as input for your encryption process.',
      ],
    },
    pinBlockGeneral: {
      title: 'PIN Block Encoder/Decoder - ISO 9564 Formats 0-4 | HSM Kit',
      description: 'Free online PIN Block encoder and decoder supporting all ISO 9564 formats (0, 1, 2, 3, 4). Encode PINs into PIN blocks or decode PIN blocks back to PIN. Essential tool for payment security, HSM testing, and card transaction development. 100% client-side processing.',
      keywords: 'PIN block encoder, PIN block decoder, ISO 9564, PIN block format 0, PIN block format 1, PIN block format 2, PIN block format 3, PIN block format 4, PIN encryption, payment security, HSM testing, card PIN, PAN, PIN decoder, ATM PIN, POS PIN',
      faqTitle: 'PIN Block Encoder/Decoder FAQ',
      usageTitle: 'How to Use PIN Block Tool',
      faqs: [
        { question: 'What are the differences between PIN Block formats?', answer: 'Format 0 (ISO-0): The most widely used format, XORs the PIN with the rightmost 12 digits of the PAN (excluding check digit). Structure: 0L[PIN][Padding] XOR 0000[PAN-12]. Format 1 (ISO-1): Uses random padding instead of PAN XOR, suitable when PAN is not available. Structure: 1L[PIN][Random-Padding]. Format 2 (ISO-2): Similar to Format 0 but with "2" control field. Format 3 (ISO-3): Combines Format 1\'s random padding with Format 0\'s PAN XOR for enhanced security. Format 4 (ISO-4): The newest format designed for AES encryption, uses 128-bit block (32 hex chars) instead of 64-bit.' },
        { question: 'When should I use Format 0 vs Format 1?', answer: 'Use Format 0 in card-based payment systems (ATM, POS, EMV) where PAN is available - it binds the PIN to a specific card number, preventing PIN blocks from being replayed on different cards. Use Format 1 for general-purpose PIN transmission where card binding is not required, such as customer service systems, PIN mailers, or scenarios where PAN is not yet known. Format 1 provides PIN confidentiality but not card binding.' },
        { question: 'What is the padding character and why does it matter?', answer: 'The padding character (typically "F" in hexadecimal) fills the remaining positions after the PIN digits to create a fixed 16-character (8-byte) block for Formats 0-3, or 32-character (16-byte) block for Format 4. This fixed length is required for block cipher encryption algorithms (DES, 3DES, AES). Different payment networks may use different padding: "F" is most common, but some systems use "0" or random hex digits. The padding character must match between encoding and decoding for correct PIN recovery.' },
        { question: 'Can I decode a PIN block without the PAN?', answer: 'Only Format 1 can be decoded without a PAN, because it uses random padding and does not XOR with PAN data. Formats 0, 2, 3, and 4 all require the correct PAN to reverse the XOR operation. If you attempt to decode a Format 0 PIN block with an incorrect PAN, you will get an incorrect PIN. This PAN-binding provides security against PIN block interception attacks - an attacker cannot reuse a captured Format 0 PIN block on a different card.' },
        { question: 'What is Format 4 and why is it important?', answer: 'Format 4 is the latest PIN block format defined in ISO 9564-1:2017, specifically designed for AES encryption. Unlike older formats that use 64-bit blocks (16 hex characters) designed for DES/3DES, Format 4 uses 128-bit blocks (32 hex characters) matching AES block size. It provides enhanced security through larger block size, random padding, and support for longer PINs (up to 12 digits). Format 4 is being adopted in modern payment systems as the industry transitions from 3DES to AES encryption, particularly in EMV contactless and mobile payment applications.' },
        { question: 'How does the PIN length indicator work?', answer: 'The second character of all PIN block formats is the PIN length indicator in hexadecimal. For a 4-digit PIN, it\'s "4"; for a 6-digit PIN, it\'s "6"; for a 12-digit PIN, it\'s "C" (12 in hex). This allows the receiving system to extract exactly the right number of PIN digits from the block. The minimum PIN length is typically 4 digits, maximum is 12 digits. The length indicator is crucial for correct PIN extraction during decoding - without it, the system wouldn\'t know where the PIN ends and padding begins.' },
        { question: 'What security considerations should I know?', answer: 'Never transmit or store PIN blocks without encryption - they should always be encrypted with a PIN Encryption Key (PEK) or Zone PIN Key (ZPK). PIN blocks are only intermediate format; the encrypted PIN block is what travels across networks. Format 0 PIN blocks can be vulnerable to precomputation attacks if the same PAN is used repeatedly - use Format 3 or Format 4 for enhanced security. Always use random padding when possible (Formats 1, 3, 4). In production systems, PIN blocks should be generated inside secure Hardware Security Modules (HSMs), never in software.' },
      ],
      usage: [
        'Select PIN Block Format: Choose from Format 0 (ISO-0, most common, requires PAN), Format 1 (ISO-1, random padding, no PAN needed), Format 2 (ISO-2, alternative to Format 0), Format 3 (ISO-3, random padding with PAN), or Format 4 (ISO-4, for AES encryption, 32 hex output). Format 0 is standard for ATM/POS transactions, Format 4 is used in modern AES-based systems.',
        'Choose Operation Mode: Select "Encode" to convert a clear PIN into a PIN block for transmission/storage, or select "Decode" to extract the original PIN from a PIN block. Encoding is used when initializing PINs or preparing for encryption. Decoding is used for PIN verification at acquiring banks or during HSM testing.',
        'Enter PAN (Primary Account Number): For Formats 0, 2, 3, and 4, enter the full card number (13-19 digits). The tool automatically extracts the rightmost 12 digits excluding the check digit for XOR operations. The PAN must match exactly between encoding and decoding for correct PIN recovery. Format 1 does not require PAN input.',
        'Enter PIN (Encoding Mode): Input the customer\'s PIN as 4-12 decimal digits (0-9 only). Common lengths are 4 digits (ATM standard), 6 digits (online banking), or variable length up to 12 digits. The tool validates PIN length and automatically adds the length indicator to the PIN block. Never use sequential (1234) or repeated (1111) PINs in production.',
        'Enter PIN Block (Decoding Mode): Paste the PIN block in hexadecimal format - 16 hex characters (32 digits) for Formats 0-3, or 32 hex characters (64 digits) for Format 4. The tool parses the format identifier (first character) and length indicator (second character) to extract the PIN. Ensure the PIN block has not been encrypted yet - this tool works with clear PIN blocks only.',
        'Adjust Padding Character (Optional): For encoding, you can change the padding character from the default "F" to match your system requirements. Some networks use "0" padding or random hex digits. The padding character must be a single hexadecimal digit (0-9, A-F). This setting only affects Formats 0-3; Format 4 uses its own padding scheme.',
        'Process and Verify Result: Click "Encode" or "Decode" button. For encoding, the result shows the complete PIN block in hexadecimal with format identifier, length indicator, PIN digits, and padding. For decoding, the result displays the extracted PIN and format details. Copy the result using the Copy button. The tool also shows PIN length, block length, and format type for verification. In production, this clear PIN block would then be encrypted with a PIN Encryption Key (PEK) using 3DES or AES before transmission.',
      ],
    },
    pinBlockAes: {
      title: 'AES PIN Block Format 4 Encryption/Decryption Online | HSM Kit',
      description: 'Free online AES PIN Block Format 4 encryption and decryption tool. Encrypt PIN blocks with AES-128 or decrypt AES-encrypted PIN blocks. Essential for modern payment systems using AES encryption. 100% client-side processing.',
      keywords: 'AES PIN block, PIN block format 4, AES-128 encryption, PIN block encryption, PIN block decryption, AES PIN, payment security, ISO 9564-1:2017, AES ECB, PIN encryption tool',
      faqTitle: 'AES PIN Block FAQ',
      usageTitle: 'How to Use AES PIN Block Tool',
      faqs: [
        { question: 'What is PIN Block Format 4?', answer: 'PIN Block Format 4 is the newest format defined in ISO 9564-1:2017, specifically designed for AES encryption. It uses a 128-bit (16-byte) block size, represented as 32 hexadecimal characters, making it suitable for modern AES-based payment systems.' },
        { question: 'How is Format 4 different from Format 0?', answer: 'Format 4 uses a 32-character hex block (128 bits) instead of 16 characters (64 bits), making it compatible with AES encryption. It also uses different padding patterns and includes enhanced security features designed for modern cryptographic standards.' },
        { question: 'What encryption algorithm is used?', answer: 'This tool uses AES-128 in ECB mode with no padding. The PIN block is 16 bytes (128 bits), matching the AES block size perfectly. The clear PIN block is XORed with the PAN block before encryption for additional security.' },
        { question: 'Can I use AES-192 or AES-256?', answer: 'This implementation uses AES-128 (16-byte key) as it is the most common in payment systems. AES-192 and AES-256 require 24-byte and 32-byte keys respectively and may be supported in future versions.' },
        { question: 'Why does the tool show intermediate blocks?', answer: 'The tool displays the clear PIN block and PAN block to help understand the Format 4 structure and XOR operation. This is educational and useful for debugging, but in production systems, only the encrypted block should be transmitted.' },
      ],
      usage: [
        'Select "Encrypt" to encrypt a PIN into an AES PIN block, or "Decrypt" to extract a PIN from an encrypted block.',
        'Enter the AES-128 key (32 hex characters / 16 bytes) used for encryption/decryption.',
        'Enter the PAN (Primary Account Number / card number, 13-19 digits).',
        'For encryption: Enter the PIN (4-12 digits).',
        'For decryption: Enter the encrypted PIN block (32 hex characters).',
        'Click Encrypt or Decrypt to process.',
        'The result shows the encrypted block (for encryption) or the decrypted PIN (for decryption), along with intermediate clear blocks.',
      ],
    },
    pinOffset: {
      title: 'PIN Offset Calculator - IBM 3624 Method Online | HSM Kit',
      description: 'Free online PIN Offset calculator using IBM 3624 method. Calculate PIN offset from customer PIN or verify PIN with offset. Supports 3DES encryption with PDK, decimalization table, and flexible validation data methods. Essential tool for PIN management.',
      keywords: 'PIN offset, IBM 3624, PIN offset calculator, natural PIN, decimalization table, PDK, PIN derivation key, PIN verification, customer PIN, validation data, 3DES encryption, PIN management',
      faqTitle: 'PIN Offset FAQ',
      usageTitle: 'How to Use PIN Offset Tool',
      faqs: [
        { question: 'What is PIN Offset?', answer: 'PIN Offset is the difference between a customer\'s chosen PIN and the "natural PIN" calculated from their card data. It allows the issuer to support customer-selected PINs while maintaining a cryptographic verification method. The offset is calculated as (Customer PIN - Natural PIN) mod 10.' },
        { question: 'What is the IBM 3624 method?', answer: 'IBM 3624 is a widely-used PIN generation and verification method. It encrypts the PAN with a PIN Derivation Key (PDK) using 3DES, applies a decimalization table to convert hex to digits, extracts validation data, and calculates the offset or verifies the PIN.' },
        { question: 'What is a decimalization table (DecTab)?', answer: 'A decimalization table (DecTab) is a 16-digit lookup table used to convert hexadecimal digits (0-F) to decimal digits (0-9). The default is "0123456789012345" but can be customized. Each hex digit is replaced by the corresponding position in the table.' },
        { question: 'What is the difference between validation data parameters and mask?', answer: 'Validation data parameters (Start, Length, Pad, PIN Length) extract a fixed-length substring from the natural PIN. Validation data mask allows more flexible extraction using a pattern where "N" represents natural PIN digits and 0-9 are fixed values (e.g., "0000000N0000").' },
        { question: 'How do I verify a PIN with an offset?', answer: 'Use the PIN tab: enter PDK, PAN, PIN offset, and validation parameters. The tool calculates the natural PIN, extracts validation data, and adds the offset to get the customer PIN: (Validation Data + Offset) mod 10.' },
      ],
      usage: [
        'Use the "Offset" tab to calculate PIN offset from a customer PIN, or "PIN" tab to verify/calculate PIN from offset.',
        'Enter the PDK (Pin Derivation Key) - 32 hex characters (16 bytes) 3DES key.',
        'Enter the PAN (Primary Account Number) - 12-19 digits.',
        'Enter the decimalization table (DecTab) - 16 digits, default: 0123456789012345.',
        'Choose validation data method: parameters (Start, Length, Pad, PIN Length) or mask pattern.',
        'For Offset tab: enter customer PIN and click Calculate Offset.',
        'For PIN tab: enter PIN offset and click Calculate PIN to get the customer\'s PIN.',
      ],
    },
    pinPvv: {
      title: 'PIN PVV Calculator - Visa PIN Verification Value Online | HSM Kit',
      description: 'Free online PIN PVV (PIN Verification Value) calculator using Visa standard algorithm. Calculate PVV from customer PIN or verify PIN with PVV. Supports 3DES encryption with PDK, PVKI selection, and decimalization. Essential tool for card payment security.',
      keywords: 'PIN PVV, PIN Verification Value, Visa PVV, PVV calculator, PDK, PVKI, PIN verification, card security, payment security, 3DES encryption, decimalization, TSP, PIN derivation',
      faqTitle: 'PIN PVV FAQ',
      usageTitle: 'How to Use PIN PVV Tool',
      faqs: [
        { question: 'What is PIN PVV?', answer: 'PIN Verification Value (PVV) is a Visa standard for PIN verification. It\'s a 4-digit value calculated from the customer PIN, card number (PAN), and a secret PIN Derivation Key (PDK) using 3DES encryption and decimalization. Banks use PVV to verify customer PINs without storing the actual PIN.' },
        { question: 'How is PVV calculated?', answer: 'PVV calculation: 1) Encrypt the PAN (right-aligned, zero-padded) with the PDK using 3DES ECB. 2) Apply decimalization table to convert hex to digits (0-9 stay, A-F map to 0-5). 3) Extract 4 digits starting at position PVKI (Transformed Selection Process - TSP). 4) Calculate PVV by adding PIN and TSP digit-by-digit modulo 10.' },
        { question: 'What is PVKI?', answer: 'PVKI (PIN Verification Key Index) is a value from 0-9 that determines which position in the encrypted PAN to start extracting digits for TSP. Different cards can use different PVKI values to add variation to the verification process. The PVKI is typically stored with the card account.' },
        { question: 'What is TSP in PVV calculation?', answer: 'TSP (Transformed Selection Process) is a 4-digit value extracted from the decimalized encrypted PAN starting at the position indicated by PVKI. It\'s combined with the customer PIN to produce the PVV. The TSP acts as a cryptographic salt that varies per card.' },
        { question: 'How do I verify a PIN using PVV?', answer: 'Use the PIN tab: enter PDK, PAN, PVV (stored value), and PVKI. The tool calculates the natural PIN by encrypting the PAN, extracting TSP, and reversing the PVV formula: PIN = (PVV - TSP) mod 10. Compare the result with the customer-entered PIN to verify correctness.' },
      ],
      usage: [
        'Use the "PVV" tab to calculate PVV from a customer PIN, or "PIN" tab to verify/calculate PIN from a known PVV.',
        'Enter the PDK (PIN Derivation Key) - 32 hex characters (16 bytes) 3DES key.',
        'Enter the PAN (Primary Account Number) - 12-19 digits.',
        'For PVV tab: enter customer PIN (4-12 digits) and PVKI (0-9), then click Calculate PVV.',
        'For PIN tab: enter PVV (4 digits) and PVKI (0-9), then click Calculate PIN.',
        'The result shows the calculated value along with intermediate values (Encrypted PAN and TSP) for verification.',
      ],
    },
    bitmap: {
      title: 'ISO8583 Bitmap Encoder/Decoder Online - Payment Message Bitmap | HSM Kit',
      description: 'Free online ISO 8583 bitmap encoder and decoder. Parse hex bitmap to see which fields are present in payment messages. Supports primary (1-64) and secondary (65-128) bitmaps. Essential tool for ISO8583 message analysis.',
      keywords: 'ISO 8583 bitmap, bitmap decoder, bitmap encoder, payment message, ISO8583 fields, primary bitmap, secondary bitmap, financial transaction, payment protocol, message bitmap',
      faqTitle: 'ISO8583 Bitmap FAQ',
      usageTitle: 'How to Use Bitmap Tool',
      faqs: [
        { question: 'What is an ISO 8583 bitmap?', answer: 'The bitmap in ISO 8583 is a field that indicates which data elements are present in the message. Each bit position corresponds to a data field number. If a bit is set to 1, that field is included in the message.' },
        { question: 'What is the difference between primary and secondary bitmaps?', answer: 'The primary bitmap (64 bits) covers fields 1-64. If bit 1 is set, a secondary bitmap follows, covering fields 65-128. This allows ISO 8583 messages to contain up to 128 data fields.' },
        { question: 'How is the bitmap encoded?', answer: 'The bitmap is typically encoded as hexadecimal. The primary bitmap is 16 hex characters (64 bits). If the first bit is set (bit 1), an additional 16 hex characters follow for the secondary bitmap.' },
        { question: 'How do I know which fields are present?', answer: 'Enter the hex bitmap in the tool, and it will display all bit positions (1-64 or 1-128). Checked boxes indicate fields present in the message. You can also build a bitmap by selecting the fields you need.' },
      ],
      usage: [
        'Enter a hex bitmap string to decode it and see which field bits are set.',
        'Alternatively, check/uncheck the bit checkboxes to build your own bitmap.',
        'Bit 1 controls the presence of the secondary bitmap (fields 65-128).',
        'The hex bitmap updates automatically as you check or uncheck bits.',
        'Copy the generated bitmap hex for use in your ISO8583 messages.',
      ],
    },
    visaCertificates: {
      title: 'VISA Certificates Validator - Validate Issuer Signing Request & Signed Public Key Data | HSM Kit',
      description: 'Free online VISA certificate validator. Validate VISA issuer certificate signing requests and verify signed issuer public key data using CA public keys. Supports VSDC CA V92, V94, and custom CA keys. Essential tool for payment card certificate management and EMV certification.',
      keywords: 'VISA certificates, issuer signing request, certificate validation, CA public key, signed certificate, EMV certificates, payment card security, VISA CA, issuer public key, certificate signing, VSDC CA, EMV certification',
      faqTitle: 'VISA Certificates FAQ',
      usageTitle: 'How to Use VISA Certificates Tool',
      faqs: [
        { question: 'What is a VISA Issuer Certificate?', answer: 'A VISA Issuer Certificate is a digital certificate issued by VISA that contains the issuer\'s public key. It is used in EMV chip card transactions to authenticate the card issuer and establish a chain of trust from the payment scheme to the card.' },
        { question: 'What is an Issuer Signing Request?', answer: 'An Issuer Signing Request (CSR) is a request sent to VISA CA to sign the issuer\'s public key. It contains the public key modulus, exponent, and other certificate information that needs to be certified by VISA before it can be used in production.' },
        { question: 'How do I validate a signed certificate?', answer: 'To validate a signed certificate, you need the signed issuer public key data and the corresponding VISA CA public key. This tool verifies the RSA signature to ensure the certificate is authentic, hasn\'t been tampered with, and was genuinely signed by VISA.' },
        { question: 'What CA public keys are supported?', answer: 'This tool includes predefined VISA CA public keys for VSDC CA V92 and V94 (commonly used in EMV certifications). You can also load custom CA public keys if you need to verify certificates signed by other VISA CA versions or test CAs.' },
        { question: 'Why is certificate validation important?', answer: 'Certificate validation ensures that issuer public keys have been properly certified by VISA and haven\'t been altered. This maintains the security chain in EMV transactions, preventing fraudulent cards from being accepted by terminals.' },
      ],
      usage: [
        'Use "Validate Issuer Signing Request" tab to check certificate requests before sending to VISA CA for signing.',
        'Load the certificate request file or paste hex data, then click Validate to verify structure and format.',
        'Use "Validate Signed Issuer Public Key Data" tab to verify certificates received from VISA CA.',
        'Load or paste the signed certificate data, select a predefined CA key (VSDC CA V92/V94) or load a custom CA public key.',
        'Click Validate to verify the signature using RSA verification with the selected CA public key.',
        'Enable Debug mode to see detailed information about certificate structure, modulus, exponent, and validation steps.',
      ],
    },
    cvv: {
      title: 'CVV/CVC Calculator Online - Generate & Validate Card Verification Value | HSM Kit',
      description: 'Free online CVV/CVC calculator and validator. Generate and validate CVV, CVC, iCVV, CVV2, CVC2, and dCVV for payment card security. Supports Visa, Mastercard, Amex. Essential tool for card payment testing and security.',
      keywords: 'CVV calculator, CVC calculator, CVV generator, CVV validator, iCVV, CVV2, CVC2, dCVV, card verification value, card security code, payment card security, CVK key, card verification',
      faqTitle: 'CVV/CVC FAQ',
      usageTitle: 'How to Use CVV Calculator',
      faqs: [
        { question: 'What is CVV/CVC?', answer: 'CVV (Card Verification Value) for Visa and CVC (Card Verification Code) for Mastercard are 3-digit security codes used to verify card-not-present transactions. They are calculated using card data encrypted with the issuer\'s CVK keys.' },
        { question: 'What is the difference between CVV and CVV2?', answer: 'CVV (CVV1) is encoded on the magnetic stripe. CVV2 is the 3-digit code printed on the back of the card. CVV2 provides additional security for card-not-present transactions like online purchases.' },
        { question: 'What is iCVV?', answer: 'iCVV (integrated Circuit CVV) is used for chip cards. It includes the ATC (Application Transaction Counter) in the calculation, making it unique for each transaction and providing enhanced security.' },
        { question: 'What is dCVV?', answer: 'dCVV (dynamic CVV) is used for contactless payments. Like iCVV, it uses the ATC to generate a unique verification value for each transaction, preventing replay attacks.' },
        { question: 'What are CVK keys?', answer: 'CVK (Card Verification Key) consists of two 16-byte DES keys (CVK-A and CVK-B) used by the card issuer to generate and validate CVV values. These keys must be kept secure as they protect all cards issued by that institution.' },
      ],
      usage: [
        'Select Generate tab to create a CVV, or Validate tab to verify an existing CVV.',
        'Enter CVK A and CVK B keys (32 hex characters each).',
        'Enter PAN (Primary Account Number), expiry date (YYMM), and service code (3 digits).',
        'For iCVV or dCVV, also enter the ATC (Application Transaction Counter).',
        'Select the verification type: CVV/CVC, iCVV, CVV2/CVC2, or dCVV.',
        'Click Generate to create the CVV, or enter the CVV and click Validate to verify.',
      ],
    },
    amexCsc: {
      title: 'AMEX CSC Calculator Online - Generate & Validate American Express Card Security Code | HSM Kit',
      description: 'Free online AMEX CSC calculator and validator. Generate and validate CSC, CSC-5, CSC-4, and CSC-3 for American Express cards. Supports CSC version 1 and 2. Essential tool for AMEX card payment testing.',
      keywords: 'AMEX CSC calculator, AMEX CSC generator, American Express CSC, CSC-5, CSC-4, CSC-3, card security code, AMEX card verification, payment card security, CSC key, AMEX validation',
      faqTitle: 'AMEX CSC FAQ',
      usageTitle: 'How to Use AMEX CSC Calculator',
      faqs: [
        { question: 'What is AMEX CSC?', answer: 'AMEX CSC (Card Security Code) is American Express\'s version of card verification value. It\'s similar to CVV/CVC but uses a 15-digit PAN specific to AMEX cards.' },
        { question: 'What is the difference between CSC version 1 and 2?', answer: 'CSC version 1 generates a 4-digit code for the magnetic stripe. CSC version 2 is enhanced and generates CSC-5 (5 digits), CSC-4 (4 digits), and CSC-3 (3 digits printed on the front of the card).' },
        { question: 'Where is CSC-3 located?', answer: 'CSC-3 is the 3-digit or 4-digit code printed on the front of American Express cards, typically above the card number on the right side.' },
        { question: 'What is CSC-5 used for?', answer: 'CSC-5 is a 5-digit code used internally for enhanced card verification in version 2. It provides additional security layers for transaction validation.' },
        { question: 'How is AMEX CSC different from Visa/Mastercard CVV?', answer: 'AMEX uses 15-digit PANs (vs 16 for Visa/MC) and has a different algorithm. AMEX CSC version 2 also provides multiple verification values (CSC-5, CSC-4, CSC-3) for different use cases.' },
      ],
      usage: [
        'Select CSC version: Version 1 (4-digit magnetic stripe) or Version 2 (enhanced with CSC-5, CSC-4, CSC-3).',
        'Enter CSC Key (32 or 48 hex characters) - the issuer\'s card security key.',
        'Enter AMEX PAN (15 digits), expiry date (YYMM), and service code (3 digits).',
        'Click Generate to create the CSC values, or enter a CSC and click Validate to verify.',
        'Version 2 generates multiple codes: CSC-5 (5 digits), CSC-4 (4 digits), CSC-3 (3 digits).',
      ],
    },
    mastercardCvc3: {
      title: 'MasterCard CVC3 Calculator Online - Generate & Validate Dynamic CVC3 | HSM Kit',
      description: 'Free online MasterCard dynamic CVC3 calculator and validator. Generate and validate dynamic CVC3 and PIN-CVC3 for contactless EMV cards. Essential tool for MasterCard payment testing.',
      keywords: 'MasterCard CVC3, dynamic CVC3, PIN-CVC3, contactless payment, EMV card, ICC Master Key, IMK, card verification, payment security, ATC, unpredictable number',
      faqTitle: 'MasterCard CVC3 FAQ',
      usageTitle: 'How to Use MasterCard CVC3 Calculator',
      faqs: [
        { question: 'What is MasterCard dynamic CVC3?', answer: 'MasterCard dynamic CVC3 is a 3-digit security code generated dynamically for each contactless EMV transaction. Unlike static CVV/CVC, it changes for every transaction, providing enhanced security.' },
        { question: 'What is the difference between dynamic CVC3 and PIN-CVC3?', answer: 'Dynamic CVC3 is used for contactless transactions without PIN verification. PIN-CVC3 is generated when PIN verification is performed during the transaction, providing an additional security layer.' },
        { question: 'What is IMK?', answer: 'IMK (ICC Master Key) is the issuer\'s master key used to derive card-specific keys. It\'s used to generate MK-CVC3, which then produces the dynamic CVC3 for each transaction.' },
        { question: 'What is the Unpredictable Number?', answer: 'The Unpredictable Number (UN) is a random value provided by the terminal for each transaction. It ensures that even with identical transaction data, the CVC3 will be different each time.' },
        { question: 'Why is Track 1/2 Data needed?', answer: 'Track 1/2 Data contains card information read from the magnetic stripe or stored in the EMV chip. It\'s part of the input data used to calculate the CVC3, ensuring the code is specific to the card and transaction.' },
      ],
      usage: [
        'Enter IMK (32 hex characters) - the ICC Master Key from the card issuer.',
        'Enter PAN (13-19 digits), PAN Sequence Number (2 digits), and ATC (4 hex characters).',
        'Enter Track 1/2 Data (up to 128 hex characters) and Unpredictable Number (8 hex characters).',
        'Select CVC3 type: dynamic CVC3 (standard contactless) or PIN-CVC3 (with PIN verification).',
        'Click Generate to create the 3-digit CVC3, or enter a CVC3 and click Validate to verify.',
      ],
    },
    dukpt: {
      title: 'DUKPT Calculator Online - ISO 9797 Key Derivation & Encryption | HSM Kit',
      description: 'Free online DUKPT calculator for ISO 9797 standard. Derive PEK keys from BDK/IPEK and KSN. Encrypt/decrypt PIN blocks, calculate MAC, and process data. Essential tool for POS and ATM system development.',
      keywords: 'DUKPT calculator, ISO 9797, PEK derivation, BDK, IPEK, KSN, PIN encryption, MAC calculation, POS security, ATM security, key derivation, payment terminal',
      faqTitle: 'DUKPT FAQ',
      usageTitle: 'How to Use DUKPT Calculator',
      faqs: [
        { question: 'What is DUKPT?', answer: 'DUKPT (Derived Unique Key Per Transaction) is a key management scheme that derives a unique encryption key for each transaction from a Base Derivation Key (BDK) and Key Serial Number (KSN). It is widely used in POS terminals and ATM systems.' },
        { question: 'What is the difference between BDK and IPEK?', answer: 'BDK (Base Derivation Key) is the master key held by the key injection facility. IPEK (Initial PIN Encryption Key) is the first derived key injected into the device. IPEK is derived from BDK and the device\'s KSN base.' },
        { question: 'What is KSN?', answer: 'KSN (Key Serial Number) is a 10-byte value that uniquely identifies each transaction. It contains the device serial number and a transaction counter. Each KSN produces a unique derived key.' },
        { question: 'Why is DUKPT considered secure?', answer: 'DUKPT is secure because each transaction uses a different encryption key. If a key is compromised, it cannot be used to decrypt past transactions (forward secrecy). Only future transactions using that specific device would be at risk.' },
        { question: 'What is Data Variant in DUKPT?', answer: 'Data Variant is a key modification technique where the encryption key is XORed with a fixed pattern (typically 0x000...0FF) before use. This creates different keys for different purposes (PIN, MAC, Data) from the same derived key.' },
      ],
      usage: [
        'For PEK Derivation: Enter BDK/IPEK (32 hex) and KSN (20 hex), then click "Derive PEK" to generate the PIN Encryption Key.',
        'For PIN Encryption: Enter PEK and PIN block, then click "Encrypt" or "Decrypt".',
        'For MAC Calculation: Enter PEK, select algorithm (DES/3DES), enter data, then click "Calculate MAC".',
        'For Data Encryption: Enter PEK, optionally enable Data Variant, select input type (ASCII/Hex), enter data, then click "Encrypt" or "Decrypt".',
      ],
    },
    dukptAes: {
      title: 'DUKPT AES Calculator Online - AES Key Derivation & Encryption | HSM Kit',
      description: 'Free online DUKPT AES calculator with support for AES-128, AES-192, AES-256, 2TDEA, and 3TDEA. Derive working keys from BDK/IK and KSN. Essential tool for modern POS and payment terminal development.',
      keywords: 'DUKPT AES calculator, AES-128, AES-192, AES-256, 2TDEA, 3TDEA, working key derivation, BDK, IK, KSN, PIN encryption, MAC calculation, POS security, payment terminal, key management',
      faqTitle: 'DUKPT AES FAQ',
      usageTitle: 'How to Use DUKPT AES Calculator',
      faqs: [
        { question: 'What is DUKPT AES?', answer: 'DUKPT AES is an extension of the original DUKPT (Derived Unique Key Per Transaction) standard that adds support for AES encryption algorithms (AES-128, AES-192, AES-256) in addition to traditional TDEA (Triple DES).' },
        { question: 'What key types are supported?', answer: 'DUKPT AES supports 2TDEA (16-byte keys), 3TDEA (24-byte keys), AES-128 (16-byte keys), AES-192 (24-byte keys), and AES-256 (32-byte keys). Each provides different levels of security and performance.' },
        { question: 'What is the difference between BDK and IK?', answer: 'BDK (Base Derivation Key) is the root key used by key injection facilities. IK (Initial Key) is the first derived key loaded into a device. Both can be used as starting points for DUKPT key derivation.' },
        { question: 'Why use AES instead of TDEA?', answer: 'AES offers stronger security, better performance, and is the modern encryption standard. AES-128 provides equivalent security to 3TDEA but with better speed. AES-256 provides even stronger protection for highly sensitive data.' },
        { question: 'What is the KSN format?', answer: 'KSN (Key Serial Number) is a 12-byte (24 hex characters) value that includes the device serial number and a transaction counter. It ensures each transaction uses a unique derived key.' },
      ],
      usage: [
        'Select key type (BDK/IK) and working key type (2TDEA, 3TDEA, AES-128, AES-192, or AES-256).',
        'Enter BDK/IK with correct length based on key type (32/48/64 hex) and KSN (24 hex).',
        'Click "Derive Key" to generate the working key for the specific transaction.',
        'Use derived key for PIN encryption/decryption, MAC calculation, or data encryption operations.',
      ],
    },
    iso9797Mac: {
      title: 'ISO/IEC 9797-1 MAC Calculator Online - Message Authentication Code Generator | HSM Kit',
      description: 'Free online ISO/IEC 9797-1 MAC calculator supporting all 6 algorithms (1-6) with multiple padding methods. Generate Message Authentication Codes for financial transactions, payment systems, and security applications. Client-side tool - your keys never leave your device.',
      keywords: 'ISO 9797 MAC, ISO 9797-1, MAC calculator, message authentication code, DES MAC, 3DES MAC, CBC-MAC, payment MAC, retail MAC, wholesale MAC, financial MAC, ISO9797, block cipher MAC, cryptographic MAC, secure MAC, banking MAC, algorithm 1, algorithm 2, algorithm 3, padding method 1, padding method 2',
      faqTitle: 'ISO 9797-1 MAC FAQ',
      usageTitle: 'How to Use ISO 9797-1 MAC Calculator',
      faqs: [
        { question: 'What is ISO/IEC 9797-1?', answer: 'ISO/IEC 9797-1 is an international standard that defines multiple MAC (Message Authentication Code) algorithms for data integrity and authentication using block ciphers like DES and 3DES. It is widely used in financial and payment systems for message authentication.' },
        { question: 'Which MAC algorithm should I use?', answer: 'Algorithm 1 (DES CBC-MAC) is the simplest. Algorithm 2 uses dual keys for enhanced security. Algorithm 3 (Retail MAC) is most secure with DES CBC and final 3DES encryption. Choose based on your security requirements, system compatibility, and industry standards.' },
        { question: 'What are the padding methods?', answer: 'Method 1 pads with zeros (0x00), suitable for most cases. Method 2 uses 0x80 followed by zeros (ISO 7816-4), providing better security against certain attacks. Method 3 includes the data length for additional integrity. Method 2 is recommended for maximum security.' },
        { question: 'What is the truncation parameter?', answer: 'Truncation specifies how many bytes (1-8) of the final MAC value to output. Common values are 4 bytes (8 hex characters) for efficiency or 8 bytes (16 hex characters) for full security. Industry standards may specify required truncation lengths.' },
        { question: 'How many keys do I need?', answer: 'Algorithm 1 requires 1 key (K). Algorithm 2 requires 2 keys (K, K2). Algorithm 3 requires 2 keys (K, K\') for 3DES operation. Enter keys in hexadecimal format, typically 16 or 32 characters.' },
      ],
      usage: [
        'Select the MAC algorithm (Algorithm 1-6) from the dropdown menu.',
        'Enter the required keys in hexadecimal format (16 or 32 hex characters per key).',
        'Choose the padding method: Method 1 (zeros), Method 2 (0x80 + zeros), or Method 3 (with length).',
        'Enter your data in hexadecimal format in the data field.',
        'Set the truncation length (1-8 bytes) for the output MAC size.',
        'Click "Calculate MAC" to generate the Message Authentication Code.',
        'Copy the resulting MAC for use in your application or verification process.',
      ],
    },
    ansiMac: {
      title: 'ANSI MAC Calculator Online - X9.9 & X9.19 MAC Generator | HSM Kit',
      description: 'Free online ANSI MAC calculator for X9.9 (Wholesale) and X9.19 (Retail) algorithms. Generate message authentication codes for financial transactions with DES and 3DES encryption.',
      keywords: 'ANSI MAC, X9.9 MAC, X9.19 MAC, wholesale MAC, retail MAC, financial MAC, payment MAC, DES MAC, 3DES MAC, CBC-MAC, message authentication',
      faqTitle: 'ANSI MAC FAQ',
      usageTitle: 'How to Use ANSI MAC Calculator',
      faqs: [
        { question: 'What is ANSI X9.9?', answer: 'ANSI X9.9 (Wholesale MAC) is a Message Authentication Code algorithm that uses DES encryption in CBC (Cipher Block Chaining) mode. It processes data in 8-byte blocks, XORing each block with the previous encrypted output. The final encrypted block becomes the MAC. Widely used in wholesale banking and interbank financial transactions for message integrity verification.' },
        { question: 'What is ANSI X9.19?', answer: 'ANSI X9.19 (Retail MAC) is an enhanced MAC algorithm designed for retail payment systems. It uses single DES for all data blocks in CBC mode, but applies Triple DES (3DES) encryption to the final block for increased security. This hybrid approach provides stronger protection against cryptanalytic attacks while maintaining backward compatibility with X9.9 systems in retail environments.' },
        { question: 'When should I use X9.19 instead of X9.9?', answer: 'Use X9.19 for retail/consumer transactions (POS terminals, ATMs, card payments) requiring higher security due to the 3DES final block encryption. Use X9.9 for wholesale/institutional transactions (interbank transfers, clearing systems) where both parties operate in secure environments. X9.19 is recommended for all new implementations due to stronger cryptographic protection.' },
        { question: 'What are the key requirements for ANSI MAC?', answer: 'For X9.9: A single DES key (64-bit, 16 hex characters, with parity bits making it effectively 56-bit). For X9.19: Either a single DES key (used twice in 3DES) or two separate DES keys (K and K\') for the final 3DES encryption. Keys must have proper parity and should be cryptographically strong. Data is zero-padded to 8-byte boundaries before processing.' },
        { question: 'How does MAC truncation work?', answer: 'MAC truncation reduces the 8-byte (64-bit) MAC output to a shorter length for transmission efficiency. Common truncation values are 4 bytes (32 bits) for standard security or 6 bytes (48 bits) for enhanced security. Truncation uses the leftmost N bytes of the final MAC block. Note that shorter MACs reduce security - a 4-byte MAC provides 2^32 possible values, making brute force more feasible than the full 8-byte MAC with 2^64 possibilities.' }
      ],
      usage: [
        'Select MAC algorithm: X9.9 (Wholesale) for DES CBC-MAC, or X9.19 (Retail) for 3DES final block.',
        'Enter the primary DES key K (16 hex). For X9.19 with separate keys, also enter K\' (16 hex).',
        'Enter data in hexadecimal format (auto-padded to 8-byte blocks).',
        'Set truncation length (1-8 bytes). Standard is 4 bytes for most applications.',
        'Click "Calculate MAC" and copy the result.',
      ],
    },
    as2805Mac: {
      title: 'AS2805 MAC Calculator Online - Australian Payment MAC | HSM Kit',
      description: 'Free online AS2805.4.1 MAC calculator for Australian EFTPOS payment systems. Generate MACs using Method 1 (DES) or Method 2 (DES with 3DES final block) for secure financial transaction authentication.',
      keywords: 'AS2805 MAC, Australian payment, EFTPOS MAC, AS2805.4.1, payment MAC, financial MAC, Method 1, Method 2, DES MAC, 3DES MAC, Australian banking, payment security',
      faqTitle: 'AS2805 MAC FAQ',
      usageTitle: 'How to Use AS2805 MAC Calculator',
      faqs: [
        { question: 'What is AS2805?', answer: 'AS2805 is an Australian Standard (AS2805.4.1) for EFTPOS messaging and financial transaction authentication. It defines MAC (Message Authentication Code) algorithms specifically designed for the Australian payment ecosystem, ensuring message integrity and authenticity in electronic funds transfer systems. Widely adopted by Australian banks and payment processors for ATM, POS, and interbank transactions.' },
        { question: 'What is the difference between Method 1 and Method 2?', answer: 'Method 1 uses single DES in CBC mode for all blocks, providing basic MAC generation suitable for lower-risk transactions. Method 2 uses DES CBC for all data blocks but applies Triple DES (3DES) encryption to the final block, significantly enhancing security against cryptanalytic attacks. Method 2 is recommended for high-value transactions and modern payment systems requiring stronger cryptographic protection.' },
        { question: 'What keys are required for AS2805 MAC?', answer: 'AS2805 MAC requires two 8-byte (16 hex character) keys: K|KL (left key) and KR (right key). The left key is used for CBC-MAC computation across all data blocks. The right key is combined with the left key to form a 16-byte 3DES key for the final block encryption in Method 2. Both keys must be securely generated and managed according to payment industry standards (PCI DSS).' },
        { question: 'How does AS2805 MAC differ from ISO 9797-1?', answer: 'AS2805.4.1 MAC Method 2 is based on ISO 9797-1 Algorithm 3 (Retail MAC) but with specific key structure requirements for Australian systems. Both use DES CBC with 3DES final block, but AS2805 specifies the two-key format (K|KL and KR) matching Australian HSM implementations. AS2805 is tailored for Australian EFTPOS environments with specific padding and data formatting conventions.' },
        { question: 'What is the typical truncation for AS2805 MAC?', answer: 'AS2805 MAC typically uses 4-byte (8 hex characters) truncation for most Australian EFTPOS transactions, balancing security and message efficiency. Some high-security applications may use 6-byte or full 8-byte MACs. The truncation parameter selects the leftmost N bytes of the final MAC block. Check your payment network specifications for required MAC length.' }
      ],
      usage: [
        'Select MAC method: Method 1 (DES CBC) or Method 2 (DES CBC + 3DES final block).',
        'Enter left key K|KL (16 hex) and right key KR (16 hex).',
        'Enter transaction data in hexadecimal format.',
        'Set truncation length (1-8 bytes, standard EFTPOS uses 4 bytes).',
        'Click "Calculate MAC" and copy the result for your payment message.',
      ],
    },
    tdesCbcMac: {
      title: 'TDES CBC-MAC Calculator Online - Triple DES Message Authentication | HSM Kit',
      description: 'Free online TDES CBC-MAC calculator for generating message authentication codes using Triple DES in CBC mode. Supports 2-key and 3-key TDES with ISO 9797-1 padding methods. PCI DSS compliant MAC generation for financial transactions, payment systems, and secure communications.',
      keywords: 'TDES CBC-MAC, Triple DES MAC, 3DES MAC, CBC-MAC, message authentication, DES MAC, ISO 9797-1, payment MAC, financial MAC, 2-key TDES, 3-key TDES, CBC mode',
      faqTitle: 'TDES CBC-MAC FAQ',
      usageTitle: 'How to Use TDES CBC-MAC Calculator',
      faqs: [
        { question: 'What is TDES CBC-MAC?', answer: 'TDES CBC-MAC (Triple Data Encryption Standard Cipher Block Chaining Message Authentication Code) is a cryptographic algorithm that uses Triple DES encryption in CBC mode to generate authentication tags for verifying message integrity and authenticity. It processes data in 8-byte blocks, chaining each block with the previous encrypted output. The final block becomes the MAC value, ensuring any tampering with the message is detected.' },
        { question: 'What is the difference between 2-key and 3-key TDES?', answer: '2-key TDES (112-bit effective security) uses 16 bytes (32 hex characters) with K1 and K2, where K3=K1 in the encrypt-decrypt-encrypt sequence. 3-key TDES (168-bit effective security) uses 24 bytes (48 hex characters) with three independent keys K1, K2, K3. 3-key TDES provides stronger security and is recommended for high-value transactions and modern payment systems complying with PCI DSS standards.' },
        { question: 'What are ISO 9797-1 padding methods?', answer: 'ISO 9797-1 defines two padding methods: Method 1 pads with zero bytes (0x00) to reach a multiple of 8 bytes, simple but vulnerable if the original data ends with zeros. Method 2 (recommended) appends 0x80 followed by zero bytes, always distinguishing padded data from original data. Method 2 ensures unambiguous padding removal and prevents padding oracle attacks in MAC verification systems.' },
        { question: 'When should I use TDES CBC-MAC?', answer: 'Use TDES CBC-MAC for legacy financial systems requiring Triple DES compatibility, payment terminal authentication (POS, ATM), EMV chip card transactions, key management MAC generation, and secure messaging in banking networks. While AES-based MACs (like CMAC) are preferred for new systems, TDES CBC-MAC remains widely deployed in existing payment infrastructure due to backward compatibility requirements and regulatory acceptance.' },
        { question: 'What is the typical MAC truncation for TDES CBC-MAC?', answer: 'TDES CBC-MAC generates an 8-byte (16 hex characters) MAC from the final encrypted block. Common truncation values are 4 bytes (8 hex characters) for standard security in payment systems, 6 bytes (12 hex characters) for enhanced security, or full 8 bytes (16 hex characters) for maximum protection. Truncation balances security with message efficiency - shorter MACs reduce bandwidth but provide fewer bits of security against brute-force attacks.' },
      ],
      usage: [
        'Select key type: 3-key TDES (48 hex, maximum security) or 2-key TDES (32 hex, legacy systems).',
        'Enter the TDES key in hexadecimal format.',
        'Choose padding method: Method 1 (zero padding) or Method 2 (0x80 + zeros, recommended).',
        'Enter message data in hexadecimal format.',
        'Set truncation length (1-8 bytes) and click "Calculate MAC".',
      ],
    },
    hmac: {
      title: 'HMAC Calculator Online - Hash-based Message Authentication | HSM Kit',
      description: 'Free online HMAC calculator supporting SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-3, MD5, RIPEMD-160 and more hash algorithms. Generate RFC 2104 compliant hash-based message authentication codes for API security, JWT tokens, webhook verification, and secure communications.',
      keywords: 'HMAC calculator, HMAC-SHA256, HMAC-SHA512, HMAC-MD5, hash-based MAC, message authentication, RFC 2104, HMAC-SHA1, HMAC-SHA3, API authentication, JWT HMAC, webhook signature',
      faqTitle: 'HMAC FAQ',
      usageTitle: 'How to Use HMAC Calculator',
      faqs: [
        { question: 'What is HMAC?', answer: 'HMAC (Hash-based Message Authentication Code, RFC 2104) combines a cryptographic hash function with a secret key to create message authentication codes. It provides both data integrity and authenticity verification. HMAC processes data through nested hash operations: HMAC(K, m) = H((K ⊕ opad) || H((K ⊕ ipad) || m)), where K is the key, m is the message, H is the hash function, and opad/ipad are padding constants. This construction ensures that even if the hash function has weaknesses, HMAC remains secure.' },
        { question: 'Which hash function should I use for HMAC?', answer: 'SHA-256 is recommended for most applications offering 128-bit security strength. Use SHA-512 for 256-bit security in high-value systems or SHA-384 for 192-bit security. SHA-3 (Keccak) provides the latest NIST standard with different internal structure. Avoid MD5-HMAC and SHA-1-HMAC for new security-critical applications due to hash collision vulnerabilities, though HMAC construction itself remains secure. For legacy system compatibility, SHA-1-HMAC may still be acceptable as HMAC provides additional security over plain hashing.' },
        { question: 'What is the recommended HMAC key length?', answer: 'The key length should match the hash output size for optimal security: 32 bytes (256 bits) for SHA-256, 64 bytes (512 bits) for SHA-512, 20 bytes (160 bits) for SHA-1. Keys shorter than the hash output reduce security strength. Keys longer than the hash block size (64 bytes for SHA-256, 128 bytes for SHA-512) are first hashed before use. Use cryptographically secure random number generators (CSPRNG) to generate HMAC keys, never use passwords or predictable values directly as HMAC keys.' },
        { question: 'Where is HMAC commonly used?', answer: 'HMAC is widely deployed in: API authentication (AWS Signature, OAuth 2.0, HMAC-based tokens), JWT (JSON Web Tokens) with HS256/HS384/HS512 algorithms, webhook signature verification (GitHub, Stripe, PayPal), TLS/SSL (HMAC for record integrity in cipher suites), IPsec (authentication headers and ESP), challenge-response protocols, secure file integrity verification, and blockchain/cryptocurrency transaction signing. HMAC is preferred over simple hashing for authentication because it requires knowledge of the secret key.' },
        { question: 'Can I truncate HMAC output?', answer: 'Yes, HMAC supports truncation while maintaining security. RFC 2104 recommends keeping at least half the hash output length: minimum 16 bytes for SHA-256-HMAC (128 bits of security), 20 bytes for SHA-512-HMAC (160 bits). Common truncations include HMAC-SHA-256-128 (16 bytes), HMAC-SHA-512-256 (32 bytes). Truncation reduces MAC size for bandwidth-constrained environments while preserving authentication strength against forgery attacks. Never truncate below 80 bits (10 bytes) for security applications.' },
      ],
      usage: [
        'Select a hash algorithm (SHA-256 recommended for most applications, SHA-512 for high security).',
        'Choose key format (Hex or ASCII) and enter your secret key.',
        'Choose data format (Hex or ASCII) and enter the message to authenticate.',
        'Click "Calculate HMAC" to generate the authentication code.',
        'Copy the HMAC result for use in API headers, webhooks, or verification systems.',
      ],
    },
    cmac: {
      title: 'CMAC Calculator Online - Cipher-based Message Authentication | HSM Kit',
      description: 'Free online CMAC calculator supporting AES-CMAC and TDES-CMAC (3DES-CMAC). Generate NIST SP 800-38B compliant cipher-based message authentication codes for secure communications, data integrity verification, and cryptographic protocols.',
      keywords: 'CMAC calculator, AES-CMAC, TDES-CMAC, 3DES-CMAC, cipher-based MAC, AES CMAC 96, NIST SP 800-38B, message authentication, block cipher MAC, AES-128 CMAC, AES-256 CMAC',
      faqTitle: 'CMAC FAQ',
      usageTitle: 'How to Use CMAC Calculator',
      faqs: [
        { question: 'What is CMAC?', answer: 'CMAC (Cipher-based Message Authentication Code, NIST SP 800-38B) is a block cipher-based MAC algorithm that provides data integrity and authenticity verification. It uses block ciphers like AES or Triple DES (TDES) in a sophisticated subkey derivation scheme. CMAC processes data in blocks, generating two subkeys (K1 and K2) from the encryption key, then applying cipher block chaining with specific padding rules. The final block is XORed with K1 (for complete blocks) or K2 (for padded blocks) before final encryption. CMAC provides security equivalent to the underlying block cipher and is widely used in modern cryptographic protocols.' },
        { question: 'Which cipher should I use for CMAC?', answer: 'AES-CMAC is strongly recommended for new applications, providing 128-bit, 192-bit, or 256-bit security depending on key size (AES-128, AES-192, AES-256). AES offers excellent performance on modern hardware with AES-NI acceleration. TDES-CMAC (3DES-CMAC) provides only 112-bit effective security and is significantly slower but may be required for legacy system compatibility or regulatory compliance in financial/payment systems. For new implementations, use AES-256-CMAC for maximum security. AES-128-CMAC offers good balance of security and performance for most applications.' },
        { question: 'What are the CMAC key length requirements?', answer: 'AES-CMAC supports three key lengths: 128 bits (16 bytes/32 hex characters) for AES-128-CMAC, 192 bits (24 bytes/48 hex characters) for AES-192-CMAC, and 256 bits (32 bytes/64 hex characters) for AES-256-CMAC. TDES-CMAC requires either 128 bits (16 bytes/32 hex characters) for 2-key TDES (K1=K3) or 192 bits (24 bytes/48 hex characters) for 3-key TDES (all keys unique). Keys must be generated using cryptographically secure random number generators (CSPRNG). Never derive CMAC keys from passwords without proper key derivation functions (KDF) like PBKDF2 or HKDF. Store keys securely using hardware security modules (HSM) or key management systems.' },
        { question: 'Where is CMAC commonly used?', answer: 'CMAC is widely deployed in modern cryptographic protocols: TLS 1.3 cipher suites for record authentication, IPsec AH (Authentication Header) and ESP (Encapsulating Security Payload) for VPN security, IEEE 802.11i (WPA2/WPA3) for wireless network authentication, NIST key management standards (SP 800-108, SP 800-56C) for key derivation and confirmation, EMV contactless payment cards for offline authentication, ISO/IEC 9797-1 Algorithm 5 for financial message authentication, automotive security (AUTOSAR SecOC) for in-vehicle network protection, Bluetooth LE secure connections for device pairing, and firmware integrity verification in secure boot processes. CMAC is preferred over CBC-MAC because it handles variable-length messages securely without length prepending.' },
        { question: 'Can I truncate CMAC output?', answer: 'Yes, CMAC supports truncation while maintaining security. NIST SP 800-38B recommends minimum MAC lengths: For AES-CMAC, use at least 64 bits (8 bytes) for general security, 96 bits (12 bytes) for strong security applications (AES-CMAC-96 is common in IPsec and wireless protocols), or full 128 bits (16 bytes) for maximum security. For TDES-CMAC, use minimum 64 bits (8 bytes), with 80 bits (10 bytes) or full 64 bits (8 bytes) output typical. Truncation affects security strength: 96-bit MAC provides 2^96 collision resistance and 2^48 forgery resistance, 64-bit MAC provides 2^64 collision resistance and 2^32 forgery resistance (marginal for high-value data). Never truncate below 64 bits for security-critical applications. Truncation is done by taking leftmost (most significant) bytes of full CMAC output.' },
      ],
      usage: [
        'Select encryption algorithm: AES (recommended) or TDES for legacy systems.',
        'Choose key format (Hex or ASCII) and enter your secret key (AES: 32/48/64 hex chars; TDES: 32/48 hex chars).',
        'Choose data format and enter the message to authenticate.',
        'Optional: Check "AES CMAC 96" for 96-bit truncated output (common in IPsec/802.11i).',
        'Click "Calculate CMAC" and copy the result for your application.',
      ],
    },
    retailMac: {
      title: 'Retail MAC Calculator Online - DES & 3DES Message Authentication | HSM Kit',
      description: 'Free online Retail MAC calculator supporting DES and Triple DES with ISO 9797-1 Method 2 padding. Generate secure MACs for payment systems with optional 3DES finalization for enhanced security. Browser-based tool for financial message authentication.',
      keywords: 'Retail MAC, DES MAC, 3DES MAC, Triple DES, ISO 9797-1, Method 2 padding, message authentication, payment MAC, financial MAC, POS MAC, ATM security, banking MAC, 3DES finalization',
      faqTitle: 'Retail MAC FAQ',
      usageTitle: 'How to Use Retail MAC Calculator',
      faqs: [
        { question: 'What is Retail MAC?', answer: 'Retail MAC is a widely-used MAC algorithm in payment and banking systems that uses DES or Triple DES encryption with ISO 9797-1 Method 2 padding (0x80 followed by zeros). It processes data in CBC mode and extracts the last block as the MAC value. Retail MAC is commonly used in POS terminals, ATMs, and financial message authentication where DES-based security is required for compatibility with legacy systems.' },
        { question: 'Should I use 3DES finalization?', answer: 'Yes, 3DES finalization is highly recommended for better security. Standard DES Retail MAC uses single DES throughout, which provides 56-bit effective security. With 3DES finalization enabled, the final MAC block is encrypted using Triple DES (112-bit effective security), making it significantly more resistant to brute force attacks while maintaining backward compatibility with systems expecting DES-based MACs. This is particularly important for high-value transactions or sensitive financial data.' },
        { question: 'What is the difference between DES and 3DES algorithm selection?', answer: 'When you select "DES" algorithm, the entire CBC-MAC chain uses single DES encryption (optionally with 3DES finalization on the last block). When you select "3DES" algorithm, the entire CBC-MAC chain uses Triple DES encryption, providing stronger security throughout the computation. 3DES mode requires either a 16-byte key (2-key TDES with K1=K3) or provides a second key K\' for full 3-key TDES. Use DES mode for compatibility with legacy systems, and 3DES mode for modern secure implementations.' },
        { question: 'What padding method does Retail MAC use?', answer: 'Retail MAC uses ISO 9797-1 Method 2 padding: append 0x80 byte followed by zero bytes to reach the next 8-byte block boundary. For example, if your data ends mid-block at 5 bytes, padding adds 0x80 00 00 (3 bytes). If data is exactly block-aligned (8, 16, 24 bytes...), an entire padding block (0x80 00 00 00 00 00 00 00) is appended. This padding method ensures unambiguous message boundaries and prevents length extension attacks. The padding is mandatory and applied automatically before MAC calculation.' },
        { question: 'What key lengths are supported?', answer: 'For DES mode: Key K must be exactly 16 hex characters (8 bytes, 64 bits with parity). If 3DES finalization is enabled, Key K\' should also be 16 hex characters for the final encryption step. For 3DES mode: Key K is 16 hex characters (2-key TDES where K1=K3), or you can provide both Key K and Key K\' (16 hex characters each) for full 3-key Triple DES where all three keys are unique. Keys must be generated using cryptographically secure random number generators and stored securely in HSMs or key management systems.' },
      ],
      usage: [
        'Select algorithm: DES for legacy systems, 3DES for enhanced security throughout.',
        'Choose finalization: "None" for standard processing, or "3DES" for enhanced final block security.',
        'Enter Key K (16 hex characters). Enter Key K\' if using 3DES finalization or 3-key mode.',
        'Enter message data in hexadecimal. ISO 9797-1 Method 2 padding is applied automatically.',
        'Set truncation length (1-8 bytes) and click "Calculate MAC" to generate the result.',
      ],
    },
    zka: {
      title: 'ZKA German Banking Standard Cryptographic Operations | HSM Kit',
      description: 'Free online ZKA cryptographic tool for German banking systems. Perform session key (SK) derivation, PIN encryption/decryption, and MAC calculation using Triple DES. Implements ZKA standard for secure payment processing.',
      keywords: 'ZKA, German banking, Zentraler Kreditausschuss, session key derivation, SK derivation, PIN encryption, MAC calculation, TDES, 3DES, German payment standard, banking cryptography',
      faqTitle: 'ZKA FAQ',
      usageTitle: 'How to Use ZKA Tool',
      faqs: [
        { question: 'What is ZKA?', answer: 'ZKA (Zentraler Kreditausschuss) is a German banking standard that defines cryptographic operations for secure payment processing, including key derivation, PIN handling, and message authentication. It is widely used in German banking infrastructure for ATM and POS transactions.' },
        { question: 'What is SK derivation?', answer: 'Session Key (SK) derivation is the process of generating a temporary session key from a master key (MK), command data (CM), and a random number (Rnd). This ensures each transaction uses a unique key, enhancing security by preventing key reuse attacks.' },
        { question: 'How does ZKA PIN encryption work?', answer: 'ZKA uses Triple DES (3DES) in ECB mode to encrypt PIN blocks using the derived session key (SK-pac). The PIN block must be 8 bytes (16 hex characters). This provides secure PIN transmission between payment terminals and host systems.' },
        { question: 'What MAC algorithm does ZKA use?', answer: 'ZKA uses Triple DES CBC-MAC for message authentication. The MAC is calculated by processing data blocks in CBC mode and taking the final encrypted block as the MAC value. This ensures message integrity and authenticity in financial transactions.' },
      ],
      usage: [
        'SK Derivation tab: Enter Master Key (MK), Command Data (CM), and Random Number (Rnd) in hexadecimal format (32 hex characters each). Click "Derive SK" to generate the session key.',
        'PIN tab: Enter the session key (SK-pac) and PIN block (8 bytes, 16 hex characters). Click "Encrypt" to encrypt the PIN block or "Decrypt" to decrypt it.',
        'MAC tab: Enter the MAC key (32 hex characters) and data in hexadecimal format. Click "Calculate MAC" to generate the message authentication code.',
        'All inputs must be in hexadecimal format. Keys are 16 bytes (32 hex characters), and PIN blocks are 8 bytes (16 hex characters).',
      ],
    },
    // Generic Tools SEO
    hash: {
      title: 'Hash Calculator Online - MD5, SHA-256, SHA-512, BLAKE2 | HSM Kit',
      description: 'Free online hash calculator supporting MD5, SHA-1, SHA-256, SHA-512, RIPEMD-160, WHIRLPOOL, BLAKE2, CRC32 and more. Calculate hash values from text or hexadecimal input. 20+ hash algorithms supported. All processing in browser.',
      keywords: 'hash calculator, MD5 hash, SHA-256 hash, SHA-512 hash, BLAKE2, RIPEMD-160, WHIRLPOOL, CRC32, hash generator, checksum calculator, message digest, cryptographic hash',
      faqTitle: 'Hash Calculator FAQ',
      usageTitle: 'How to Use Hash Calculator',
      faqs: [
        { question: 'What is a hash function?', answer: 'A hash function is a mathematical algorithm that converts input data of any size into a fixed-size output (hash value). It is deterministic and one-way - you cannot reverse a hash to get the original input.' },
        { question: 'Which hash algorithm should I use?', answer: 'For security purposes, use SHA-256 or SHA-512. MD5 and SHA-1 are considered insecure for cryptographic use but can be used for checksums. BLAKE2 offers excellent performance with strong security.' },
        { question: 'What is the difference between MD5 and SHA-256?', answer: 'MD5 produces a 128-bit hash and is faster but cryptographically broken. SHA-256 produces a 256-bit hash and is currently secure for cryptographic purposes. Use SHA-256 for security-sensitive applications.' },
        { question: 'Can I decrypt a hash value?', answer: 'No, hash functions are one-way functions by design. You cannot reverse a hash to recover the original input. This property makes hashes useful for password storage and data integrity verification.' },
      ],
      usage: [
        'Select input type: ASCII text or Hexadecimal.',
        'Choose a hash algorithm from the dropdown (MD5, SHA-256, etc.).',
        'Enter your data in the input field.',
        'Click "Calculate Hash" to generate the hash value.',
      ],
    },
    encoding: {
      title: 'Character Encoding Converter Online - ASCII, EBCDIC, Hex | HSM Kit',
      description: 'Free online character encoding converter. Convert between ASCII, EBCDIC, Hexadecimal, Binary, and ATM Decimal formats. Essential tool for payment system development and mainframe integration. 100% client-side conversion.',
      keywords: 'character encoding, ASCII to EBCDIC, hex converter, binary converter, EBCDIC converter, ATM decimal, encoding converter, mainframe encoding, payment system encoding, banking encoding',
      faqTitle: 'Character Encoding FAQ',
      usageTitle: 'How to Use Encoding Converter',
      faqs: [
        { question: 'What is character encoding?', answer: 'Character encoding is a system that pairs each character with a unique number or sequence of bytes, allowing computers to store and transmit text.' },
        { question: 'What is EBCDIC?', answer: 'EBCDIC (Extended Binary Coded Decimal Interchange Code) is an 8-bit character encoding used mainly on IBM mainframe and midrange computer systems, common in banking and financial systems.' },
        { question: 'Why do I need to convert between ASCII and EBCDIC?', answer: 'Many legacy banking and financial systems run on IBM mainframes using EBCDIC encoding. When integrating modern systems (using ASCII/UTF-8) with these mainframes, character conversion is essential.' },
        { question: 'What is ATM Decimal encoding?', answer: 'ATM Decimal is a specific encoding used in ATM communications where each digit (0-9) is represented by its ASCII code. It is commonly used in financial messaging protocols.' },
      ],
      usage: [
        'Select the conversion type from the dropdown.',
        'Enter your data in the appropriate format.',
        'Click "Convert" to see the result.',
      ],
    },
    bcd: {
      title: 'BCD Encoder/Decoder Online - Binary Coded Decimal | HSM Kit',
      description: 'Free online BCD (Binary Coded Decimal) encoder and decoder. Convert decimal numbers to BCD format (binary or hex) and decode BCD back to decimal. Used in financial and embedded systems. Perfect for payment terminal integration.',
      keywords: 'BCD encoder, BCD decoder, binary coded decimal, decimal to BCD, BCD to decimal, BCD converter, packed BCD, financial encoding, payment system encoding',
      faqTitle: 'BCD FAQ',
      usageTitle: 'How to Use BCD Tool',
      faqs: [
        { question: 'What is BCD?', answer: 'Binary Coded Decimal (BCD) is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of bits, usually four.' },
        { question: 'Why is BCD used?', answer: 'BCD is used in financial applications and embedded systems where exact decimal representation is important, avoiding floating-point rounding errors.' },
        { question: 'What is the difference between packed and unpacked BCD?', answer: 'In packed BCD, two decimal digits are stored in one byte (4 bits each). In unpacked BCD, each decimal digit occupies one full byte. Packed BCD is more space-efficient.' },
        { question: 'Where is BCD commonly used?', answer: 'BCD is widely used in financial systems, calculators, digital clocks, and any application where decimal precision is critical. Payment terminals and ATMs often use BCD for amount representation.' },
      ],
      usage: [
        'Select Encode to convert decimal to BCD, or Decode to convert BCD to decimal.',
        'Enter your data in the input field.',
        'Click the action button to perform the conversion.',
      ],
    },
    checkDigits: {
      title: 'Check Digit Calculator Online - Luhn MOD 10, MOD 9 | HSM Kit',
      description: 'Free online check digit calculator and validator. Generate or verify check digits using Luhn algorithm (MOD 10) and Amex SE MOD 9. Validate credit card numbers, IMEI, and other identifiers. Essential for payment validation.',
      keywords: 'check digit calculator, Luhn algorithm, MOD 10, MOD 9, credit card validation, IMEI check, checksum calculator, Luhn check, card number validation, identifier validation',
      faqTitle: 'Check Digits FAQ',
      usageTitle: 'How to Use Check Digit Calculator',
      faqs: [
        { question: 'What is a check digit?', answer: 'A check digit is a digit added to a number for error detection, calculated using a specific algorithm like Luhn (MOD 10).' },
        { question: 'What is the Luhn algorithm?', answer: 'The Luhn algorithm (also called MOD 10) is a checksum formula used to validate various identification numbers such as credit card numbers, IMEI numbers, and more.' },
        { question: 'What numbers use the Luhn algorithm?', answer: 'Credit card numbers (Visa, MasterCard, Amex), IMEI numbers, National Provider Identifier (NPI), Canadian Social Insurance Numbers, and many other identification numbers use Luhn validation.' },
        { question: 'What is the Amex SE MOD 9 algorithm?', answer: 'The Amex SE (Service Establishment) MOD 9 algorithm is used specifically by American Express for validating merchant/service establishment numbers. It uses a different calculation method than Luhn.' },
      ],
      usage: [
        'Select the algorithm type (Luhn MOD 10 or Amex SE MOD 9).',
        'Choose to Verify an existing number or Generate a check digit.',
        'Enter the number and click the action button.',
      ],
    },
    base64: {
      title: 'Base64 Encoder/Decoder Online - Free Base64 Tool | HSM Kit',
      description: 'Free online Base64 encoder and decoder. Encode text or binary data to Base64 format, or decode Base64 strings back to original format. Essential for data encoding in web applications. Fast and secure browser-based processing.',
      keywords: 'Base64 encoder, Base64 decoder, Base64 encode, Base64 decode, binary to text, text to Base64, data encoding, Base64 converter, MIME encoding',
      faqTitle: 'Base64 FAQ',
      usageTitle: 'How to Use Base64 Tool',
      faqs: [
        { question: 'What is Base64?', answer: 'Base64 is a binary-to-text encoding scheme that represents binary data in ASCII string format using 64 characters (A-Z, a-z, 0-9, +, /).' },
        { question: 'Why use Base64?', answer: 'Base64 is used to encode binary data for transmission in text-based protocols like email (MIME) or embedding images in HTML/CSS.' },
        { question: 'Does Base64 provide encryption?', answer: 'No, Base64 is an encoding scheme, not encryption. Anyone can decode Base64 data. It is used for data representation, not security.' },
        { question: 'Why does Base64 increase data size?', answer: 'Base64 encodes 3 bytes of binary data into 4 ASCII characters, resulting in approximately 33% size increase. The padding character "=" is used when input length is not divisible by 3.' },
      ],
      usage: [
        'Select Encode to convert text to Base64, or Decode to convert Base64 back to text.',
        'Enter your data in the input field.',
        'Click the action button to perform the conversion.',
      ],
    },
    base94: {
      title: 'Base94 Encoder/Decoder Online - Compact Binary Encoding | HSM Kit',
      description: 'Free online Base94 encoder and decoder. Encode data using all 94 printable ASCII characters for more compact encoding than Base64. Useful for efficient data storage and transmission. 20% more compact than Base64.',
      keywords: 'Base94 encoder, Base94 decoder, Base94 encode, Base94 decode, compact encoding, binary encoding, ASCII encoding, efficient encoding, URL-safe encoding',
      faqTitle: 'Base94 FAQ',
      usageTitle: 'How to Use Base94 Tool',
      faqs: [
        { question: 'What is Base94?', answer: 'Base94 is a binary-to-text encoding that uses all 94 printable ASCII characters (! to ~), providing more efficient encoding than Base64.' },
        { question: 'Why use Base94 instead of Base64?', answer: 'Base94 provides approximately 20% more compact encoding than Base64, useful when storage or bandwidth is at a premium.' },
        { question: 'What characters does Base94 use?', answer: 'Base94 uses all 94 printable ASCII characters from ! (0x21) to ~ (0x7E), excluding the space character. This includes letters, numbers, and all standard punctuation.' },
        { question: 'When should I use Base94?', answer: 'Use Base94 when you need compact text representation of binary data and your transport/storage system supports all printable ASCII characters. It is ideal for URLs, QR codes, and storage optimization.' },
      ],
      usage: [
        'Select Encode to convert text to Base94, or Decode to convert Base94 back to text.',
        'Enter your data in the input field.',
        'Click the action button to perform the conversion.',
      ],
    },
    messageParser: {
      title: 'Message Parser Online - ATM NDC, Wincor, ISO 8583 | HSM Kit',
      description: 'Free online message parser for ATM and financial transactions. Parse ATM NDC, Wincor/Nixdorf, and ISO 8583:1987 message formats. Essential tool for payment system development and debugging. All parsing done client-side.',
      keywords: 'message parser, ATM NDC, ATM Wincor, ISO 8583, financial message, transaction parser, hex parser, ATM message decoder, payment message parser, financial transaction parser',
      faqTitle: 'Message Parser FAQ',
      usageTitle: 'How to Use Message Parser',
      faqs: [
        { question: 'What is ATM NDC?', answer: 'NDC (NCR Direct Connect) is a communication protocol used by NCR ATMs to communicate with host systems. It defines the message formats for transactions, status, and commands.' },
        { question: 'What is ISO 8583?', answer: 'ISO 8583 is an international standard for financial transaction card originated messages. It defines a message structure used by payment systems worldwide.' },
        { question: 'What is Wincor/Nixdorf protocol?', answer: 'Wincor Nixdorf (now Diebold Nixdorf) protocol is a proprietary ATM communication protocol similar to NDC but with vendor-specific variations. It is widely used in European and Asian markets.' },
        { question: 'How do I identify the message format?', answer: 'NDC messages typically start with specific message class identifiers. ISO 8583 messages begin with a 4-digit MTI (Message Type Indicator). The hex dump structure can help identify the protocol used.' },
      ],
      usage: [
        'Select the message format (ATM NDC, ATM Wincor, or ISO 8583).',
        'Enter the hexadecimal message data in the input field.',
        'Click "Parse" to decode and display the message fields.',
      ],
    },
    rsaDer: {
      title: 'RSA DER Public Key Encoder/Decoder Online | HSM Kit',
      description: 'Free online RSA DER public key encoder and decoder. Convert between RSA modulus/exponent and DER ASN.1 format. Support for PEM output and various input encodings (ASCII Hex, Base64, EBCDIC). 100% browser-based processing.',
      keywords: 'RSA DER, RSA public key, DER encoding, ASN.1, PEM format, modulus, exponent, RSA key converter, public key encoder, RSA key parser, certificate key extractor',
      faqTitle: 'RSA DER Public Key FAQ',
      usageTitle: 'How to Use RSA DER Tool',
      faqs: [
        { question: 'What is DER encoding?', answer: 'DER (Distinguished Encoding Rules) is a binary format for encoding ASN.1 data structures, commonly used for cryptographic keys and certificates.' },
        { question: 'What is PEM format?', answer: 'PEM (Privacy-Enhanced Mail) is a Base64-encoded version of DER with header/footer lines, making it suitable for text-based transmission and storage.' },
        { question: 'What are modulus and exponent in RSA?', answer: 'The modulus (n) is the product of two large prime numbers and determines the key size. The public exponent (e) is typically 65537 (0x10001). Together they form the public key.' },
        { question: 'How do I extract modulus from a certificate?', answer: 'Use this tool to decode a DER/PEM encoded public key. The parser will extract and display the modulus and exponent in various formats (hex, decimal, Base64).' },
      ],
      usage: [
        'For encoding: Enter the RSA modulus and exponent, select encodings, and click Encode.',
        'For decoding: Paste the DER or PEM encoded public key and click Decode.',
        'Toggle PEM output to get Base64-encoded output with headers.',
      ],
    },
    uuid: {
      title: 'UUID Generator Online - Version 1, 3, 4, 5 | HSM Kit',
      description: 'Free online UUID generator supporting Version 1 (time-based), Version 3 (MD5), Version 4 (random), and Version 5 (SHA-1). Generate single or batch UUIDs for your applications. Cryptographically secure random generation.',
      keywords: 'UUID generator, GUID generator, UUID v4, UUID v1, random UUID, unique identifier, UUID online, batch UUID generator, unique ID generator, GUID generator online',
      faqTitle: 'UUID Generator FAQ',
      usageTitle: 'How to Use UUID Generator',
      faqs: [
        { question: 'What is UUID?', answer: 'UUID (Universally Unique Identifier) is a 128-bit identifier that is unique across space and time, commonly used in distributed systems for generating unique keys.' },
        { question: 'Which UUID version should I use?', answer: 'Version 4 (random) is most commonly used and recommended for most applications. Version 1 is time-based, while versions 3 and 5 are name-based using MD5 and SHA-1 respectively.' },
        { question: 'What is the difference between UUID and GUID?', answer: 'UUID and GUID (Globally Unique Identifier) are essentially the same thing. GUID is Microsoft\'s implementation of the UUID standard. Both use the same format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.' },
        { question: 'Are UUIDs truly unique?', answer: 'For UUID v4 (random), the probability of collision is astronomically low (about 1 in 2^122). While not mathematically impossible, duplicate UUIDs are practically never encountered in real-world applications.' },
      ],
      usage: [
        'Select the UUID version (1, 3, 4, or 5).',
        'Enter the number of UUIDs to generate (1-100).',
        'Optionally check "Without hyphen" to remove dashes.',
        'Click "Generate" to create UUIDs.',
      ],
    },
    sslCert: {
      title: 'SSL Certificates (X509) - Generate Keys, CSR, Self-signed Certs | HSM Kit',
      description: 'Free online SSL certificate tool. Generate RSA key pairs with encrypted private keys, create Certificate Signing Requests (CSR), generate self-signed X.509 certificates, and parse/analyze certificates. All processing done client-side in your browser. 100% secure.',
      keywords: 'SSL certificate, X509, CSR generator, self-signed certificate, RSA key generator, certificate parser, PEM, PKI tools, certificate signing request, X.509 certificate, SSL tools, certificate generator, TLS certificate, HTTPS certificate',
      faqTitle: 'SSL Certificates FAQ',
      usageTitle: 'How to Use SSL Certificates Tool',
      faqs: [
        { question: 'What is an X.509 certificate?', answer: 'X.509 is a standard format for public key certificates, used in TLS/SSL for secure web connections, email signing (S/MIME), code signing, and other PKI applications. It binds a public key to an identity.' },
        { question: 'What is a CSR (Certificate Signing Request)?', answer: 'A CSR is a message sent to a Certificate Authority (CA) to request a digital certificate. It contains the public key and subject information (organization, domain name, etc.) that will be included in the certificate.' },
        { question: 'What is a self-signed certificate?', answer: 'A self-signed certificate is signed by its own private key rather than a CA. It is useful for testing, development, or internal use, but browsers will show warnings since the certificate is not verified by a trusted CA.' },
        { question: 'Why do I need a pass phrase for the private key?', answer: 'The pass phrase encrypts the private key using 3DES. This protects the key if the file is compromised. Without the correct pass phrase, the private key cannot be used.' },
        { question: 'What key length should I use?', answer: 'For RSA keys, 2048 bits is the minimum recommended for security. 4096 bits provides stronger security but is slower. 3072 bits is a good balance between security and performance.' },
      ],
      usage: [
        'Keys Tab: Generate RSA key pairs with encrypted private keys. Set key length and pass phrase.',
        'CSRs Tab: Create Certificate Signing Requests. Paste your private key, enter subject details (country, organization, common name, etc.), and generate the CSR.',
        'Read CSR Tab: Parse and analyze existing CSRs to view subject information and public key.',
        'Self-signed Tab: Generate self-signed certificates for testing. Set validity period, serial number, and subject details.',
        'Read Certificate Tab: Parse X.509 certificates to view issuer, subject, validity dates, extensions, and public key.',
      ],
    },
  },
};
