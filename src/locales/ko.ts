// Korean translations
export default {
  common: {
    copy: '복사',
    generate: '생성',
    calculate: '계산',
    parse: '구문 분석',
    clear: '지우기',
    copied: '클립보드에 복사되었습니다!',
    copyFailed: '복사 실패',
    error: '오류',
    result: '결과',
    loading: '로딩 중...',
    close: '닫기',
    cancel: '취소',
  },

  bitmap: {
    title: 'ISO8583 Bitmap',
    description: 'Parse bitmap (hexadecimal data) into bits and construct a bitmap back from binary data provided.',
    bitmapLabel: 'Bitmap',
    bitmapPlaceholder: 'e.g., B0300054020000000000000010000001',
    bitmapHint: 'Enter hexadecimal bitmap or select bits below. Bit 1 indicates secondary bitmap presence (ISO8583 standard).',
    primaryBitmap: 'Primary Bitmap',
    secondaryBitmap: 'Secondary Bitmap',
    bits: 'Bits',
    copySuccess: 'Copied to clipboard',
    copyError: 'Failed to copy',
    errorNoBitmap: 'Please enter or generate a bitmap',
    errorInvalidHex: 'Invalid hexadecimal input',
    infoTitle: 'About ISO8583 Bitmap',
    info1: 'ISO 8583 bitmap indicates which data fields are present in the message.',
    info2: 'Primary bitmap (64 bits) covers fields 1-64. If bit 1 is set, secondary bitmap (65-128) is present.',
    info3: 'Each bit position corresponds to a data field number in the ISO8583 message.',
  },
  cvv: {
    title: 'Card Verification Value',
    description: 'Generate and validate CVV/CVC, iCVV, CVV2/CVC2, and dCVV for payment card security.',
    infoTitle: 'About CVV/CVC',
    info1: 'CVV (Card Verification Value) and CVC (Card Verification Code) are security features for card-not-present transactions.',
    info2: 'CVV/CVC: Printed on card (3 digits). CVV2/CVC2: Enhanced version. iCVV: Integrated chip CVV. dCVV: Dynamic CVV for contactless.',
    info3: 'Generated using card data (PAN, expiry, service code) encrypted with issuer CVK keys.',
    tabGenerate: 'Generate',
    tabValidate: 'Validate',
    cvkA: 'CVK A',
    cvkB: 'CVK B',
    pan: 'PAN',
    expDate: 'Exp. date',
    serviceCode: 'Service Code',
    atc: 'ATC',
    cvvLabel: 'CVV/CVC',
    verificationType: 'Verification Value Type',
    errorInvalidCvkA: 'CVK A must be 32 hex characters (16 bytes)',
    errorInvalidCvkB: 'CVK B must be 32 hex characters (16 bytes)',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorInvalidExpDate: 'Exp. date must be 4 digits (YYMM)',
    errorInvalidServiceCode: 'Service code must be 3 digits',
    errorInvalidAtc: 'ATC must be 4 digits for iCVV/dCVV',
    errorInvalidCvv: 'CVV must be 3 digits',
    errorGeneration: 'Failed to generate CVV',
    errorValidation: 'Failed to validate CVV',
    validResult: '✓ Valid - CVV is correct',
    invalidResult: '✗ Invalid - CVV does not match',
    copyError: 'Failed to copy',
  },
  amexCsc: {
    title: 'Card Security Code (AMEX)',
    description: 'Generate and validate AMEX Card Security Codes (CSC) for American Express payment cards.',
    infoTitle: 'About AMEX CSC',
    info1: 'AMEX CSC (Card Security Code) is a security feature similar to CVV/CVC but specific to American Express cards.',
    info2: 'CSC ver. 1: 4-digit code on magnetic stripe. CSC ver. 2: Enhanced with CSC-5 (5 digits), CSC-4 (4 digits), and CSC-3 (3 digits printed on card front).',
    info3: 'Generated using AMEX 15-digit PAN, expiry date, and service code encrypted with the issuer CSC Key.',
    tabGenerate: 'Generate',
    tabValidate: 'Validate',
    cscKey: 'CSC Key',
    pan: 'PAN',
    expDate: 'Exp. date',
    serviceCode: 'Service Code',
    csc: 'CSC',
    cscVersion: 'CSC version',
    verificationType: 'Verification Value Type',
    errorInvalidKey: 'CSC Key must be 32 or 48 hex characters',
    errorInvalidPan: 'AMEX PAN must be 15 digits',
    errorInvalidExpDate: 'Exp. date must be 4 digits (YYMM)',
    errorInvalidServiceCode: 'Service code must be 3 digits',
    errorInvalidCsc: 'Invalid CSC length',
    errorGeneration: 'Failed to generate CSC',
    errorValidation: 'Failed to validate CSC',
    validResult: '✓ Valid - CSC is correct',
    invalidResult: '✗ Invalid - CSC does not match',
    copyError: 'Failed to copy',
  },
  mastercardCvc3: {
    title: 'Card Verification Code (MasterCard)',
    subtitle: 'Generate and validate MasterCard dynamic CVC3 for contactless EMV payment cards.',
    infoTitle: 'About MasterCard CVC3',
    info1: 'MasterCard dynamic CVC3 is a 3-digit security code generated dynamically for contactless EMV transactions.',
    info2: 'The CVC3 is derived from the ICC Master Key (IMK) and includes PAN, Track Data, Unpredictable Number, and ATC to ensure each transaction is unique.',
    imk: 'IMK',
    pan: 'PAN',
    panSeqNum: 'PAN Seq. Num.',
    track12Data: 'Track 1/2 Data',
    unpredictableNum: 'Unpredictable Num.',
    atc: 'ATC',
    cvc3Type: 'CVC3 type',
    dynamicCvc3: 'dynamic CVC3',
    pinCvc3: 'PIN-CVC3',
    generate: 'Generate',
    validate: 'Validate',
    errorInvalidImk: 'IMK must be 32 hex characters',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorInvalidPanSeq: 'PAN Seq. Num. must be 2 digits',
    errorInvalidTrack: 'Track 1/2 Data must be max 128 hex characters',
    errorInvalidUN: 'Unpredictable Number must be 8 hex characters',
    errorInvalidAtc: 'ATC must be 4 hex characters',
    errorInvalidCvc3: 'CVC3 must be 3 digits',
    errorGeneration: 'Failed to generate CVC3',
    errorValidation: 'Failed to validate CVC3',
    copyError: 'Failed to copy',
    validResult: '✓ Valid - CVC3 is correct',
    invalidResult: '✗ Invalid - CVC3 does not match',
  },
  dukpt: {
    title: 'DUKPT (ISO 9797)',
    subtitle: 'Derive keys and encrypt/decrypt data using DUKPT (Derived Unique Key Per Transaction) standard.',
    infoTitle: 'About DUKPT',
    info1: 'DUKPT (Derived Unique Key Per Transaction) is a key management scheme used in POS and ATM systems.',
    info2: 'It derives a unique encryption key for each transaction from a Base Derivation Key (BDK) and Key Serial Number (KSN), ensuring that compromised keys cannot be used to decrypt past transactions.',
    tabPekDerivation: 'PEK derivation',
    tabDukptPin: 'DUKPT PIN',
    tabDukptMac: 'DUKPT MAC',
    tabDukptData: 'DUKPT DATA',
    inputKeyDesignation: 'Input key designation',
    bdk: 'BDK',
    ipek: 'IPEK',
    ksn: 'KSN',
    pek: 'PEK',
    pinBlock: 'PIN block',
    algorithm: 'Algorithm',
    des: 'DES',
    threeDes: '3DES',
    data: 'Data',
    dataVariant: 'Data Variant',
    dataInput: 'Data input',
    ascii: 'ASCII',
    hexadecimal: 'Hexadecimal',
    derivePek: 'Derive PEK',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    calculateMac: 'Calculate MAC',
    result: 'Result',
    mac: 'MAC',
    errorInvalidBdk: 'BDK must be 32 hex characters',
    errorInvalidIpek: 'IPEK must be 32 hex characters',
    errorInvalidKsn: 'KSN must be 20 hex characters',
    errorInvalidPek: 'PEK must be 32 hex characters',
    errorInvalidPekMac: 'PEK must be 32 or 48 hex characters',
    errorInvalidPinBlock: 'PIN block must be 16 hex characters',
    errorInvalidData: 'Data is required',
    errorInvalidPekData: 'PEK must be 32 hex characters',
    errorInvalidEncryptedData: 'Encrypted data must be multiple of 16 hex characters',
    errorDerivation: 'Failed to derive PEK',
    errorEncryption: 'Failed to encrypt PIN block',
    errorDecryption: 'Failed to decrypt PIN block',
    errorMacCalculation: 'Failed to calculate MAC',
    errorDataEncryption: 'Failed to encrypt data',
    errorDataDecryption: 'Failed to decrypt data',
  },
  dukptAes: {
    title: 'DUKPT (AES)',
    subtitle: 'Derive keys and encrypt/decrypt data using DUKPT with AES support.',
    infoTitle: 'About DUKPT (AES)',
    info1: 'DUKPT (Derived Unique Key Per Transaction) with AES support extends the original DUKPT standard to use AES encryption algorithms.',
    info2: 'It supports 2TDEA, 3TDEA, AES-128, AES-192, and AES-256 encryption, providing enhanced security for modern payment systems.',
    tabWorkingKeyDerivation: 'Working key derivation',
    tabDukptPin: 'DUKPT PIN',
    tabDukptMac: 'DUKPT MAC',
    tabDukptData: 'DUKPT DATA',
    inputKeyDesignation: 'Input key designation',
    bdk: 'BDK',
    ik: 'IK',
    workingKeyType: 'Working key type',
    ksn: 'KSN',
    pek: 'PEK',
    pinBlock: 'PIN block',
    macGen: 'MAC Gen.',
    dek: 'DEK',
    dataInput: 'Data input',
    ascii: 'ASCII',
    hexadecimal: 'Hexadecimal',
    data: 'Data',
    deriveKey: 'Derive Key',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    calculateMac: 'Calculate MAC',
    result: 'Result',
    workingKey: 'Working Key',
    mac: 'MAC',
    errorInvalidKeyLength: '{keyDesignation} must be {expectedLength} hex characters',
    errorInvalidKsn: 'KSN must be 24 hex characters',
    errorInvalidPekLength: 'PEK must be {expectedLength} hex characters',
    errorInvalidPinBlock: 'PIN block must be 32 hex characters',
    errorInvalidMacLength: 'MAC Gen. must be {expectedLength} hex characters',
    errorInvalidDekLength: 'DEK must be {expectedLength} hex characters',
    errorInvalidData: 'Data is required',
    errorInvalidEncryptedData: 'Encrypted data must be multiple of {blockSize} hex characters',
    errorDerivation: 'Failed to derive working key',
    errorEncryption: 'Failed to encrypt',
    errorDecryption: 'Failed to decrypt',
    errorMacCalculation: 'Failed to calculate MAC',
    errorDataEncryption: 'Failed to encrypt data',
    errorDataDecryption: 'Failed to decrypt data',
  },

  mac: {
    as2805: {
      title: 'AS2805 MAC',
      description: 'AS2805.4.1 표준을 사용하여 메시지 인증 코드를 계산합니다.',
      infoTitle: 'AS2805 MAC 정보',
      infoDescription1: 'AS2805.4.1은 호주 결제 시스템에서 사용되는 MAC 알고리즘을 정의합니다.',
      infoDescription2: '메소드 2는 최종 블록에 3DES 암호화를 사용한 DES CBC-MAC을 사용합니다.',
      algorithm: 'MAC 알고리즘:',
      algorithmMethod1: 'AS2805.4.1 MAC 메소드 1',
      algorithmMethod2: 'AS2805.4.1 MAC 메소드 2',
      keyKL: '키 (K|KL):',
      keyKLPlaceholder: '0123456789ABCDEF',
      keyKR: '키 (KR):',
      keyKRPlaceholder: 'FEDCBA9876543210',
      data: '데이터:',
      dataPlaceholder: '16진수 데이터 입력',
      truncation: '절단:',
      truncationPlaceholder: '4',
      calculate: 'MAC 계산',
      result: 'MAC:',
      hexChars: '16진수 문자',
      copied: '복사됨!',
      success: 'MAC 계산 성공',
      error: {
        invalidKeyKL: '키 (K|KL)는 16개의 16진수 문자여야 합니다',
        invalidKeyKR: '키 (KR)는 16개의 16진수 문자여야 합니다',
        emptyData: '데이터가 필요합니다',
        invalidDataFormat: '잘못된 데이터 형식',
        invalidTruncation: '절단은 1에서 8 사이여야 합니다',
        calculationFailed: 'MAC 계산 실패',
      },
    },
    tdescbc: {
      title: 'TDES CBC-MAC',
      description: 'CBC 모드의 트리플 DES를 사용하여 MAC을 계산합니다.',
      algorithm: '알고리즘',
      keyK: '키 (K)',
      padding: '패딩',
      data: '데이터 (16진수)',
      truncation: '절단 (바이트)',
      calculate: 'MAC 계산',
      result: 'MAC 결과',
      hexChars: '16진수 문자',
      copied: '복사됨!',
      success: 'MAC 계산 성공',
      error: {
        invalidKeyFormat: '잘못된 키 형식',
        invalidKeyLength: '키는 32 또는 48개의 16진수 문자여야 합니다',
        emptyData: '데이터가 필요합니다',
        invalidDataFormat: '잘못된 데이터 형식',
        invalidTruncation: '절단은 1-8 바이트여야 합니다',
      },
    },
    hmac: {
      title: 'HMAC',
      description: '해시 기반 메시지 인증 코드를 계산합니다.',
      hashType: '해시 유형',
      inputTypeLabel: '입력 유형',
      hmacKey: 'HMAC 키',
      data: '데이터',
      keyPlaceholderHex: '16진수 키 입력',
      keyPlaceholderAscii: 'ASCII 키 입력',
      dataPlaceholderHex: '16진수 데이터 입력',
      dataPlaceholderAscii: 'ASCII 데이터 입력',
      calculate: 'HMAC 계산',
      result: 'HMAC 결과',
      hexChars: '16진수 문자',
      copied: '복사됨!',
      success: 'HMAC이 성공적으로 계산되었습니다',
      error: {
        emptyKey: '키가 필요합니다',
        invalidKeyFormat: '잘못된 키 형식',
        emptyData: '데이터가 필요합니다',
        invalidDataFormat: '잘못된 데이터 형식',
      },
    },
    cmac: {
      title: 'CMAC',
      infoTitle: 'CMAC 정보',
      info: 'AES 또는 TDES와 NIST SP 800-38B 표준을 사용하여 암호 기반 MAC 계산',
      description: '암호 기반 메시지 인증 코드를 계산합니다.',
      encryptionType: '암호화 유형',
      cmacKey: 'CMAC 키',
      data: '데이터',
      inputTypeLabel: '입력 유형',
      keyPlaceholderHex: '16진수 키 입력',
      keyPlaceholderAscii: 'ASCII 키 입력',
      dataPlaceholderHex: '16진수 데이터 입력',
      dataPlaceholderAscii: 'ASCII 데이터 입력',
      aesCmac96: 'AES CMAC 96 (12바이트로 자르기)',
      calculate: 'CMAC 계산',
      result: 'CMAC 결과',
      hexChars: '16진수 문자',
      copied: '복사됨!',
      success: 'CMAC이 성공적으로 계산되었습니다',
      error: {
        emptyKey: '키가 필요합니다',
        invalidKeyFormat: '잘못된 키 형식',
        invalidKeyLength: '잘못된 키 길이',
        emptyData: '데이터가 필요합니다',
        invalidDataFormat: '잘못된 데이터 형식',
      },
    },
    retail: {
      title: 'Retail MAC',
      description: 'DES 또는 트리플 DES를 사용하여 Retail MAC을 계산합니다.',
      algorithm: '알고리즘',
      finalize: '파이널라이즈',
      keyK: '키 (K)',
      keyKPlaceholder: '0123456789ABCDEF',
      keyKPrime: '키 (K\')',
      keyKPrimePlaceholder: 'FEDCBA9876543210',
      data: '데이터 (16진수)',
      dataPlaceholder: '16진수 데이터 입력',
      truncation: '절단 (바이트)',
      truncationPlaceholder: '1-8',
      calculate: 'MAC 계산',
      result: 'MAC 결과',
      hexChars: '16진수 문자',
      copied: '복사됨!',
      success: 'MAC이 성공적으로 계산되었습니다',
      error: {
        invalidKeyK: '키 K는 16개의 16진수 문자여야 합니다',
        invalidKeyKPrime: '키 K\'는 16개의 16진수 문자여야 합니다',
        emptyData: '데이터가 필요합니다',
        invalidDataFormat: '잘못된 데이터 형식',
        invalidTruncation: '절단은 1-8 바이트여야 합니다',
      },
    },
    zka: {
      title: 'ZKA (독일 은행 표준)',
      infoTitle: 'ZKA 정보',
      info1: '독일 은행 키 관리 및 암호화 작업 표준',
      info2: 'SK 파생, PIN 암호화 및 MAC 계산 포함',
      description: '독일 은행 시스템을 위한 ZKA 암호화 작업',
    },
  },

  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: '키 생성',
    tr31: 'TR-31',
    kcv: 'KCV',
    pinBlock: 'PIN 블록',
    asn1: 'ASN.1',
    cipher: '암호화',
    generic: '일반 도구',
    hashes: '해시',
    characterEncoding: '문자 인코딩',
    bcd: 'BCD',
    checkDigits: '체크 디지트',
    base64: 'Base64',
    base94: 'Base94',
    messageParser: '메시지 파서',
    rsaDerPublicKey: 'RSA DER 공개키',
    uuid: 'UUID',
    // PKI 메뉴
    pki: 'PKI',
    asn1Decoder: 'ASN.1 디코더',
    sslCertificates: 'SSL 인증서',
    // Keys 메뉴
    keys: '키',
    keysDea: 'Keys DEA',
    keyshareGenerator: 'Keyshare Generator',
    keysHsm: 'Keys HSM',
    keysFuturex: 'Keys Futurex',
    keysAtalla: 'Keys Atalla',
    keysSafeNet: 'Keys SafeNet',
    keysThales: 'Keys Thales',
    keyBlocks: 'Key Blocks',
    thalesKeyBlock: 'Thales Key Block',
    tr31KeyBlock: 'TR-31 Key Block',
    // Payments 메뉴
    payments: 'Payments',
    as2805: 'AS2805',
    bitmap: 'Bitmap',
    cardValidation: 'Card Validation',
    cvvs: 'CVVs',
    amexCscs: 'AMEX CSCs',
    mastercardCvc3: 'MasterCard dynamic CVC3',
    dukpt: 'DUKPT',
    dukptIso9797: 'DUKPT (ISO 9797)',
    dukptAes: 'DUKPT (AES)',
    macAlgorithms: 'MAC Algorithms',
    iso9797_1: 'ISO/IEC 9797-1',
    ansix9: 'ANSI X9.9 & X9.19',
    as2805_4_1: 'AS2805.4.1',
    tdesCbcMac: 'TDES CBC-MAC',
    hmac: 'HMAC',
    cmac: 'CMAC',
    retail: 'Retail',
    pinBlocks: 'PIN Blocks',
    pinBlocksGeneral: 'PIN Blocks General',
    pinBlocksAes: 'PIN Blocks AES',
    pinOffset: 'PIN Offset',
    pinPvv: 'PIN PVV',
    visaCertificates: 'Visa Certificates',
    zka: 'ZKA',
  },
  
  as2805: {
    infoTitle: 'AS2805 도구 소개',
    info1: '터미널 키 세트 생성, PIN 블록 변환(포맷 01/46), MAC 계산(ISO9797-1 M2, TDES-CBC) 및 OWF(HMAC-SHA256)를 포함합니다. 모든 작업은 클라이언트 측에서 실행됩니다.',
    description: '결제 관련 일반 작업을 브라우저에서 구현',
    tabGenerate: '터미널 키 세트 생성',
    tabTranslatePin: 'PIN 블록 변환',
    kekFlag: 'KEK 플래그',
    kekrKey: 'KEKr 키',
    schemeKek: 'KEK 키 스킴',
    schemeLmk: 'LMK 키 스킴',
    kcvType: 'KCV 유형',
    translate: '변환',
    sysZpk: '시스템 ZPK',
    termTpk: '터미널 TPK',
    stan: 'STAN',
    amount: '거래 금액',
    inFmt: '수신 PIN 블록 형식',
    outFmt: '발신 PIN 블록 형식',
    inPinBlock: '수신 PIN 블록',
    account: '계좌 번호',
    key: '키',
    data: '데이터',
    errorInvalidHex: '잘못된 16진수 입력',
    errorGeneration: '생성 실패',
    errorPinBlock: 'PIN 블록은 16개의 16진수 문자여야 합니다',
    errorAccount: '계좌 번호는 12~19자리 숫자여야 합니다',
    errorKeyLength: '키 길이가 잘못되었습니다',
    errorCalculation: '계산 실패',
  },
  
  footer: {
    tagline: '브라우저 기반 보안 계산 도구',
    privacyPolicy: '개인정보 처리방침',
    termsOfService: '이용약관',
    disclaimer: '면책 조항',
    contact: '문의 및 피드백',
  },

  privacyPolicy: {
    seoTitle: '개인정보 처리방침 | HSM Kit',
    seoDescription: 'HSM Kit 개인정보 처리방침 - 클라이언트 측 처리를 통한 데이터 보호 방법을 알아보세요.',
    seoKeywords: '개인정보 처리방침, 데이터 보호, 클라이언트 측 처리, HSM Kit',
    title: '개인정보 처리방침',
    introTitle: '소개',
    introContent: 'HSM Kit에서는 귀하의 보안과 개인정보를 중요하게 생각합니다. 본 개인정보 처리방침은 온라인 암호화 도구를 사용할 때 데이터를 처리하는 방법을 설명합니다.',
    clientSideTitle: '클라이언트 측 처리',
    clientSideContent: '당사는 귀하의 입력 데이터를 수집, 저장 또는 전송하지 않습니다. 모든 암호화 작업(암호화, 복호화, 해싱, 키 포맷팅)은 JavaScript를 사용하여 귀하의 웹 브라우저 내에서 완전히 수행됩니다. 귀하의 키, PIN 및 데이터는 장치를 떠나지 않으며 당사 서버로 전송되지 않습니다.',
    dataCollectionTitle: '데이터 수집',
    dataCollectionContent: '당사는 개인 정보를 추적하거나 저장하지 않습니다.',
    analyticsTitle: '사용 분석',
    analyticsContent: '페이지 조회수 및 사이트 성능을 추적하기 위해 익명 분석 도구(예: Google Analytics)를 사용할 수 있습니다. 이러한 도구는 계산 양식에 입력한 데이터에 액세스할 수 없습니다.',
    localStorageTitle: '로컬 스토리지',
    localStorageContent: '인터페이스 기본 설정(예: 다크 모드 설정)을 저장하기 위해 브라우저의 로컬 스토리지를 사용할 수 있습니다. 이 데이터는 귀하의 장치에 저장되며 당사에 전송되지 않습니다.',
    thirdPartyTitle: '제3자 서비스',
    thirdPartyContent: '당사 웹사이트는 퍼블릭 클라우드 제공업체에서 호스팅됩니다. 당사는 데이터를 수집하지 않지만 표준 서버 로그(IP 주소, 사용자 에이전트)는 보안 및 유지 관리 목적으로 호스팅 제공업체에서 처리될 수 있습니다.',
    changesTitle: '정책 변경',
    changesContent: '당사는 수시로 본 개인정보 처리방침을 업데이트할 수 있습니다. 변경 사항이 있는지 정기적으로 이 페이지를 검토하시기 바랍니다.',
    lastUpdated: '최종 업데이트',
    lastUpdatedDate: '{year}년 1월',
    backToHome: '홈으로 돌아가기',
    contactTitle: '문의하기',
    contactContent: '본 개인정보 처리방침에 대해 궁금한 점이 있으시면 다음 이메일로 문의해 주세요: ',
  },

  termsOfService: {
    seoTitle: '이용약관 | HSM Kit',
    seoDescription: 'HSM Kit 이용약관 - 암호화 도구 사용에 관한 이용약관을 확인하세요.',
    seoKeywords: '이용약관, 서비스 약관, 사용자 계약, HSM Kit',
    title: '이용약관',
    acceptanceTitle: '1. 약관 동의',
    acceptanceContent: 'HSM Kit (hsmkit.com)에 접속하고 사용함으로써 귀하는 본 계약의 조건에 구속되는 것에 동의합니다. 이 약관에 동의하지 않으시면 본 웹사이트를 사용하지 마십시오.',
    useOfServiceTitle: '2. 서비스 이용',
    useOfServiceIntro: 'HSM Kit는 개발자와 보안 전문가를 위한 온라인 암호화 도구를 제공합니다.',
    licenseTitle: '라이선스',
    licenseContent: '개인, 교육 및 전문 테스트 목적으로 도구를 사용할 수 있는 제한적이고 비독점적이며 양도 불가능한 라이선스를 부여합니다.',
    restrictionsTitle: '제한 사항',
    restrictionsContent: '서비스를 오용하지 않기로 동의합니다. 여기에는 다음이 포함되지만 이에 국한되지 않습니다:',
    restriction1: '웹사이트의 정상적인 작동을 방해하려는 시도(예: DDoS 공격).',
    restriction2: '당사의 허가 없이 자동화 시스템(로봇, 스파이더)을 사용하여 웹사이트에 접근하는 행위.',
    restriction3: '불법 활동이나 악의적인 행위를 용이하게 하기 위해 도구를 사용하는 행위.',
    intellectualPropertyTitle: '3. 지적 재산권',
    intellectualPropertyContent: '본 웹사이트의 콘텐츠, 레이아웃, 디자인, 데이터, 데이터베이스 및 그래픽은 지적 재산권법에 의해 보호되며, 달리 명시되지 않는 한 HSM Kit가 소유합니다. 당사의 명시적인 서면 허가 없이 서비스의 어떤 부분도 복제, 복사, 판매 또는 이용할 수 없습니다.',
    disclaimerTitle: '4. 보증 면책',
    disclaimerContent: '도구는 "있는 그대로" 및 "이용 가능한 상태"로 제공됩니다. HSM Kit는 계산의 정확성, 신뢰성 또는 완전성에 대해 명시적이든 묵시적이든 어떠한 진술이나 보증도 하지 않습니다.',
    limitationTitle: '5. 책임 제한',
    limitationContent: '어떠한 경우에도 HSM Kit 또는 그 운영자는 본 웹사이트의 사용으로 인해 또는 이와 관련하여 발생하는 직접적, 간접적, 우발적, 특별 또는 결과적 손해에 대해 책임을 지지 않습니다. 여기에는 데이터 손실, 이익 손실 또는 사업 중단이 포함되지만 이에 국한되지 않습니다.',
    changesTitle: '6. 약관 변경',
    changesContent: '당사는 언제든지 이 약관을 수정할 권리를 보유합니다. 변경 후에도 웹사이트를 계속 사용하면 새 약관에 동의하는 것으로 간주됩니다.',
    lastUpdated: '최종 업데이트',
    lastUpdatedDate: '{year}년 1월',
    backToHome: '홈으로 돌아가기',
    contactTitle: '문의하기',
    contactContent: '본 이용약관에 대해 궁금한 점이 있으시면 다음 이메일로 문의해 주세요: ',
  },

  disclaimer: {
    seoTitle: '면책 조항 | HSM Kit',
    seoDescription: 'HSM Kit 법적 면책 조항 - 암호화 도구 사용에 관한 중요 정보.',
    seoKeywords: '면책 조항, 법적 고지, 이용 약관, HSM Kit',
    title: '면책 조항',
    generalTitle: '일반 면책 조항',
    generalContent: 'HSM Kit에서 제공하는 도구 및 정보는 교육, 테스트 및 개발 목적으로만 사용됩니다. 알고리즘과 계산의 정확성을 보장하기 위해 노력하지만, 본 소프트웨어는 명시적이든 묵시적이든 어떠한 종류의 보증 없이 "있는 그대로" 제공됩니다.',
    noLiabilityTitle: '책임 제한',
    noLiabilityContent: '어떠한 경우에도 저자 또는 저작권 보유자는 계약, 불법 행위 또는 기타 소송에서 소프트웨어 또는 소프트웨어의 사용 또는 기타 거래와 관련하여 발생하는 청구, 손해 또는 기타 책임에 대해 책임을 지지 않습니다.',
    securityTitle: '보안 경고',
    securityContent: '이 웹사이트에서 실제 프로덕션 키, 민감한 금융 데이터 또는 실제 개인 정보를 사용하지 마십시오. 모든 계산이 클라이언트 측에서 수행되지만 브라우저 환경에서 실제 암호화 자료를 노출하지 않는 것이 보안 업계의 모범 사례입니다.',
    securityWarningTitle: '중요 보안 공지',
    securityWarningContent: '이 웹사이트에서 실제 프로덕션 키, 민감한 데이터 또는 실제 자격 증명을 사용하지 마십시오. 이 도구는 교육 및 테스트 목적으로만 사용됩니다.',
    complianceTitle: '규정 준수',
    complianceContent: '사용자는 이러한 도구의 사용이 모든 적용 가능한 지역, 주 및 연방 법률 및 규정을 준수하는지 확인할 책임이 있습니다.',
    lastUpdated: '최종 업데이트',
    lastUpdatedDate: '{year}년 1월',
    backToHome: '홈으로 돌아가기',
    contactTitle: '문의하기',
    contactContent: '본 면책 조항에 대해 궁금한 점이 있으시면 다음 이메일로 문의해 주세요: ',
  },

  home: {
    heroTitle: '무료 온라인 암호화 및 키 관리 도구',
    heroDescription: '보안 전문가를 위한 종합 암호화 도구 모음입니다. 모든 계산은 브라우저에서 클라이언트 측에서 수행되며, 데이터가 기기를 떠나지 않습니다.',
    searchPlaceholder: '도구 검색... (예: MD5, AES, PIN Block)',
    availableTools: '인기 도구',
    gridView: '그리드 보기',
    listView: '목록 보기',
    whyChoose: '왜 HSM Kit를 선택해야 할까요?',
    categories: {
      all: '전체',
      symmetric: '대칭 암호화',
      asymmetric: '비대칭 암호화',
      payment: '결제/금융',
      encoding: '인코딩',
      hashing: '해시',
    },
    tools: {
      asn1: {
        title: 'ASN.1 파서',
        description: 'ASN.1 DER/BER 구조를 분석하고 X.509 인증서 및 PKCS 형식을 디코딩합니다.',
      },
      aes: {
        title: 'AES 암호화',
        description: 'AES-128/192/256으로 데이터를 암호화/복호화. ECB, CBC, CFB, OFB, CTR 모드 지원.',
      },
      des: {
        title: 'DES/3DES 암호화',
        description: '레거시 시스템을 위한 다양한 패딩 옵션이 있는 DES 및 Triple DES 암호화.',
      },
      rsa: {
        title: 'RSA 암호화',
        description: 'RSA 비대칭 암호화, 복호화, 디지털 서명 및 검증.',
      },
      ecc: {
        title: 'ECC/ECDSA',
        description: '컴팩트한 키와 효율적인 디지털 서명을 위한 타원 곡선 암호화.',
      },
      fpe: {
        title: '형식 보존 암호화',
        description: 'FPE (FF1/FF3-1)로 형식과 길이를 보존하면서 데이터를 암호화.',
      },
      keyGenerator: {
        title: '키 생성기',
        description: 'AES, DES, 3DES용 보안 랜덤 키 생성. 키 조합 및 패리티 도구.',
      },
      tr31: {
        title: 'TR-31 키 블록',
        description: 'KBPK 보호로 TR-31/ANSI X9.143 키 블록 인코딩/디코딩. TDES 및 AES 버전 지원.',
      },
      kcv: {
        title: 'KCV 계산기',
        description: 'AES 및 DES/3DES 키의 키 검증값(KCV) 계산.',
      },
      pinBlock: {
        title: 'PIN 블록 생성기',
        description: '결제 거래용 ISO 9564 PIN 블록 (형식 0, 1, 3, 4) 생성.',
      },
      pinBlockGeneral: {
        title: 'PIN 블록 일반',
        description: '모든 ISO 9564 형식(0, 1, 2, 3, 4)에서 PAN을 사용하여 PIN 블록 인코딩/디코딩.',
      },
      pinBlockAes: {
    title: 'AES PIN Block Format 4',
    infoTitle: 'About AES PIN Block',
    info1: 'PIN Block Format 4 is designed specifically for AES encryption with 128-bit block size.',
    info2: 'Unlike older formats, Format 4 uses a 32 hex character block (16 bytes) suitable for AES.',
    info3: 'The PIN block is XORed with the PAN block before AES encryption for enhanced security.',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    keyLabel: 'Key:',
    keyPlaceholder: 'C1D0F8FB4958670DBA40AB1F3752EF0D',
    keyHint: 'AES-128 key: 32 hex characters (16 bytes)',
    panLabel: 'PAN/PAN Block:',
    panPlaceholder: '6432198765432109870',
    pinLabel: 'PIN/PIN Block:',
    pinPlaceholder: '441234',
    encryptedBlockLabel: 'Encrypted PIN Block:',
    encryptedBlockPlaceholder: 'Enter encrypted PIN block (32 hex chars)',
    encryptButton: 'Encrypt',
    decryptButton: 'Decrypt',
    resultEncrypted: 'Encrypted PIN Block',
    resultDecrypted: 'Decrypted PIN',
    clearPinBlock: 'Clear PIN Block:',
    panBlockUsed: 'PAN Block (used in XOR):',
    format: 'Format',
    algorithm: 'Algorithm',
    pinLength: 'PIN Length',
    errorInvalidPin: 'PIN must be 4-12 digits',
    errorInvalidPan: 'PAN must be 13-19 digits',
    errorInvalidKey: 'AES key must be 32 hex characters (16 bytes)',
    errorInvalidBlock: 'Block must be 32 hex characters',
    errorInvalidFormat: 'Invalid PIN Block format (not Format 4)',
    errorInvalidPinLength: 'Invalid PIN length in block',
    errorEncryption: 'Encryption failed',
    errorDecryption: 'Decryption failed',
    errorProcessing: 'Processing failed, please check input',
  },

  pinOffset: {

      pinOffset: {
        title: 'PIN 오프셋',
        description: '검증 데이터를 사용하여 IBM 3624 방법으로 PIN 오프셋 계산 및 확인.',
      },
      pinPvv: {
        title: 'PIN PVV',
        description: 'PDK/PVKI를 사용한 Visa PIN 검증값(PVV) 계산 및 PIN 검증.',
      },
      as2805: {
        title: 'AS2805 메시지 도구',
        description: '호주 ISO 8583 결제 도구, 키 생성, PIN 블록 변환, MAC 계산.',
      },
      ansiMac: {
        title: 'ANSI MAC (X9.9 & X9.19)',
        description: 'ANSI X9.9/X9.19 MAC, DES CBC-MAC 또는 3DES 암호화.',
      },
      as2805Mac: {
        title: 'AS2805 MAC',
        description: 'AS2805.4.1 호주 EFTPOS MAC, 방법 1과 방법 2 지원.',
      },
      tdesCbcMac: {
        title: 'TDES CBC-MAC',
        description: 'Triple DES CBC-MAC, 2/3-키 TDES와 ISO 9797-1 패딩.',
      },
      hmac: {
        title: 'HMAC',
        description: 'SHA-256/SHA-512 기반 MAC, API 인증 및 데이터 무결성 검증.',
      },
      cmac: {
        title: 'CMAC',
        description: 'NIST SP 800-38B 암호 기반 MAC, AES/TDES와 CMAC-96.',
      },
      retailMac: {
        title: '리테일 MAC',
        description: 'ISO 9797-1 방법 2 리테일 MAC, DES/3DES, POS와 ATM 시스템.',
      },
      iso9797: {
        title: 'ISO 9797-1 MAC',
        description: 'ISO/IEC 9797-1 MAC 계산기, 알고리즘 1-6 및 다양한 패딩 방법 지원.',
      },
      visaCertificates: {
        title: 'VISA 인증서',
        description: 'VISA 인증서 검증, VSDC CA V92/V94 및 사용자 지정 CA.',
      },
      zka: {
        title: 'ZKA',
        description: '독일 은행 표준, 세션 키 파생, PIN 암호화, MAC 계산.',
      },
      bitmap: {
        title: 'ISO8583 비트맵',
        description: '결제 메시지를 위한 ISO 8583 비트맵 인코딩/디코딩. 기본 및 보조 비트맵을 지원합니다.',
      },
      cvv: {
        title: 'CVV/CVC',
        description: '카드 확인 및 결제 보안을 위한 CVV, iCVV, CVV2, dCVV를 생성하고 검증합니다.',
      },
      amexCsc: {
        title: 'AMEX CSC',
        description: '아메리칸 익스프레스 카드 보안 코드(CSC-5, CSC-4, CSC-3)를 생성하고 검증합니다.',
      },
      mastercardCvc3: {
        title: 'MasterCard CVC3',
        description: 'MasterCard 비접촉 EMV 거래를 위한 동적 CVC3를 생성합니다.',
      },
      dukpt: {
        title: 'DUKPT (ISO 9797)',
        description: 'BDK/IPEK 및 KSN에서 PEK를 파생합니다. PIN 암호화/복호화, MAC 계산, 데이터 처리.',
      },
      dukptAes: {
        title: 'DUKPT (AES)',
        description: 'AES 지원(2TDEA, 3TDEA, AES-128/192/256)을 가진 DUKPT. 작업 키를 파생하고 데이터를 처리합니다.',
      },
      hash: {
        title: '해시 계산기',
        description: 'MD5, SHA-1, SHA-256, SHA-512, BLAKE2 등 다양한 알고리즘으로 해시값 계산.',
      },
      encoding: {
        title: '문자 인코딩',
        description: 'ASCII, EBCDIC, 16진수, 이진수, ATM 십진수 간 변환.',
      },
      bcd: {
        title: 'BCD 인코더/디코더',
        description: '십진수를 BCD로 인코딩하거나 BCD를 십진수로 디코딩.',
      },
      checkDigits: {
        title: '체크 디지트',
        description: 'Luhn (MOD 10) 및 MOD 9 알고리즘으로 체크 디지트 계산 및 검증.',
      },
      base64: {
        title: 'Base64',
        description: 'Base64 바이너리-텍스트 인코딩으로 데이터 인코딩/디코딩.',
      },
      base94: {
        title: 'Base94',
        description: '94개의 모든 출력 가능한 ASCII 문자를 사용한 컴팩트 인코딩.',
      },
      messageParser: {
        title: '메시지 파서',
        description: 'ATM NDC, Wincor, ISO 8583 금융 메시지 형식 구문 분석.',
      },
      rsaDer: {
        title: 'RSA DER 공개키',
        description: '모듈러스/지수와 DER 형식 간 RSA 공개키 인코딩/디코딩.',
      },
      uuid: {
        title: 'UUID 생성기',
        description: '범용 고유 식별자 (UUID v1, v3, v4, v5) 생성.',
      },
      // Keys HSM Tools
      keyshareGenerator: {
        title: '키 공유 생성기',
        description: 'KCV 계산을 지원하는 안전한 키 분할 및 구성 요소 관리를 위한 키 공유 생성.',
      },
      futurexKeys: {
        title: 'Futurex 키',
        description: 'Futurex HSM 키 암호화, 복호화 및 여러 변형으로 조회.',
      },
      atallaKeys: {
        title: 'Atalla 키 (AKB)',
        description: 'MFK 및 MAC 검증을 지원하는 Atalla AKB 형식 키 암호화 및 복호화.',
      },
      safeNetKeys: {
        title: 'SafeNet 키',
        description: 'KM 키 변형을 지원하는 SafeNet HSM 키 암호화, 복호화 및 조회.',
      },
      thalesKeys: {
        title: 'Thales 키',
        description: '변형을 지원하는 Thales HSM LMK 키 암호화, 복호화 및 조회.',
      },
      thalesKeyBlock: {
        title: 'Thales 키 블록',
        description: 'KBPK 보호를 사용한 Thales 독점 키 블록 인코딩 및 디코딩.',
      },
      sslCert: {
        title: 'SSL 인증서',
        description: 'RSA 키 쌍 생성, CSR 생성, 자체 서명 X.509 인증서 생성 및 인증서 분석.',
      },
    },
    features: {
      clientSide: {
        title: '100% 브라우저 기반',
        description: '모든 암호화 작업이 브라우저에서 완전히 실행됩니다. 키, PIN, 민감한 데이터가 장치를 떠나지 않습니다.',
      },
      free: {
        title: '무료 & 오픈',
        description: '25개 이상의 도구가 모두 무료입니다. 등록 불필요, 로그인 불필요, 숨겨진 비용 없음. 즉시 사용 가능.',
      },
      paymentReady: {
        title: 'HSM & 결제 대응',
        description: 'Thales, Futurex, Atalla, SafeNet HSM을 전문적으로 지원. TR-31, KCV, PIN 블록 등.',
      },
    },
  },
  
  asn1: {
    title: 'ASN.1 파서',
    description: 'ASN.1 DER/BER 구조를 구문 분석 및 분석하고 RFC 정의 매칭 지원',
    infoTitle: 'ASN.1 파서 정보',
    infoContent1: 'ASN.1 DER/BER 인코딩된 데이터 구조 구문 분석',
    infoContent2: '16진수, Base64, PEM 입력 형식 지원',
    infoContent3: 'RFC 정의를 활성화하여 X.509, PKCS 등 알려진 구조와 매칭',
    inputLabel: '입력 (Hex, Base64, 또는 PEM):',
    inputPlaceholder: 'hex, base64 또는 PEM 인코딩된 ASN.1 BER/DER 구조를 붙여넣거나 파일 업로드',
    withHexDump: 'Hex Dump 표시',
    trimBigChunks: '큰 데이터 간소화',
    withDefinitions: '정의 매칭 활성화',
    uploadFile: '파일 업로드',
    parse: '구문 분석',
    clear: '지우기',
    structureDefinition: '구조 정의:',
    selectDefinition: '구조 정의 선택...',
    parsedResult: '구문 분석 결과:',
    hexDump: 'Hex Dump:',
    offset: '오프셋',
    length: '길이',
    value: '값',
    constructed: '구조 타입',
    loadError: 'ASN.1 파싱 라이브러리 로드 실패',
    inputRequired: 'ASN.1 데이터를 입력하세요',
    parseError: '구문 분석 실패',
    copied: '복사됨',
    copyHex: 'Hex 복사',
    copyHexDump: 'Hex Dump 복사',
    copyBase64: 'Base64 복사',
    copySubtree: '하위 트리 복사',
    copyValue: '값 복사',
  },
  
  keyGenerator: {
    title: '랜덤 키 생성기',
    description: 'DES, 3DES 또는 AES용 암호학적으로 강력한 랜덤 키를 생성합니다.',
    infoTitle: '키 생성기 정보',
    infoContent1: 'Web Crypto API를 사용하여 암호학적으로 안전한 랜덤 키 생성',
    infoContent2: 'DES (8바이트), 3DES (16/24바이트), AES (16/24/32바이트) 지원',
    infoContent3: '키 검증을 위한 KCV (키 체크 값) 자동 계산',
    keyLength: '키 길이',
    bytes: '바이트',
    bits: '비트',
    generateNow: '지금 생성',
    generatedKey: '생성된 키 (16진수)',
    kcv: 'KCV',
    length: '길이',
    tabKeyGen: '키 생성',
    tabCombination: '키 조합',
    tabParity: '패리티 조정',
    tabValidation: '키 검증',
    combinationTitle: '키 컴포넌트 조합',
    combinationDesc: '여러 키 컴포넌트를 XOR로 조합',
    component: '컴포넌트',
    components: '개 컴포넌트',
    combinedKey: '조합된 키',
    addComponent: '추가',
    removeComponent: '제거',
    combineKeys: '조합',
    errorInvalidComponent: '컴포넌트 {index} 무효',
    errorComponentLength: '모든 컴포넌트의 길이가 같아야 합니다',
    errorComponentLength2: '길이는 다음 중 하나여야 합니다',
    errorMinComponents: '최소 2개의 컴포넌트 필요',
    errorMaxComponents: '최대 9개 컴포넌트까지 가능',
    clearAll: '모두 지우기',
    parityTitle: '패리티 조정',
    parityDesc: 'DES/3DES 키의 패리티 비트 조정',
    keyInput: '키 입력',
    keyInputPlaceholder: '16진수 키 입력',
    parityType: '패리티 유형',
    odd: '홀수',
    even: '짝수',
    adjustParity: '조정',
    adjustedKey: '조정된 키',
    validationTitle: '키 유효성 검사',
    validationDesc: '형식, 길이 및 패리티 확인',
    validateKey: '검증',
    validKey: '유효한 키',
    invalidKey: '무효한 키',
    keyType: '키 유형',
    parityStatus: '패리티 상태',
    parityValid: '유효',
    parityInvalid: '무효',
  },
  
  kcvCalculator: {
    title: 'KCV 계산기',
    description: '키 확인 값을 계산하여 키의 정확성을 검증합니다.',
    algorithm: '알고리즘',
    keyInput: '키 (16진수)',
    keyPlaceholder: '예: 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'KCV 계산',
    keyCheckValue: '키 확인 값',
    errorInvalidHex: '키는 유효한 16진수 문자여야 합니다',
    errorDesLength: 'DES/3DES 키 길이는 8, 16 또는 24바이트여야 합니다',
    errorAesLength: 'AES 키 길이는 16, 24 또는 32바이트여야 합니다',
    errorCalculation: '계산에 실패했습니다. 키 형식을 확인하세요',
    format: '형식',
    autoAdjustParity: '패리티 비트 자동 조정',
    parityAdjustmentHint: '일부 키에는 올바른 패리티 비트가 설정되어 있지 않을 수 있습니다. 이 옵션을 선택하면 자동으로 수정됩니다',
    kcvCalcTitle: '키 확인 값 계산',
    desCalcDesc: '키의 평문을 사용하여 16자 길이의 \'0\'을 3DES-ECB 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
    aesCalcDesc: '키의 평문을 사용하여 32자 길이의 \'0\'을 CMAC-AES 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
  },
  
  pinBlock: {
    title: 'PIN 블록 생성기',
    description: '결제 거래용 ISO 형식 PIN 블록을 생성합니다.',
    format: 'PIN 블록 형식',
    pinLabel: 'PIN (4-12자리)',
    pinPlaceholder: '예: 1234',
    panLabel: 'PAN (기본 계좌 번호)',
    panPlaceholder: '예: 4111111111111111',
    generatePinBlock: 'PIN 블록 생성',
    pinBlockHex: 'PIN 블록 (16진수)',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidPan: 'PAN은 13-19자리 숫자여야 합니다',
    errorGeneration: '생성에 실패했습니다. 입력을 확인하세요',
    errorFormat1: 'ISO Format 1은 곧 출시됩니다...',
    pinLengthHint: '4-12자리 PIN 지원',
    panHint: '전체 카드 번호를 입력하세요 (13-19자리), 시스템이 자동으로 오른쪽 12자리를 추출합니다 (체크 디지트 제외)',
  },

  pinBlockGeneral: {
    title: 'PIN 블록',
    infoTitle: 'PIN 블록 정보',
    info1: 'ISO 9564는 결제 시스템에서 안전한 PIN 전송을 위한 PIN 블록 형식을 정의합니다.',
    info2: '형식 0: PAN과 XOR (가장 일반적). 형식 1: PAN 불필요 (랜덤 패딩).',
    info3: '형식 2-4: 다른 PAN 인코딩 및 랜덤 패딩 방식으로 보안 강화.',
    formatLabel: 'PIN 블록 형식:',
    encode: '인코딩',
    decode: '디코딩',
    panLabel: 'PAN:',
    panPlaceholder: '456789012345cccc',
    pinLabel: 'PIN:',
    pinPlaceholder: '123456',
    pinBlockLabel: 'PIN 블록:',
    pinBlockPlaceholder: '041226FFFFFFFF1234',
    paddingLabel: '패딩 문자:',
    paddingHint: '단일 16진수 (0-9, A-F). 기본값: F',
    encodeButton: '인코딩',
    decodeButton: '디코딩',
    resultPinBlock: 'PIN 블록 (16진수)',
    resultPin: '디코딩된 PIN',
    format: '형식',
    length: '길이',
    hexChars: '16진 문자',
    pinLength: 'PIN 길이',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidPan: 'PAN은 13-19자리 숫자여야 합니다',
    errorInvalidPinBlock: '잘못된 PIN 블록 길이',
    errorInvalidFormat: '잘못된 PIN 블록 형식',
    errorInvalidPinLength: '블록 내 PIN 길이가 잘못되었습니다',
    errorProcessing: '처리 실패, 입력을 확인하세요',
  },
  
  pinBlockAes: {
    title: 'AES PIN 블록 형식 4',
    infoTitle: 'AES PIN 블록 정보',
    info1: 'PIN 블록 형식 4는 128비트 블록 크기를 가진 AES 암호화 전용으로 설계되었습니다.',
    info2: '이전 형식과 달리 형식 4는 AES에 적합한 32개 16진수 문자 블록(16바이트)을 사용합니다.',
    info3: 'PIN 블록은 보안 강화를 위해 AES 암호화 전에 PAN 블록과 XOR됩니다.',
    encrypt: '암호화',
    decrypt: '복호화',
    keyLabel: '키:',
    keyPlaceholder: 'C1D0F8FB4958670DBA40AB1F3752EF0D',
    keyHint: 'AES-128 키: 32개 16진수 문자 (16바이트)',
    panLabel: 'PAN (카드 번호):',
    panPlaceholder: '4567890123456789',
    panHint: '13-19자리 숫자',
    pinLabel: 'PIN:',
    pinPlaceholder: '1234',
    pinHint: '4-12자리 숫자',
    encryptedBlockLabel: '암호화된 블록:',
    encryptedBlockPlaceholder: 'E14F478E9A8F7D5C1B2E3A4D5C6F7A8B',
    encryptedBlockHint: '32개 16진수 문자 (16바이트)',
    encryptButton: '암호화',
    decryptButton: '복호화',
    showIntermediateSteps: '중간 단계 표시',
    intermediateTitle: '중간 단계',
    clearPinBlock: '클리어 PIN 블록 (암호화 전)',
    panBlock: 'PAN 블록',
    xorResult: 'XOR 결과 (AES 입력)',
    encryptedResult: '암호화 결과 (AES 출력)',
    decryptedXor: '복호화된 XOR 결과',
    extractedPinBlock: '추출된 PIN 블록',
    errorInvalidKey: '키는 32개 16진수 문자여야 합니다 (AES-128)',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidPan: 'PAN은 13-19자리 숫자여야 합니다',
    errorInvalidBlock: '암호화된 블록은 32개 16진수 문자여야 합니다',
    errorProcessing: '처리 실패, 입력을 확인하세요',
  },
  
  pinOffset: {
    title: 'PIN Offset (IBM 3624 방식)',
    infoTitle: 'PIN Offset 정보',
    info1: 'IBM 3624 방식은 PDK와 10진화 테이블을 사용한 3DES 암호화로 PIN offset을 계산합니다.',
    info2: 'offset은 (고객 PIN - 자연 PIN) mod 10으로 계산됩니다.',
    info3: '검증 데이터는 유연한 PIN 검증을 위해 매개변수 또는 마스크 패턴을 사용하여 추출할 수 있습니다.',
    tabOffset: 'Offset',
    tabPin: 'PIN',
    pdkLabel: 'PDK:',
    pdkPlaceholder: '0123456789ABCDEFFEDCBA9876543210',
    panLabel: 'PAN:',
    panPlaceholder: '1234567899876543',
    pinLabel: 'PIN:',
    pinPlaceholder: '3196',
    offsetLabel: 'PIN offset:',
    offsetPlaceholder: '0000',
    decTabLabel: 'DecTab:',
    validationDataLabel: '검증 데이터',
    useParameters: '검증 데이터 매개변수 사용',
    useMask: '검증 데이터 마스크 사용',
    startLabel: '시작:',
    lengthLabel: '길이:',
    padLabel: '패딩:',
    pinLengthLabel: 'PIN 길이:',
    validationMaskLabel: '검증 데이터 마스크:',
    maskHint: '자연 PIN 자릿수에는 N 사용, 고정 값에는 0-9 사용',
    calculateOffset: 'Offset 계산',
    calculatePin: 'PIN 계산',
    offsetResult: 'PIN Offset',
    pinResult: '계산된 PIN',
    errorInvalidPdk: 'PDK는 32개 16진수 문자(16바이트)여야 합니다',
    errorInvalidPan: 'PAN은 12-19자리 숫자여야 합니다',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidOffset: 'PIN offset은 4-12자리 숫자여야 합니다',
    errorInvalidDecTab: 'DecTab은 16자리 숫자여야 합니다',
    errorInvalidMask: '검증 마스크는 숫자와 N만 포함해야 합니다',
    errorProcessing: '처리 실패, 입력을 확인하세요',
  },

  pinPvv: {
    title: 'PIN PVV 계산기',
    infoTitle: 'PIN PVV 정보',
    info1: 'PIN 검증 값(PVV)은 Visa의 PIN 검증 표준입니다. PIN 파생 키(PDK)를 사용하여 카드 번호(PAN)를 암호화하고, 10진화를 적용하여 4자리 검증 값을 계산합니다.',
    info2: 'PVV 탭은 PIN에서 PVV를 계산합니다. PIN 탭은 알려진 PVV에서 계산하여 PIN을 검증합니다.',
    info3: 'PVKI(PIN 검증 키 인덱스)는 검증에 사용할 암호화 결과 내 위치를 결정합니다.',
    tabPvv: 'PVV',
    tabPin: 'PIN',
    pdkLabel: 'PDK',
    panLabel: 'PAN',
    pinLabel: 'PIN',
    pvvLabel: 'PVV',
    pvkiLabel: 'PVKI',
    pdkHint: '32자리 16진수(16바이트) - PIN 파생 키',
    panHint: '12-19자리 숫자 - 주계좌번호',
    pinHint: '4-12자리 숫자 - 고객 PIN',
    pvvHint: '4자리 숫자 - PIN 검증 값',
    pvkiHint: '0-9 - PIN 검증 키 인덱스',
    calculatePvv: 'PVV 계산',
    calculatePin: 'PIN 계산',
    pvvResult: 'PVV',
    pinResult: 'PIN',
    encryptedPan: '암호화된 PAN',
    tsp: 'TSP(변환 선택)',
    pvvCalculated: 'PVV 계산 성공',
    pinCalculated: 'PIN 계산 성공',
    copied: '클립보드에 복사됨',
    errorInvalidPdk: 'PDK는 32자리 16진수여야 합니다',
    errorInvalidPan: 'PAN은 12-19자리 숫자여야 합니다',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidPvv: 'PVV는 4자리 숫자여야 합니다',
    errorProcessing: '계산 처리 오류',
  },

  visaCertificates: {
    title: 'VISA 인증서 검증 도구',
    infoTitle: 'VISA 인증서 정보',
    info1: '발급자 인증서 서명 요청을 검증하고 서명된 공개 키 데이터 확인',
    info2: 'VSDC CA V92, V94 또는 사용자 정의 CA 키 지원',
    description: 'EMV 결제 카드용 VISA 발급자 인증서 검증',
    tabRequest: '발급자 서명 요청 검증',
    tabSigned: '서명된 발급자 공개 키 데이터 검증',
    loadRequestFile: '발급자 인증서 요청 파일 로드 ...',
    loadSignedFile: '서명된 발급자 공개 키 데이터 파일 로드 ...',
    loadCaFile: 'CA 공개 키 파일 로드 ...',
    debug: '디버그',
    requestDataLabel: '발급자 인증서 요청 데이터:',
    signedDataLabel: '서명된 발급자 공개 키 데이터:',
    caKeyLabel: 'CA 공개 키:',
    requestDataPlaceholder: '16진수 데이터 입력(예: 22B0E1D3EC02...)',
    signedDataPlaceholder: '16진수 데이터 입력(예: 2410100000004455...)',
    caKeyPlaceholder: 'CA 공개 키가 자동으로 로드되거나 수동으로 입력',
    validate: '검증',
    validationSuccess: '검증 성공',
    validationFailed: '검증 실패',
    debugInfo: '디버그 정보:',
    lengthBytes: '길이: {0}바이트',
    fileLoadSuccess: '파일 로드 성공',
    fileLoadError: '파일 로드 실패',
    errorInvalidHex: '잘못된 16진수 데이터',
    errorTooShort: '잘못된 인증서 요청: 너무 짧음',
    errorDataTooShort: '잘못된 데이터: 너무 짧음',
    errorNoCA: 'CA 공개 키를 선택하거나 제공하세요',
    errorInvalidSignedHex: '잘못된 서명 데이터 16진수',
    errorValidationFailed: '검증 실패: {0}',
    aboutRequestTitle: '인증서 요청 정보',
    aboutRequestText1: '발급자 인증서 요청에는 CA가 서명해야 하는 공개 키 및 기타 인증서 정보가 포함됩니다.',
    aboutRequestText2: '이 도구는 인증서 요청이 CA로 전송되기 전에 구조와 형식을 검증합니다.',
    aboutSignedTitle: '서명된 공개 키 데이터 정보',
    aboutSignedText1: '서명된 발급자 공개 키 데이터에는 VISA CA가 서명한 인증서가 포함됩니다.',
    aboutSignedText2: '이 도구는 해당 CA 공개 키를 사용하여 서명을 검증합니다.',
    aboutCaTitle: 'CA 공개 키 정보',
    aboutCaText1: '사전 정의된 VISA CA 공개 키를 선택하거나 사용자 정의 키를 로드합니다.',
    aboutCaText2: 'CA 공개 키는 발급자 인증서의 서명을 검증하는 데 사용됩니다.',
  },
  
  tr31: {
    title: 'TR-31 키 블록',
    description: 'KBPK 보호로 TR-31/ANSI X9.143 키 블록 인코딩/디코딩',
    keyBlock: 'TR-31 키 블록',
    keyBlockPlaceholder: '예: D0144B1AX00E0000...',
    parseKeyBlock: '키 블록 구문 분석',
    header: '키 블록 헤더',
    version: '버전',
    keyLength: '길이',
    keyUsage: '키 용도',
    mode: '모드',
    keyVersion: '키 버전',
    exportability: '내보내기 가능성',
    characters: '문자',
    errorTooShort: 'TR-31 키 블록 길이가 부족합니다',
    errorParsing: '구문 분석에 실패했습니다. TR-31 형식을 확인하세요',
    exportable: '내보내기 가능',
    nonExportable: '내보내기 불가',
    sensitive: '민감함',
    keyBlockFormatHint: 'TR-31 키 블록 형식 (예: D0144B1AX00E0000...), 시스템이 자동으로 형식을 검증합니다',
  },

  tr31KeyBlock: {
    title: 'TR-31 키 블록',
    description: 'KBPK 보호로 TR-31/ANSI X9.143 키 블록 인코딩/디코딩',
    infoTitle: 'TR-31 키 블록 정보',
    infoContent1: 'TR-31 (ANSI X9.143)은 결제 시스템에서 안전한 암호화 키 교환을 위한 업계 표준입니다.',
    infoContent2: '키 블록에는 메타데이터(용도, 알고리즘, 내보내기 가능성)와 함께 암호화된 키 데이터가 포함됩니다.',
    infoContent3: 'KBPK(키 블록 보호 키)는 TDES 또는 AES 암호화로 래핑된 키를 보호합니다.',
    kbpkPlaceholder: 'KBPK 입력 - TDES용 32/48자리 16진수, AES용 32/48/64자리 16진수',
    keyBlockVersion: '키 블록 버전',
    tabEncode: '인코드',
    tabDecode: '디코드',
    plainKey: '평문 키',
    plainKeyPlaceholder: '16진수로 평문 키 입력 (16/24/32바이트)',
    header: '헤더',
    versionId: '버전 ID',
    keyUsage: '키 용도',
    algorithm: '알고리즘',
    modeOfUse: '사용 모드',
    keyVersionNum: '키 버전#',
    exportability: '내보내기 가능성',
    optKeyBlocks: '선택적 키 블록 수',
    reserved: '예약됨',
    optionalHeadersSection: '선택적 헤더',
    optionalHeaders: '선택적 헤더',
    encode: '인코드',
    decode: '디코드',
    keyBlock: '키 블록',
    keyBlockPlaceholder: 'TR-31 키 블록 데이터 입력 (예: D0144B1AX00E0000...)',
    encodeResult: '인코딩된 키 블록',
    decodeResult: '디코딩된 키 블록',
    headerInfo: '헤더',
    encodeSuccess: '키 블록 인코딩 성공',
    decodeSuccess: '키 블록 디코딩 성공',
    errorInvalidKey: '잘못된 평문 키 형식',
    errorInvalidKbpk: '잘못된 KBPK 형식(최소 32자 16진수 필요)',
    errorKeyBlockShort: '키 블록이 너무 짧습니다',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
  },
  
  placeholder: {
    title: '출시 예정',
    description: '이 도구는 개발 중입니다. 기대해 주세요!',
  },

  hash: {
    title: '해시 계산기',
    description: 'MD5, SHA-1, SHA-256, SHA-512 등 다양한 알고리즘으로 해시값 계산',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    hashType: '해시 유형',
    inputData: '입력 데이터',
    hashResult: '해시 결과',
    asciiPlaceholder: '텍스트 데이터 입력...',
    hexPlaceholder: '16진수 데이터 입력...',
    byteLength: '바이트',
    calculate: '해시 계산',
    algorithmInfo: '알고리즘 정보',
    outputLength: '출력 길이',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorOddHex: '16진수 입력은 짝수 개의 문자여야 합니다',
    errorCalculation: '해시 계산 실패',
    faqTitle: '해시 계산기 FAQ',
    faq1Question: '해시 함수란?',
    faq1Answer: '해시 함수는 임의 크기의 입력 데이터를 고정 크기의 출력(해시값)으로 변환하는 수학적 알고리즘입니다. 결정적이고 일방향입니다.',
    faq2Question: '어떤 해시 알고리즘을 사용해야 하나요?',
    faq2Answer: '보안 목적으로는 SHA-256 또는 SHA-512를 사용하세요. MD5와 SHA-1은 암호화 용도로는 안전하지 않지만 체크섬에는 사용할 수 있습니다.',
    usageTitle: '사용 방법',
    usage1: '입력 유형 선택 (ASCII 텍스트 또는 16진수)',
    usage2: '드롭다운에서 해시 알고리즘 선택',
    usage3: '입력 필드에 데이터 입력',
    usage4: '"해시 계산"을 클릭하여 해시값 생성',
    hashInfo: '해시 함수는 일방향 - 역변환 불가',
    inputLength: '입력',
  },

  encoding: {
    title: '문자 인코딩',
    description: '다양한 문자 인코딩과 형식 간 변환',
    encodingType: '인코딩',
    data: '데이터',
    convert: '변환',
    result: '변환 결과',
    conversionInfo: '변환 정보',
    ebcdicInfo: 'EBCDIC는 IBM 메인프레임에서 사용',
    atmInfo: 'ATM 형식은 공백으로 구분된 10진수 값을 사용 (0-255)',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorConversion: '변환 실패',
    placeholderBinary: '데이터 입력 (예: 57652C206174...)',
    placeholderHex: '16진수 데이터 입력',
    placeholderText: 'ASCII 텍스트 입력',
    placeholderAtm: '공백으로 구분된 10진수 값 입력 (예: 065 066 067)',
    faqTitle: '문자 인코딩 FAQ',
    faq1Question: '문자 인코딩이란?',
    faq1Answer: '문자 인코딩은 각 문자를 고유한 숫자 또는 바이트 시퀀스와 연결하여 컴퓨터가 텍스트를 저장하고 전송할 수 있게 하는 시스템입니다.',
    faq2Question: 'EBCDIC란?',
    faq2Answer: 'EBCDIC(확장 이진화 십진 교환 코드)는 주로 IBM 메인프레임 및 미드레인지 컴퓨터 시스템에서 사용되는 8비트 문자 인코딩입니다.',
    usageTitle: '사용 방법',
    usage1: '드롭다운에서 변환 유형 선택',
    usage2: '적절한 형식으로 데이터 입력',
    usage3: '"변환"을 클릭하여 결과 확인',
  },

  bcd: {
    title: '이진화 십진법 (BCD)',
    description: '십진수를 BCD로 인코딩하거나 BCD를 십진수로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputFormat: '입력 형식',
    binary: '이진수',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'BCD 정보',
    encodeInfo1: '각 십진 숫자 (0-9)는 4비트로 인코딩',
    encodeInfo2: '예: 25 → 0010 0101 (이진수) / 25 (16진수)',
    decodeInfo1: '각 4비트는 0-9여야 합니다 (A-F 불가)',
    decodeInfo2: '예: 0010 0101 → 25',
    encodeResult: 'BCD 인코딩 결과',
    decodeResult: '디코딩된 십진수',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidDecimal: '잘못된 입력: 0-9 숫자만 허용',
    errorInvalidBinary: '잘못된 이진수 입력 (0과 1만, 4의 배수 길이)',
    errorInvalidHex: '잘못된 16진수 입력',
    errorConversion: '변환 실패',
    placeholderEncode: '십진수 입력 (예: 12345)',
    placeholderBinary: 'BCD 이진수 입력 (예: 0010 0101)',
    placeholderHex: 'BCD 16진수 입력 (예: 25)',
    faqTitle: 'BCD FAQ',
    faq1Question: 'BCD란?',
    faq1Answer: '이진화 십진법 (BCD)는 각 십진 숫자를 고정 비트 수 (보통 4비트)로 표현하는 이진 인코딩입니다.',
    faq2Question: 'BCD를 왜 사용하나요?',
    faq2Answer: 'BCD는 십진 정밀도가 중요한 금융 및 상업 애플리케이션과 십진 숫자를 직접 표시해야 하는 시스템에서 사용됩니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 십진수를 BCD로 변환',
    usage2: '"디코딩"을 선택하여 BCD를 십진수로 변환',
    usage3: '디코딩 시 이진수 또는 16진수 입력 형식 선택',
  },

  checkDigits: {
    title: '체크 디지트',
    description: '다양한 알고리즘으로 체크 디지트 검증 또는 생성',
    operation: '작업',
    check: '검증',
    generate: '생성',
    hashType: '알고리즘',
    input: '입력',
    info: '알고리즘 정보',
    luhnInfo: 'Luhn 알고리즘 (MOD 10) - 신용카드, IMEI 등에 사용',
    amexInfo: 'Amex SE Number (MOD 9) - 숫자 합계를 9로 나눈 나머지',
    checkInfo: '체크 디지트를 포함한 완전한 번호 입력',
    generateInfo: '체크 디지트 없는 번호 입력',
    checkResult: '검증 결과',
    generateResult: '생성된 체크 디지트',
    validResult: '유효 - 체크 디지트가 올바릅니다',
    invalidResult: '무효 - 체크 디지트가 올바르지 않습니다',
    fullNumber: '전체 번호',
    errorNoInput: '번호를 입력하세요',
    errorCalculation: '계산 실패',
    placeholderCheck: '체크 디지트 포함 번호 입력 (예: 79927398713)',
    placeholderGenerate: '체크 디지트 없는 번호 입력 (예: 7992739871)',
    faqTitle: '체크 디지트 FAQ',
    faq1Question: '체크 디지트란?',
    faq1Answer: '체크 디지트는 특정 알고리즘으로 계산된 오류 검출용 숫자입니다.',
    faq2Question: 'Luhn 알고리즘이란?',
    faq2Answer: 'Luhn 알고리즘 (MOD 10)은 신용카드 번호, IMEI 번호 등의 검증에 사용되는 체크섬 공식입니다.',
    usageTitle: '사용 방법',
    usage1: '"검증"을 선택하여 체크 디지트 포함 번호 검증',
    usage2: '"생성"을 선택하여 체크 디지트 계산',
    usage3: '용도에 맞는 알고리즘 선택',
  },

  base64: {
    title: 'Base64',
    description: '데이터를 Base64로 인코딩하거나 Base64를 원래 형식으로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputEncoding: '입력 인코딩',
    outputEncoding: '출력 인코딩',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'Base64 정보',
    encodeInfo1: 'Base64는 바이너리 데이터를 ASCII 문자로 인코딩',
    encodeInfo2: '출력은 입력보다 약 33% 큼',
    decodeInfo1: 'Base64를 원래 데이터로 디코딩',
    decodeInfo2: '출력 형식 선택: ASCII 텍스트 또는 16진수',
    encodeResult: 'Base64 인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase64: '잘못된 Base64 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    placeholderAscii: '인코딩할 텍스트 입력',
    placeholderHex: '인코딩할 16진수 데이터 입력',
    placeholderBase64: '디코딩할 Base64 문자열 입력',
    faqTitle: 'Base64 FAQ',
    faq1Question: 'Base64란?',
    faq1Answer: 'Base64는 64개 문자를 사용하여 바이너리 데이터를 ASCII 문자열 형식으로 표현하는 바이너리-텍스트 인코딩 방식입니다.',
    faq2Question: '왜 Base64를 사용하나요?',
    faq2Answer: 'Base64는 JSON, XML, 이메일 첨부 파일과 같은 텍스트 기반 형식에 바이너리 데이터를 포함하는 데 일반적으로 사용됩니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 데이터를 Base64로 변환',
    usage2: '"디코딩"을 선택하여 Base64를 원래 데이터로 변환',
    usage3: '입력/출력 인코딩 선택: ASCII 또는 16진수',
  },

  base94: {
    title: 'Base94',
    description: '데이터를 Base94로 인코딩하거나 Base94를 원래 형식으로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputEncoding: '입력 인코딩',
    outputEncoding: '출력 인코딩',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'Base94 정보',
    encodeInfo1: 'ASCII 인쇄 가능 문자 사용 (0x20 공백부터 0x7E 물결표)',
    encodeInfo2: '5:4 비율 - 4바이트를 5문자로 인코딩 (25% 오버헤드)',
    decodeInfo1: 'Base94를 원래 데이터로 디코딩',
    decodeInfo2: '유효한 문자: 공백부터 ~ (ASCII 32-126)',
    encodeResult: 'Base94 인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase94: '잘못된 Base94 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    placeholderAscii: '인코딩할 텍스트 입력',
    placeholderHex: '인코딩할 16진수 데이터 입력',
    placeholderBase94: '디코딩할 Base94 문자열 입력',
    faqTitle: 'Base94 FAQ',
    faq1Question: 'Base94란?',
    faq1Answer: 'Base94는 94개의 인쇄 가능한 ASCII 문자 (!부터 ~)를 모두 사용하는 바이너리-텍스트 인코딩으로, Base64보다 효율적인 인코딩을 제공합니다.',
    faq2Question: '왜 Base64 대신 Base94를 사용하나요?',
    faq2Answer: 'Base94는 Base64 (약 33%)에 비해 오버헤드가 적어 (약 22%), 동일한 데이터의 인코딩 출력이 더 작습니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 데이터를 Base94로 변환',
    usage2: '"디코딩"을 선택하여 Base94를 원래 데이터로 변환',
    usage3: '입력/출력 인코딩 선택: ASCII 또는 16진수',
  },

  messageParser: {
    title: '메시지 파서',
    description: 'ATM 및 금융 거래 메시지 파싱',
    parseMode: '파싱 모드',
    hexData: '16진수 데이터',
    info: '파싱 모드 정보',
    ndcDesc: 'NCR NDC/DDC 프로토콜, ATM 통신용',
    wincorDesc: 'Wincor Nixdorf 프로토콜, ATM 통신용',
    iso8583Desc: 'ISO 8583:1987 금융 거래 메시지 형식',
    hexInputInfo: '입력은 유효한 16진수 데이터여야 합니다',
    placeholder: '파싱할 16진수 메시지 데이터 입력...',
    parsedResult: '파싱 결과',
    fields: '필드',
    fieldName: '필드',
    length: '길이',
    value: '값',
    errorNoInput: '16진수 데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorParseFailed: '메시지 파싱 실패',
    faqTitle: '메시지 파서 FAQ',
    faq1Question: 'ATM NDC란?',
    faq1Answer: 'NDC(NCR Direct Connect)는 NCR ATM이 호스트 시스템과 통신하는 데 사용하는 통신 프로토콜입니다.',
    faq2Question: 'ISO 8583이란?',
    faq2Answer: 'ISO 8583은 카드 결제 거래에 사용되는 금융 거래 카드 발신 메시지의 국제 표준입니다.',
    usageTitle: '사용 방법',
    usage1: '적절한 파싱 모드 선택 (ATM_NDC, ATM_WINCOR 또는 ISO_8583_1987)',
    usage2: '입력 필드에 16진수 메시지 데이터 입력',
    usage3: '파싱을 클릭하여 파싱된 필드와 값 보기',
  },

  rsaDer: {
    title: 'RSA DER 공개키',
    description: 'DER ASN.1 형식으로 RSA 공개키 인코딩/디코딩',
    info: 'RSA DER 정보',
    encode: '인코딩',
    decode: '디코딩',
    modulus: '모듈러스',
    modulusEncoding: '모듈러스 인코딩',
    exponent: '지수',
    exponentEncoding: '지수 인코딩',
    modulusNegative: '모듈러스 음수 (부호 없는 인코딩)',
    outputEncoding: '출력 인코딩',
    inputEncoding: '입력 인코딩',
    derInput: 'DER/PEM 입력',
    modulusPlaceholder: '모듈러스 입력 (16진수 또는 base64)',
    exponentPlaceholder: '지수 입력 (예: 65537의 경우 010001)',
    derInputPlaceholder: 'DER (16진수/base64) 또는 PEM 형식 공개키 입력',
    encodeInfo: 'RSA 공개키 인코딩',
    encodeInfo1: 'RSA 모듈러스와 지수를 DER/PEM 형식으로 인코딩',
    encodeInfo2: '부호 있는 및 부호 없는 정수 인코딩 지원',
    decodeInfo: 'RSA 공개키 디코딩',
    decodeInfo1: 'DER/PEM 형식을 디코딩하여 모듈러스와 지수 추출',
    decodeInfo2: '16진수, base64, PEM 입력 형식 지원',
    encodeResult: '인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoModulus: '모듈러스를 입력하세요',
    errorNoExponent: '지수를 입력하세요',
    errorNoInput: 'DER 데이터를 입력하세요',
    errorInvalidModulusHex: '잘못된 모듈러스 16진수',
    errorInvalidModulusBase64: '잘못된 모듈러스 base64',
    errorInvalidExponentHex: '잘못된 지수 16진수',
    errorInvalidExponentBase64: '잘못된 지수 base64',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase64: '잘못된 base64 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    faqTitle: 'RSA DER 공개키 FAQ',
    faq1Question: 'DER 인코딩이란?',
    faq1Answer: 'DER(Distinguished Encoding Rules)은 ASN.1 데이터 구조를 인코딩하는 바이너리 형식으로, 암호화 키와 인증서에 일반적으로 사용됩니다.',
    faq2Question: 'PEM 형식이란?',
    faq2Answer: 'PEM은 헤더와 푸터 라인이 있는 DER의 Base64 인코딩 버전으로, 텍스트 형식으로 쉽게 복사하여 붙여넣을 수 있습니다.',
    usageTitle: '사용 방법',
    usage1: '인코딩: 모듈러스와 지수를 입력하여 DER/PEM 인코딩된 공개키 생성',
    usage2: '디코딩: DER 또는 PEM 형식 공개키를 입력하여 모듈러스와 지수 추출',
    usage3: '16진수 및 base64 입출력 형식 지원',
  },

  uuid: {
    title: 'UUID 생성기',
    description: '범용 고유 식별자 (UUID) 생성',
    variant: '버전',
    count: '수량',
    info: 'UUID 정보',
    infoFormat: '형식: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36자)',
    v1Desc: '타임스탬프와 랜덤 노드를 사용하는 시간 기반 UUID',
    v4Desc: '랜덤 UUID - 가장 일반적',
    v3Desc: 'MD5 해시를 사용하는 이름 기반 UUID',
    v5Desc: 'SHA-1 해시를 사용하는 이름 기반 UUID',
    generatedUUIDs: '생성된 UUID',
    copyAll: '모두 복사',
    errorInvalidCount: '수량은 1에서 100 사이여야 합니다',
    errorGenerate: '생성 실패',
    withoutHyphen: '"-" 제외',
    maxCount: '최대 100개',
    faqTitle: 'UUID FAQ',
    faq1Question: 'UUID란?',
    faq1Answer: 'UUID(범용 고유 식별자)는 시간과 공간 모두에서 고유한 128비트 식별자로, 분산 시스템에서 일반적으로 사용됩니다.',
    faq2Question: '어떤 UUID 버전을 사용해야 하나요?',
    faq2Answer: '버전 4(랜덤)가 가장 일반적입니다. 버전 1은 시간 기반이고, 버전 3과 5는 각각 MD5와 SHA-1을 사용하는 이름 기반입니다.',
    usageTitle: '사용 방법',
    usage1: 'UUID 버전 선택',
    usage2: '생성할 UUID 수 입력 (1-100)',
    usage3: '생성을 클릭하여 UUID 생성',
  },

  cipher: {
    title: 'AES 암호화/복호화',
    description: 'AES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    aesInfo: 'AES 정보',
    keyLengthInfo: '키 길이는 선택한 알고리즘과 일치해야 합니다',
    ivInfo: 'IV(초기화 벡터)는 16바이트여야 합니다',
    paddingInfo: 'PKCS7 패딩 사용',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB/KCV 모드에서는 IV가 필요하지 않습니다',
    kcvInfo: 'KCV: 0을 암호화하고 처음 6개의 16진수 문자를 가져옴',
    calculateKcv: 'KCV 계산',
    noPaddingInfo: '패딩 없음 - 데이터 길이는 16바이트의 배수여야 합니다',
    errorDataLength: '데이터 길이는 16바이트의 배수여야 합니다',
    kcvNoDataNeeded: 'KCV 계산에는 데이터 입력이 필요하지 않습니다',
    kcvDataHint: 'KCV는 0을 사용하여 계산되므로 데이터 입력이 필요하지 않습니다',
    errorKcvCalculation: 'KCV 계산 실패',
    kcvResult: 'KCV 결과',
  },

  des: {
    title: 'DES / 3DES 암호화/복호화',
    description: 'DES 또는 3DES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    padding: '패딩',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    desInfo: 'DES/3DES 정보',
    keyLengthInfoDes: 'DES에는 8바이트(64비트) 키가 필요합니다',
    keyLengthInfo3Des: '3DES에는 16 또는 24바이트 키가 필요합니다',
    ivInfo: 'IV(초기화 벡터)는 8바이트여야 합니다',
    blockSizeInfo: '블록 크기는 8바이트입니다',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLengthDes: 'DES 키 길이는 8바이트여야 합니다',
    errorKeyLength3Des: '3DES 키 길이는 16 또는 24바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorDataLength: '패딩 없음 사용 시 데이터 길이는 8바이트의 배수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB 모드에서는 IV가 필요하지 않습니다',
    paddingNone: '패딩 없음',
    paddingZeros: '0x00으로 채움',
    paddingSpaces: '공백 0x20으로 채움',
    paddingANSIX923: '마지막 바이트는 패딩 길이, 나머지는 0x00으로 채움',
    paddingISO10126: '마지막 바이트는 패딩 길이, 나머지는 랜덤 바이트로 채움',
    paddingPKCS5: '각 패딩 바이트 값은 패딩 길이와 같음',
    paddingPKCS7: 'PKCS#5와 동일',
    paddingISO7816: '0x80을 추가한 후 0x00으로 채움',
    paddingRijndael: 'Zero 패딩과 동일',
    paddingISO9797M1: '0x00으로 블록 크기까지 채움',
    paddingISO9797M2: 'ISO 7816-4와 동일',
    mode8BitNote: '참고: 8비트 모드는 한 번에 1바이트를 처리합니다',
    mode64BitNote: '64비트 모드는 한 번에 전체 블록(8바이트)을 처리합니다',
  },

  rsa: {
    title: 'RSA 암호화/복호화',
    description: 'RSA 비대칭 암호화, 복호화, 서명 및 검증',
    rsaInfo: 'RSA 정보',
    rsaInfo1: 'RSA는 비대칭 암호화 알고리즘입니다',
    rsaInfo2: '키 크기: 1024, 2048, 4096비트 (2048 이상 권장)',
    rsaInfo3: 'PKCS#1 v1.5 및 OAEP 패딩 지원',
    tabKeys: '키',
    tabEncrypt: '암호화',
    tabDecrypt: '복호화',
    tabSign: '서명',
    tabVerify: '검증',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA 모듈러스 (16진수)',
    privateExpPlaceholder: 'RSA 개인 지수 (16진수)',
    keyLength: '키 길이',
    generateKeys: '키 생성',
    importKeys: '키 가져오기',
    clearKeys: '지우기',
    keyGenerated: '키 쌍이 성공적으로 생성되었습니다',
    keysCleared: '키가 지워졌습니다',
    keyImported: '공개 키가 성공적으로 가져왔습니다',
    privateKeyImportNote: '개인 키 가져오기에는 전체 CRT 매개변수가 필요합니다. 전체 기능을 사용하려면 "키 생성"을 사용하세요.',
    padding: '패딩',
    hashAlgorithm: '해시 알고리즘',
    data: '데이터',
    dataToEncrypt: '암호화할 데이터',
    dataPlaceholderAscii: '텍스트 데이터 입력',
    encodingMethod: '인코딩 방법',
    private: '개인',
    public: '공개',
    inputDataFormat: '입력 데이터 형식',
    hexadecimal: '16진수',
    paddingMethod: '패딩 방법',
    noPadding: '패딩 없음',
    errorDataRequired: '데이터가 필요합니다',
    privateEncryptNote: '참고: 암호화 데모에 공개 키 사용',
    dataToSign: '서명할 데이터',
    dataToVerify: '검증할 데이터',
    ciphertextToDecrypt: '복호화할 암호문',
    signatureToVerify: '서명',
    dataPlaceholder: '16진수 데이터 입력',
    ciphertextPlaceholder: '암호화된 16진수 데이터 입력',
    signaturePlaceholder: '16진수 서명 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    sign: '서명',
    verify: '검증',
    encryptedResult: '암호화 결과',
    encryptionFinished: '데이터 암호화 작업 완료',
    decryptionFinished: '데이터 복호화 작업 완료',
    decodingMethod: '디코딩 방법',
    copyResult: '결과 복사',
    result: '결과',
    decryptedResult: '복호화 결과',
    signatureResult: '서명',
    signatureValid: '✓ 서명이 유효합니다',
    signatureInvalid: '✗ 서명이 유효하지 않습니다',
    encryptInfo: 'RSA 암호화',
    encryptDesc: '공개 키로 데이터 암호화',
    decryptInfo: 'RSA 복호화',
    decryptDesc: '개인 키로 데이터 복호화',
    signInfo: 'RSA 서명',
    signDesc: '개인 키로 데이터 서명 (RSA-PSS)',
    verifyInfo: 'RSA 서명 검증',
    verifyDesc: '공개 키로 서명 검증 (RSA-PSS)',
    oaepDesc1: 'OAEP는 RSA 암호화에 사용되는 패딩 체계입니다',
    oaepDesc2: 'PKCS#1 v1.5 패딩보다 더 안전합니다',
    oaepDesc3: '선택된 암호문 공격을 방지합니다',
    oaepDesc4: '새로운 애플리케이션에 권장됩니다',
    oaepStructure: 'OAEP 구조',
    maxDataSize: '최대 데이터 크기',
    errorKeyGen: '키 생성 실패',
    errorKeyImport: '키 가져오기 실패',
    errorInvalidModulus: '유효하지 않은 모듈러스',
    errorInvalidPublicExp: '유효하지 않은 공개 지수',
    errorNoPublicKey: '먼저 공개 키를 생성하거나 가져오세요',
    errorNoPrivateKey: '먼저 키 쌍을 생성하세요 (개인 키 필요)',
    errorInvalidData: '유효하지 않은 데이터 (16진수여야 함)',
    errorInvalidCiphertext: '유효하지 않은 암호문 (16진수여야 함)',
    errorInvalidSignature: '유효하지 않은 서명 (16진수여야 함)',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorSign: '서명 실패',
    errorVerify: '검증 실패',
  },

  ecc: {
    title: 'ECC (ECDSA)',
    description: '타원 곡선 암호학 - 디지털 서명 알고리즘',
    infoTitle: 'ECC/ECDSA 정보',
    infoContent1: '타원 곡선 암호학은 더 작은 키 크기로 강력한 보안 제공',
    infoContent2: '디지털 서명을 위한 P-256, P-384, P-521 곡선 지원',
    infoContent3: 'ECDSA 서명으로 데이터의 진위성과 무결성 검증 가능',
  },

  sslCert: {
    title: 'SSL 인증서 (X509)',
    description: 'RSA 키 생성, CSR 생성, 자체 서명 인증서 및 X.509 인증서 분석',
    infoTitle: 'X.509 인증서 정보',
    info1: 'X.509는 공개 키 인증서의 표준 형식입니다',
    info2: 'TLS/SSL, 이메일 서명, 코드 서명에 사용됩니다',
    info3: 'CSR(인증서 서명 요청)은 CA에 인증서를 요청하는 데 사용됩니다',
    tabKeys: '키',
    tabCSRs: 'CSR',
    tabReadCSR: 'CSR 읽기',
    tabSelfSigned: '자체 서명 인증서',
    tabReadCert: '인증서 읽기',
    publicExponent: '공개 지수(e)',
    keyLength: '키 길이',
    passPhrase: '암호 문구',
    passPhrasePlaceholder: '개인 키를 암호화할 암호 문구 입력',
    generateKeys: '키 생성',
    privateKey: '개인 키',
    keyGenerated: '키 쌍 생성 성공',
    generating: 'RSA 키 쌍 생성 중...',
    privateKeyPlaceholder: '암호화된 PEM 개인 키 붙여넣기',
    version: '버전',
    country: '국가명',
    state: '시/도',
    locality: '시/군/구',
    organization: '조직',
    unit: '부서',
    commonName: '일반 이름',
    email: '이메일 주소',
    generateCSR: 'CSR 생성',
    generatedCSR: '생성된 CSR',
    csrGenerated: '인증서 서명 요청이 생성되었습니다',
    inputPK: '입력된 개인 키',
    certificateSigningRequest: '인증서 서명 요청',
    generatingCSR: 'CSR 생성 중...',
    inputCSR: 'CSR 입력',
    csrPlaceholder: 'PEM 형식 CSR 붙여넣기 (-----BEGIN CERTIFICATE REQUEST-----)',
    parseCSR: 'CSR 분석',
    parsedCSRInfo: '분석된 CSR 정보',
    csrParsed: 'CSR 분석 성공',
    csrRead: '인증서 서명 요청 읽기',
    pemData: 'PEM 데이터',
    publicKey: '공개 키',
    validityBefore: '유효 기간 시작',
    validityAfter: '유효 기간 종료',
    days: '일',
    serialNumber: '일련 번호',
    generateCert: '인증서 생성',
    generatedCert: '생성된 인증서',
    certGenerated: '인증서가 생성되었습니다',
    generatingCert: '인증서 생성 중...',
    certificate: '인증서',
    inputCert: '인증서 입력',
    certPlaceholder: 'PEM 형식 인증서 붙여넣기 (-----BEGIN CERTIFICATE-----)',
    parseCert: '인증서 분석',
    parsedCertInfo: '분석된 인증서 정보',
    certParsed: '인증서 분석 성공',
    validFrom: '유효 기간 시작',
    validTo: '유효 기간 종료',
    issuer: '발급자',
    subject: '주체',
    extensions: '확장',
    errorPassPhraseRequired: '암호 문구를 입력하세요',
    errorPrivateKeyRequired: '개인 키를 입력하세요',
    errorCommonNameRequired: '일반 이름을 입력하세요',
    errorInvalidPrivateKey: '개인 키 또는 암호 문구가 잘못되었습니다',
    errorCSRRequired: 'CSR을 입력하세요',
    errorCertRequired: '인증서를 입력하세요',
    errorKeyGen: '키 생성 실패',
    errorCSRGen: 'CSR 생성 실패',
    errorCSRParse: 'CSR 분석 실패',
    errorCertGen: '인증서 생성 실패',
    errorCertParse: '인증서 분석 실패',
  },

  keyshareGenerator: {
    title: '키쉐어 생성기',
    description: '키를 입력하여 여러 쉐어로 분할, KCV 검증 지원',
    infoTitle: '키쉐어 생성기 정보',
    infoContent: 'XOR 연산을 사용하여 암호화 키를 여러 쉐어로 분할합니다.',
    infoContent2: '각 쉐어는 키 세리머니에서 다른 관리자에게 배포할 수 있습니다.',
    mode: '모드',
    insecure: 'Insecure',
    secure: 'Secure',
    parity: '패리티',
    ignore: '무시',
    forceOdd: '홀수 패리티 강제',
    combinedKey: '결합된 키',
    threePartKey: '3파트 키',
    twoPartKey: '2파트 키',
    parityAdjusted: '패리티 조정됨',
    setPinFirst: '먼저 4자리 PIN을 설정하세요',
    keyRevealed: '키 쉐어가 공개되었습니다',
    wrongPin: 'PIN이 올바르지 않습니다',
    enterPin: 'PIN 입력',
    enterPinToReveal: '키 쉐어를 보려면 4자리 PIN을 입력하세요',
    unlock: '잠금 해제',
    regenerate: '재생성',
  },

  futurexKeys: {
    title: 'Futurex 키 암호화/복호화',
    description: 'Futurex HSM 키 변형 방식으로 키 암호화/복호화',
    infoTitle: 'Futurex 키 정보',
    infoContent1: 'Futurex HSM 변형으로 키 암호화/복호화.',
    infoContent2: '모디파이어 (0-F)로 MFK에서 다른 변형 생성.',
    infoContent3: 'MFK (Master File Key)는 기본 암호화 키.',
    tabEncrypt: '키 암호화/복호화',
    tabLookup: '키 조회',
    key: '키',
    modifier: '모디파이어',
    modifierHint: '키 변형 선택기 (0-F)',
    mfk: 'MFK (Master File Key)',
    customMfk: '사용자 정의 MFK...',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptedKey: '암호화된 키',
    decryptedKey: '복호화된 키',
    encryptedKeyInput: '암호화된 키',
    lookup: '모든 모디파이어 조회',
    lookupResults: '조회 결과',
    encryptSuccess: '키 암호화 성공',
    decryptSuccess: '키 복호화 성공',
    errorInvalidKey: '잘못된 키 형식',
    errorKeyLength: '키는 16, 24, 32바이트여야 합니다',
    errorInvalidMfk: '잘못된 MFK 형식(32자 이상의 16진수 필요)',
    errorEncrypt: '암호화 실패',
    errorDecrypt: '복호화 실패',
    errorLookup: '조회 실패',
    noResults: '유효한 복호화를 찾을 수 없습니다',
    encryptResult: '키 암호화 결과',
    decryptResult: '키 복호화 결과',
    plainKey: '평문 키',
    encryptedKeyLabel: '암호화된 키',
    parityDetected: '패리티 감지',
    mfkLabel: 'MFK',
    keyModifier: '키 모디파이어',
    decodedKey: '복호화된 키',
    kcvLabel: 'KCV',
    checkKcv: 'KCV 확인?',
    type: '유형',
    typeAny: '모두',
    typeFuturex: 'Futurex',
    typeIbm: 'IBM',
    typeAtalla: 'Atalla',
    typeVisa: 'VISA',
    parityLabel: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
    keyPlaceholder: '조회할 암호화된 키 입력',
    kcvPlaceholder: '일치할 KCV 입력(6자 16진수)',
    errorInvalidKcv: '잘못된 KCV 형식(6자 이상의 16진수 필요)',
  },

  atallaKeys: {
    title: 'Atalla 키 (AKB)',
    description: 'Atalla HSM AKB 형식으로 키 암호화/복호화',
    infoTitle: 'Atalla 키 정보',
    infoContent1: 'Atalla Key Block (AKB) 형식으로 키 암호화/복호화.',
    infoContent2: 'AKB 헤더(8자)로 키 변형 정의.',
    infoContent3: 'MFK (Master File Key)는 기본 암호화 키.',
    tabEncrypt: '키 암호화',
    tabDecode: 'AKB 디코드',
    key: '키',
    akbHeader: 'AKB 헤더',
    akbHeaderHint: 'Atalla Key Block 헤더(8자)',
    mfkKey: 'MFK 키',
    mfkPlaceholder: 'MFK 입력(48자 16진수)',
    keyPlaceholder: '16진수 키 입력(16/24/32바이트)',
    encrypt: '암호화',
    decode: '디코드',
    akb: 'AKB',
    akbPlaceholder: 'AKB 입력(헤더,암호화데이터)',
    checkKcv: 'KCV 확인?',
    kcvS: 'KCV (S)',
    kcvPlaceholder: '예상 KCV 입력',
    parity: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
    encryptSuccess: '키 암호화 성공',
    decodeSuccess: 'AKB 디코드 성공',
    errorInvalidKey: '잘못된 키 형식',
    errorKeyLength: '키는 16, 24, 32바이트여야 합니다',
    errorHeaderLength: 'AKB 헤더는 8자여야 합니다',
    errorInvalidMfk: 'MFK는 48자 이상의 16진수여야 합니다',
    errorInvalidAkb: '잘못된 AKB 형식(헤더,데이터 필요)',
    errorInvalidAkbData: 'AKB의 암호화 데이터가 잘못됨',
    errorInvalidKcv: '잘못된 KCV 형식',
    errorEncrypt: '암호화 실패',
    errorDecode: '디코드 실패',
    kcvMismatch: 'KCV가 일치하지 않습니다',
    macMismatch: 'MAC 검증 실패',
    parityMismatch: '패리티가 일치하지 않습니다',
    decodeFailed: 'AKB 디코드 실패',
    encryptResult: '암호화 결과',
    decodeResult: '디코드 결과',
    plainKey: '평문 키',
    encryptedAkb: '암호화된 AKB',
    kcv: 'KCV',
    header: '헤더',
    decodedKey: '복호화된 키',
    parityDetected: '패리티',
  },

  safenetKeys: {
    title: 'SafeNet 키 암호화/복호화',
    description: 'SafeNet HSM 키 변형 방식으로 키 암호화/복호화',
    infoTitle: 'SafeNet 키 정보',
    infoContent1: 'SafeNet HSM 방식으로 키 암호화/복호화.',
    infoContent2: '키 형식으로 암호화 유형(ECB/CBC) 정의.',
    infoContent3: '변형으로 키 용도(DPK, PPK, MPK 등) 결정.',
    tabEncrypt: '키 암호화/복호화',
    tabLookup: '키 조회',
    key: '키',
    keyFormat: '키 형식',
    variant: '변형',
    kmKey: 'KM 키',
    kmKeyPlaceholder: 'KM 키 입력(32자 16진수)',
    keyPlaceholder: '16진수 키 입력',
    lookupKeyPlaceholder: '조회할 암호화된 키 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    lookup: '조회',
    encryptSuccess: '키 암호화 성공',
    decryptSuccess: '키 복호화 성공',
    decryptFailed: '복호화 실패',
    errorInvalidKey: '잘못된 키 형식',
    errorInvalidKmKey: 'KM 키는 16바이트 이상이어야 합니다',
    errorInvalidKcv: '잘못된 KCV 형식',
    errorEncrypt: '암호화 실패',
    errorDecrypt: '복호화 실패',
    errorLookup: '조회 실패',
    noResults: '일치하는 키를 찾을 수 없습니다',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    plainKey: '평문 키',
    encryptedKeyLabel: '암호화된 키',
    decodedKey: '복호화된 키',
    kcvLabel: 'KCV',
    parityDetected: '패리티',
    checkKcv: 'KCV 확인?',
    kcv: 'KCV',
    kcvPlaceholder: '예상 KCV 입력',
    parity: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
  },

  thalesKeys: {
    title: 'Thales 키 암호화/복호화',
    description: 'Thales HSM LMK 키 변형 방식으로 키 암호화/복호화',
    infoTitle: 'Thales 키 정보',
    infoContent1: 'Thales HSM LMK 방식으로 키 암호화/복호화.',
    infoContent2: '키 스킴으로 키 길이와 암호화 유형 정의.',
    infoContent3: '변형으로 LMK에 적용할 XOR 마스크 결정.',
    tabEncrypt: '키 암호화/복호화',
    tabLookup: '키 조회',
    key: '키',
    keyScheme: '키 스킴',
    lmkSize: 'LMK 크기',
    double: '더블',
    triple: '트리플',
    lmkPair: 'LMK 쌍',
    lmkKey: 'LMK 키',
    variant: '변형',
    keyPlaceholder: '16진수 키 입력',
    lookupKeyPlaceholder: '조회할 암호화된 키 입력(스킴 접두사 유무)',
    encrypt: '암호화',
    decrypt: '복호화',
    lookup: '조회',
    encryptSuccess: '키 암호화 성공',
    decryptSuccess: '키 복호화 성공',
    decryptFailed: '복호화 실패',
    errorInvalidKey: '잘못된 키 형식',
    errorInvalidLmkKey: '잘못된 LMK 키',
    errorInvalidKcv: '잘못된 KCV 형식',
    errorEncrypt: '암호화 실패',
    errorDecrypt: '복호화 실패',
    errorLookup: '조회 실패',
    noResults: '일치하는 키를 찾을 수 없습니다',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    plainKey: '평문 키',
    encryptedKeyLabel: '암호화된 키',
    decodedKey: '복호화된 키',
    kcvLabel: 'KCV',
    parityDetected: '패리티',
    checkKcv: 'KCV 확인?',
    kcv: 'KCV',
    kcvPlaceholder: '예상 KCV 입력',
    parity: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
  },

  thalesKeyBlock: {
    title: 'Thales 키 블록',
    description: 'Thales 전용 키 블록 인코딩/디코딩',
    infoTitle: 'Thales 키 블록 정보',
    infoContent1: 'Thales 전용 키 블록 인코딩/디코딩.',
    infoContent2: 'TR-31과 유사하지만 Thales 특정 형식.',
    infoContent3: 'KBPK(키 블록 보호 키)로 암호화.',
    tabEncode: '인코드',
    tabDecode: '디코드',
    plainKey: '평문 키',
    versionId: '버전 ID',
    keyUsage: '키 용도',
    algorithm: '알고리즘',
    modeOfUse: '사용 모드',
    keyVersionNum: '키 버전#',
    exportability: '내보내기 가능성',
    optKeyBlocks: '선택적 키 블록 수',
    lmkId: 'LMK ID',
    optionalHeaders: '선택적 헤더',
    encode: '인코드',
    decode: '디코드',
    keyBlock: '키 블록',
    encodeResult: '인코드 결과',
    decodeResult: '디코드 결과',
  },

  fpe: {
    title: '형식 보존 암호화',
    description: '형식과 길이를 유지하면서 데이터 암호화 (NIST SP 800-38G)',
    radix: '기수',
    encryptionType: '암호화 유형',
    keyInput: '키 입력',
    useTweak: 'Tweak 사용?',
    fpeInfo: 'FPE 정보',
    formatPreserving: '형식 보존: 출력이 입력과 동일한 형식과 길이를 가짐',
    radixInfo: '현재 기수가 데이터의 유효한 문자 집합을 정의합니다',
    tweakInfo: 'Tweak은 암호화에 추가 입력을 제공합니다 (IV와 유사)',
    minLength: '최소 데이터 길이: 2자',
    dataPlaceholder: '유효한 기수 문자로 데이터 입력',
    tweakPlaceholderFF1: 'Tweak을 16진수로 입력 (임의의 길이)',
    tweakPlaceholderFF3: '16자리 16진수 문자 (8바이트)',
    resultLength: '길이',
    characters: '문자',
    algorithm: '알고리즘',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorDataTooShort: '데이터는 최소 2자여야 합니다',
    errorInvalidDataForRadix: '데이터에 기수 {radix}의 유효하지 않은 문자가 포함되어 있습니다',
    errorInvalidTweakHex: 'Tweak은 유효한 16진수여야 합니다',
    errorTweakLength: '{algorithm}의 Tweak 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    algorithmNotImplemented: '이 알고리즘은 아직 완전히 구현되지 않았습니다',
  },

  // SEO Content
  seo: {
    home: {
      title: 'HSM Kit - 무료 온라인 암호화 및 키 관리 도구',
      description: '무료 온라인 암호화 도구. Thales, Futurex, Atalla, SafeNet HSM 키 작업 지원. KCV 계산, TR-31 키 블록 인코딩, 안전한 키 생성, AES/DES/RSA 암호화. 모든 계산은 브라우저에서 실행. 100% 무료, 등록 불필요.',
      keywords: 'HSM 도구, Thales HSM, Futurex HSM, Atalla AKB, SafeNet 키, 암호화 도구키트, 키 관리, KCV 계산기, TR-31 키 블록, AES 암호화, DES 암호화, RSA 암호화, PIN 블록, 키 생성기, 암호화 도구, 결제 보안, LMK 암호화, 온라인 암호화 도구, 무료 암호화 도구',
      faqTitle: '자주 묻는 질문',
      usageTitle: 'HSM Kit 소개',
      faqs: [
        { question: 'HSM Kit은 무료인가요?', answer: '네, HSM Kit은 25개 이상의 암호화 도구를 100% 무료로 제공합니다. 등록, 로그인, 결제 불필요. 모든 기능을 즉시 사용할 수 있습니다.' },
        { question: '데이터는 안전한가요?', answer: '물론입니다. 모든 작업은 JavaScript를 사용하여 브라우저에서 완전히 실행됩니다. 키, PIN, 민감한 데이터가 장치를 벗어나지 않습니다. 서버 통신 제로.' },
        { question: '어떤 HSM 벤더가 지원되나요?', answer: 'HSM Kit은 Thales(LMK 암호화, 키 블록), Futurex(MFK 변형), Atalla(AKB 형식), SafeNet(KM 키 변형) HSM 키 작업을 지원합니다.' },
        { question: '어떤 암호화 알고리즘이 지원되나요?', answer: 'AES(128/192/256비트), DES, 3DES, RSA, ECC/ECDSA, 형식 보존 암호화(FPE FF1/FF3-1)를 지원합니다. 다양한 모드와 패딩 옵션 제공.' },
        { question: '결제 보안에 사용할 수 있나요?', answer: '물론입니다! PIN 블록 생성(ISO 9564), TR-31/Thales 키 블록, KCV 계산, 키 쉐어 생성, HSM 키 암호화/복호화 도구를 포함한 전문 도구를 제공합니다.' },
        { question: '어떤 인코딩 도구가 있나요?', answer: 'Base64, Base94, BCD, 문자 인코딩(ASCII/EBCDIC/Hex), ASN.1/DER 파싱, UUID 생성, 해시 계산(MD5/SHA/BLAKE2), 체크 디지트 검증.' },
      ],
      usage: [
        'HSM Kit은 보안 전문가, 개발자, 암호화 및 결제 시스템 작업자를 위해 설계된 25개 이상의 암호화 도구 모음입니다.',
        '모든 도구는 브라우저에서 완전히 작동합니다. 서버 통신 제로로 민감한 데이터, 키, PIN이 장치를 벗어나지 않습니다.',
        'Thales, Futurex, Atalla, SafeNet 키 작업, TR-31 키 블록, KCV 계산을 지원하는 전문 HSM 도구.',
        '암호화, 결제 보안 및 HSM 키 관리 분야의 테스트, 개발 및 교육 목적에 완벽합니다.',
      ],
    },
    ansiMac: {
      title: 'ANSI MAC 계산기 온라인 - X9.9 & X9.19 MAC 생성기 | HSM Kit',
      description: '무료 온라인 ANSI MAC 계산기로 X9.9(도매) 및 X9.19(소매) 알고리즘 지원. DES 및 3DES 암호화를 사용하여 금융 거래를 위한 메시지 인증 코드 생성.',
      keywords: 'ANSI MAC, X9.9 MAC, X9.19 MAC, 도매 MAC, 소매 MAC, 금융 MAC, 결제 MAC, DES MAC, 3DES MAC, CBC-MAC, 메시지 인증',
      faqTitle: 'ANSI MAC FAQ',
      usageTitle: 'ANSI MAC 계산기 사용 방법',
      faqs: [
        { question: 'ANSI X9.9란 무엇인가요?', answer: 'ANSI X9.9(도매 MAC)는 CBC(암호 블록 체인) 모드에서 DES 암호화를 사용하는 메시지 인증 코드 알고리즘입니다. 8바이트 블록으로 데이터를 처리하여 각 블록을 이전 암호화 출력과 XOR 연산합니다. 마지막 암호화 블록이 MAC이 됩니다. 도매 뱅킹 및 은행 간 금융 거래에서 메시지 무결성 검증을 위해 널리 사용됩니다.' },
        { question: 'ANSI X9.19란 무엇인가요?', answer: 'ANSI X9.19(소매 MAC)는 소매 결제 시스템을 위해 설계된 향상된 MAC 알고리즘입니다. 모든 데이터 블록에 대해 CBC 모드에서 단일 DES를 사용하지만 보안 강화를 위해 마지막 블록에 트리플 DES(3DES) 암호화를 적용합니다. 이 하이브리드 접근 방식은 소매 환경에서 X9.9 시스템과의 하위 호환성을 유지하면서 암호 분석 공격에 대한 더 강력한 보호를 제공합니다.' },
        { question: 'X9.9 대신 X9.19를 언제 사용해야 하나요?', answer: '3DES 최종 블록 암호화로 인해 더 높은 보안이 필요한 소매/소비자 거래(POS 단말기, ATM, 카드 결제)에는 X9.19를 사용하세요. 양 당사자가 보안 환경에서 운영하는 도매/기관 거래(은행 간 이체, 청산 시스템)에는 X9.9를 사용하세요. 더 강력한 암호화 보호로 인해 모든 새로운 구현에는 X9.19가 권장됩니다.' },
        { question: 'ANSI MAC의 키 요구 사항은 무엇인가요?', answer: 'X9.9의 경우: 단일 DES 키(64비트, 16진수 16자, 패리티 비트 포함 실질적으로 56비트). X9.19의 경우: 단일 DES 키(3DES에서 두 번 사용) 또는 최종 3DES 암호화를 위한 두 개의 별도 DES 키(K 및 K\'). 키는 적절한 패리티를 가져야 하며 암호학적으로 강력해야 합니다. 데이터는 처리 전에 8바이트 경계로 0으로 패딩됩니다.' },
        { question: 'MAC 절단은 어떻게 작동하나요?', answer: 'MAC 절단은 전송 효율성을 위해 8바이트(64비트) MAC 출력을 더 짧은 길이로 줄입니다. 일반적인 절단 값은 표준 보안의 경우 4바이트(32비트) 또는 향상된 보안의 경우 6바이트(48비트)입니다. 절단은 최종 MAC 블록의 왼쪽 N바이트를 사용합니다. 더 짧은 MAC은 보안을 감소시킨다는 점에 유의하세요 - 4바이트 MAC은 2^32개의 가능한 값을 제공하여 2^64개의 가능성을 가진 전체 8바이트 MAC보다 무차별 대입을 더 실행 가능하게 만듭니다.' }
      ],
      usage: [
        'MAC 알고리즘 선택: DES CBC-MAC을 사용하는 도매 뱅킹 거래에는 "ANSI MAC X9.9(도매 MAC)"를 선택하고, DES와 3DES 최종 블록 암호화를 사용하는 소매 결제 시스템에는 "ANSI MAC X9.19(소매 MAC)"를 선택하세요.',
        '기본 DES 키(K) 입력: 16진수 형식으로 주 암호화 키를 입력합니다. 단일 길이 DES 키의 경우 정확히 16진수 16자(패리티 포함 8바이트, 64비트) 또는 이중 길이 3DES 키의 경우 32진수 문자(16바이트)여야 합니다.',
        'X9.19의 경우 두 번째 키(K\') 입력: 3DES 최종 블록에 별도의 키를 사용하는 경우 두 번째 DES 키(16진수 16자)를 입력합니다. 최종 3DES 단계의 두 DES 작업에서 기본 키 K를 재사용하려면 비워 두세요.',
        '인증할 데이터 입력: 16진수 형식으로 메시지 또는 거래 데이터를 입력합니다. 데이터는 블록 암호 요구 사항을 충족하기 위해 자동으로 16진수 문자(8바이트)의 배수로 0으로 패딩됩니다.',
        '절단 길이 설정: 사용할 최종 MAC의 바이트 수(1-8바이트)를 지정합니다. 표준 값은 대부분의 금융 애플리케이션의 경우 4바이트(16진수 8자) 또는 최대 보안의 경우 8바이트(전체 16진수 16자)입니다.',
        '"Calculate MAC" 클릭: 도구는 선택한 알고리즘을 사용하여 데이터를 처리합니다. X9.9의 경우 DES CBC-MAC을 적용합니다. X9.19의 경우 모든 블록에 DES CBC를 적용한 다음 최종 블록에 3DES를 적용합니다.',
        '생성된 MAC 복사: 계산된 MAC은 지정된 절단 길이로 16진수 형식으로 표시됩니다. 복사 버튼을 사용하여 MAC을 거래 메시지 또는 검증 시스템으로 전송하세요. MAC 길이가 시스템 요구 사항과 일치하는지 확인하세요.'
      ],
    },
    as2805Mac: {
      title: 'AS2805.4.1 MAC 계산기 온라인 - 호주 EFTPOS 메시지 인증 코드 | HSM Kit',
      description: '호주 결제 시스템용 메시지 인증 코드 생성을 위한 무료 온라인 AS2805 MAC 계산기. AS2805.4.1 표준에 따른 메소드 1(DES CBC-MAC) 및 메소드 2(DES+3DES 최종 블록) 보안 수준 지원. EFTPOS 거래를 위한 K|KL 및 KR 키 사용. 호주 결제 보안을 위한 PCI DSS 준수.',
      keywords: 'AS2805 MAC 계산기, AS2805.4.1, EFTPOS MAC, 호주 결제 MAC, 메시지 인증 코드, DES CBC-MAC, 3DES MAC, EFTPOS 보안, K|KL 키, KR 키, 결제 보안',
      faqTitle: 'AS2805 MAC FAQ',
      usageTitle: 'AS2805 MAC 계산기 사용 방법',
      faqs: [
        { question: 'AS2805란 무엇인가요?', answer: 'AS2805.4.1은 EFTPOS 시스템의 메시지 인증을 위한 호주 표준입니다. ISO 9797-1 알고리즘 3을 기반으로 하지만 호주 결제 네트워크에 특화되어 있습니다. 이 표준은 두 가지 방법을 지원합니다: 메소드 1은 하위 호환성을 위해 DES CBC-MAC을 사용하고, 메소드 2는 보안 강화를 위해 DES와 3DES 최종 블록을 사용합니다.' },
        { question: '메소드 1과 메소드 2의 차이점은?', answer: '메소드 1은 모든 블록에 DES CBC-MAC을 사용합니다. 메소드 2는 대부분의 블록을 DES로 암호화하지만 최종 블록에는 3DES(KL과 KR을 사용한 encrypt-decrypt-encrypt)를 사용하여 중간자 공격을 방지합니다. 메소드 2는 더 나은 보안을 제공하며 PCI DSS 요구사항에 따른 새로운 구현에 권장됩니다.' },
        { question: 'AS2805 MAC에 필요한 키는?', answer: '메소드 1은 단일 DES 키 K|KL이 필요합니다. 메소드 2는 두 개의 키가 필요합니다: 3DES 작업을 위한 K|KL(왼쪽 키)과 KR(오른쪽 키). 두 키 모두 올바른 패리티를 가진 유효한 DES 키여야 하며 일반적으로 16개의 16진수 문자(8바이트)입니다.' },
        { question: 'AS2805는 ISO 9797-1과 어떻게 다른가요?', answer: 'AS2805는 ISO 9797-1 알고리즘 3을 기반으로 하지만 호주 EFTPOS 요구사항에 맞게 특별히 조정되었습니다. 호주 결제 네트워크에 맞춰져 있으며 현지 보안 정책을 통합합니다. 주요 차이점은 구현별 세부 사항, 절단 요구사항 및 규정 준수 표준에 있습니다.' },
        { question: '일반적인 AS2805 MAC 절단은?', answer: '호주 EFTPOS 시스템은 일반적으로 4바이트(8개의 16진수 문자) MAC 절단을 사용합니다. 이는 터미널 작업의 보안과 효율성을 균형있게 유지합니다. 전체 MAC은 8바이트이지만 4바이트로 절단하는 것이 AS2805.4.1 구현의 표준입니다.' },
      ],
      usage: [
        '레거시 시스템의 경우 메소드 1(DES CBC-MAC)을, 보안 강화 및 PCI DSS 준수를 위해 메소드 2(DES+3DES 최종 블록)를 선택합니다.',
        'K|KL 키를 입력합니다(8바이트에 대해 16개의 16진수 문자). 메소드 2의 경우 이것은 3DES 작업의 왼쪽 키로 사용됩니다. DES 키 패리티가 올바른지 확인하십시오.',
        '메소드 2의 경우 KR 키를 입력합니다(16개의 16진수 문자). 이 오른쪽 키는 최종 블록의 encrypt-decrypt-encrypt 시퀀스에서 KL과 함께 사용됩니다.',
        '메시지 데이터를 16진수 형식으로 입력합니다. 데이터는 ISO 9797-1 패딩 메소드 2(0x80 다음에 0x00s)에 따라 자동으로 8바이트의 배수로 패딩됩니다.',
        '절단 크기를 선택합니다(호주 EFTPOS의 경우 기본값 4바이트) 또는 최대 보안을 위해 전체 8바이트 MAC을 사용합니다.',
        '"MAC 계산"을 클릭합니다. 도구는 선택한 알고리즘으로 메시지를 처리하고 AS2805 준수 MAC을 생성합니다.',
        '결과 MAC은 EFTPOS 거래 무결성 검증, 네트워크 메시지 보안 및 호주 결제 시스템의 데이터 무결성 보장에 사용할 수 있습니다.',
      ],
    },
    iso9797Mac: {
      title: 'ISO/IEC 9797-1 MAC 계산기 온라인 - 메시지 인증 코드 생성기 | HSM Kit',
      description: '무료 온라인 ISO/IEC 9797-1 MAC 계산기로 전체 6개 알고리즘(1-6)과 여러 패딩 방법을 지원합니다. 금융 거래, 결제 시스템 및 보안 애플리케이션을 위한 메시지 인증 코드 생성. 클라이언트 측 도구 - 키가 장치를 떠나지 않습니다.',
      keywords: 'ISO 9797 MAC, ISO 9797-1, MAC 계산기, 메시지 인증 코드, DES MAC, 3DES MAC, CBC-MAC, 결제 MAC, 소매 MAC, 도매 MAC, 금융 MAC, ISO9797, 블록 암호 MAC, 암호화 MAC, 보안 MAC, 뱅킹 MAC, 알고리즘 1, 알고리즘 2, 알고리즘 3, 패딩 방법 1, 패딩 방법 2',
      faqTitle: 'ISO 9797-1 MAC FAQ',
      usageTitle: 'ISO 9797-1 MAC 계산기 사용 방법',
      faqs: [
        { question: 'ISO/IEC 9797-1이란 무엇인가요?', answer: 'ISO/IEC 9797-1은 DES 및 3DES와 같은 블록 암호를 사용하여 데이터 무결성 및 인증을 위한 여러 MAC(메시지 인증 코드) 알고리즘을 정의하는 국제 표준입니다. 금융 및 결제 시스템에서 메시지 인증에 널리 사용됩니다.' },
        { question: '어떤 MAC 알고리즘을 사용해야 하나요?', answer: '알고리즘 1(DES CBC-MAC)이 가장 간단합니다. 알고리즘 2는 이중 키를 사용하여 보안을 강화합니다. 알고리즘 3(소매 MAC)은 DES CBC와 최종 3DES 암호화로 가장 안전합니다. 보안 요구 사항, 시스템 호환성 및 산업 표준에 따라 선택하세요.' },
        { question: '패딩 방법은 무엇인가요?', answer: '방법 1은 0(0x00)으로 채우며 대부분의 경우에 적합합니다. 방법 2는 0x80 다음에 0(ISO 7816-4)를 사용하여 특정 공격에 대해 더 나은 보안을 제공합니다. 방법 3은 추가 무결성을 위해 데이터 길이를 포함합니다. 최대 보안을 위해 방법 2를 권장합니다.' },
        { question: '트런케이션 매개변수는 무엇인가요?', answer: '트런케이션은 최종 MAC 값의 몇 바이트(1-8)를 출력할지 지정합니다. 일반적인 값은 효율성을 위해 4바이트(8개 16진수 문자) 또는 완전한 보안을 위해 8바이트(16개 16진수 문자)입니다. 산업 표준에서 필요한 트런케이션 길이를 지정할 수 있습니다.' },
        { question: '몇 개의 키가 필요한가요?', answer: '알고리즘 1은 1개의 키(K)가 필요합니다. 알고리즘 2는 2개의 키(K, K2)가 필요합니다. 알고리즘 3은 3DES 작업을 위해 2개의 키(K, K\')가 필요합니다. 키는 16진수 형식으로 입력하며 일반적으로 16 또는 32자입니다.' },
      ],
      usage: [
        '드롭다운 메뉴에서 MAC 알고리즘(알고리즘 1-6)을 선택합니다.',
        '필요한 키를 16진수 형식으로 입력합니다(키당 16 또는 32개 16진수 문자).',
        '패딩 방법을 선택합니다: 방법 1(0), 방법 2(0x80 + 0) 또는 방법 3(길이 포함).',
        '데이터 필드에 16진수 형식으로 데이터를 입력합니다.',
        '출력 MAC 크기에 대한 트런케이션 길이(1-8바이트)를 설정합니다.',
        '\"MAC 계산\"을 클릭하여 메시지 인증 코드를 생성합니다.',
        '애플리케이션 또는 검증 프로세스에 사용하기 위해 결과 MAC을 복사합니다.',
      ],
    },
    as2805: {
      title: 'AS2805 결제 도구: 터미널 키 세트, PIN 블록, MAC, OWF | HSM Kit',
      description: '종합 AS2805 유틸리티: 터미널 키 세트 생성, PIN 블록 변환, ISO9797-1 M2 TDES-CBC MAC, OWF(HMAC-SHA256). 100% 클라이언트 측, 데이터가 장치를 떠나지 않습니다.',
      keywords: 'AS2805, AS2805.4.1, 터미널 키 세트, PIN 블록 변환, MAC, OWF, ISO9797-1 M2, TDES CBC-MAC, HMAC-SHA256, ZPK, TPK, KEK 플래그 1,2,3, KEK 키 스킴 B,C,H,F,G, LMK 키 스킴 0,T,U,X,Y,Z, KCV 타입 0,1,2, 결제 보안',
      faqTitle: 'AS2805 FAQ',
      usageTitle: '사용 방법',
      faqs: [
        { question: 'AS2805란 무엇인가요?', answer: 'AS2805는 호주에서 널리 사용되는 금융 메시지 및 보안 작업 표준입니다.' },
        { question: '계산은 클라이언트 측인가요?', answer: '네. 모든 작업은 브라우저에서 완전히 실행되며 서버로 전송되지 않습니다.' },
        { question: '지원하는 KEK 플래그 값은?', answer: '1, 2, 3.' },
        { question: '지원하는 KEK 키 스킴은?', answer: 'B, C, H, F, G.' },
        { question: '지원하는 LMK 키 스킴은?', answer: '0, T, U, X, Y, Z.' },
        { question: '지원하는 KCV 타입은?', answer: '0, 1, 2.' },
        { question: 'MAC 알고리즘은?', answer: 'ISO9797-1 패딩 방식 2 + TDES CBC-MAC(마지막 블록).' },
        { question: 'OWF 알고리즘은?', answer: 'HMAC-SHA256(32바이트 16진 출력).' },
      ],
      usage: [
        '터미널 키 세트: KEK 플래그(1/2/3) 선택.',
        'KEKr 키를 16진수로 입력; 길이 표시는 입력 상단에 표시.',
        'KEK 키 스킴(B/C/H/F/G)과 LMK 키 스킴(0/T/U/X/Y/Z) 선택.',
        'KCV 타입(0/1/2) 선택 후 "생성"을 클릭하여 KCV, ZPK, TPK 생성.',
        'PIN 블록 변환: 시스템 ZPK와 터미널 TPK(16진수)를 입력하고 실시간 길이 표시 확인.',
        'STAN과 거래 금액을 입력하고 입/출력 포맷 선택(예: 46 → 01).',
        '입력 PIN 블록(16개의 16진수)과 계좌번호(12–19자리)를 제공한 후 "변환" 클릭.',
        'MAC: 키(16/32/48 16진수)와 데이터(16진수)를 입력. ISO9797-1 M2 패딩 후 TDES CBC-MAC 계산.',
        'OWF: 키(16/32/48/64 16진수)와 데이터(16진수)를 입력. HMAC-SHA256 계산.',
        '결과 카드의 복사 버튼으로 빠르게 복사.',
      ],
    },
    tdesCbcMac: {
      title: 'TDES CBC-MAC 계산기 온라인 - 트리플 DES 메시지 인증 | HSM Kit',
      description: '무료 온라인 TDES CBC-MAC 계산기로 CBC 모드의 트리플 DES를 사용하여 메시지 인증 코드 생성. ISO 9797-1 패딩 방법으로 2키 및 3키 TDES 지원. 금융 거래, 결제 시스템 및 보안 통신을 위한 PCI DSS 준수 MAC 생성.',
      keywords: 'TDES CBC-MAC, 트리플 DES MAC, 3DES MAC, CBC-MAC, 메시지 인증, DES MAC, ISO 9797-1, 결제 MAC, 금융 MAC, 2키 TDES, 3키 TDES, CBC 모드',
      faqTitle: 'TDES CBC-MAC FAQ',
      usageTitle: 'TDES CBC-MAC 계산기 사용 방법',
      faqs: [
        { question: 'TDES CBC-MAC이란 무엇인가요?', answer: 'TDES CBC-MAC(트리플 데이터 암호화 표준 암호 블록 체인 메시지 인증 코드)은 CBC 모드의 트리플 DES 암호화를 사용하여 메시지의 무결성과 진위성을 검증하는 인증 태그를 생성하는 암호 알고리즘입니다. 8바이트 블록 단위로 데이터를 처리하며 각 블록을 이전 암호화 출력과 체인합니다. 최종 블록이 MAC 값이 되어 메시지의 모든 변조가 감지되도록 보장합니다.' },
        { question: '2키 TDES와 3키 TDES의 차이점은?', answer: '2키 TDES(유효 보안 112비트)는 16바이트(32개의 16진수 문자)를 사용하며 K1과 K2를 포함하고 암호화-복호화-암호화 시퀀스에서 K3=K1입니다. 3키 TDES(유효 보안 168비트)는 24바이트(48개의 16진수 문자)를 사용하며 세 개의 독립적인 키 K1, K2, K3를 포함합니다. 3키 TDES는 더 강력한 보안을 제공하며 고가치 거래와 PCI DSS 준수가 필요한 현대 결제 시스템에 권장됩니다.' },
        { question: 'ISO 9797-1 패딩 방법은 무엇인가요?', answer: 'ISO 9797-1은 두 가지 패딩 방법을 정의합니다: 방법 1은 8바이트의 배수로 채우기 위해 제로 바이트(0x00)를 사용합니다 - 간단하지만 원본 데이터가 제로로 끝나는 경우 취약합니다. 방법 2(권장)는 0x80 뒤에 제로 바이트를 추가하여 항상 패딩을 원본 데이터와 분리합니다. 방법 2는 명시적인 패딩 제거를 보장하고 MAC 검증 시스템에서 패딩 오라클 공격으로부터 보호합니다.' },
        { question: 'TDES CBC-MAC은 언제 사용해야 하나요?', answer: '트리플 DES 호환성이 필요한 레거시 금융 시스템, 결제 단말기 인증(POS, ATM), EMV 칩 카드 거래, 키 관리 MAC 생성 및 은행 네트워크의 보안 메시징에 사용합니다. AES 기반 MAC(예: CMAC)이 새 시스템에 권장되지만, 역호환성 요구 사항과 규제 수용으로 인해 TDES CBC-MAC은 기존 결제 인프라에서 여전히 널리 배포되고 있습니다.' },
        { question: 'TDES CBC-MAC의 일반적인 MAC 절단은?', answer: 'TDES CBC-MAC은 최종 암호화 블록에서 8바이트(16개의 16진수 문자) MAC을 생성합니다. 일반적인 절단 값은: 결제 시스템의 표준 보안을 위한 4바이트(8개의 16진수 문자), 향상된 보안을 위한 6바이트(12개의 16진수 문자) 또는 최대 보호를 위한 전체 8바이트(16개의 16진수 문자)입니다. 절단은 보안과 메시지 효율성의 균형을 맞춥니다 - 짧은 MAC은 대역폭을 줄이지만 무차별 공격에 대한 보안 비트가 적습니다.' },
      ],
      usage: [
        'TDES 키 유형 선택: 세 개의 독립적인 키 K1, K2, K3로 최대 보안을 위해 3키 TDES(48개의 16진수 문자, 24바이트)를 사용하거나 K3=K1인 레거시 시스템용 2키 TDES(32개의 16진수 문자, 16바이트)를 사용합니다. PCI DSS 준수 및 현대 결제 애플리케이션에는 3키 TDES가 권장됩니다.',
        'TDES 키를 16진수 형식으로 입력: 3키 TDES의 경우 K1||K2||K3 연결을 나타내는 정확히 48개의 16진수 문자를 입력합니다. 2키 TDES의 경우 K1||K2를 나타내는 32개의 16진수 문자를 입력합니다. 키가 올바른 패리티 비트를 가지고 있으며 암호학적으로 안전한 난수 생성기로 생성되었는지 확인하십시오.',
        '패딩 방법 선택: 레거시 시스템 호환성을 위해 ISO 9797-1 방법 1(제로 패딩) 또는 향상된 보안과 명시적 패딩을 위해 ISO 9797-1 방법 2(0x80 뒤에 제로)를 선택합니다. 패딩 관련 취약점을 방지하기 위해 모든 새로운 구현에는 방법 2가 권장됩니다.',
        '메시지 데이터를 16진수 형식으로 입력: 인증할 데이터를 16진수 문자로 입력합니다. MAC 계산 전에 선택한 ISO 9797-1 방법에 따라 데이터가 자동으로 16개의 16진수 문자(8바이트, DES 블록 크기)의 배수로 패딩됩니다.',
        'MAC 절단 길이 설정: 최종 8바이트 MAC에서 출력할 바이트 수(1-8바이트)를 지정합니다. 표준 결제 시스템은 4바이트를 사용하고, 더 높은 보안 요구 사항은 6바이트를 사용하거나 최대 인증 강도를 위해 8바이트(전체 MAC)를 사용합니다. 필요한 MAC 길이에 대해 시스템 사양을 확인하십시오.',
        '"MAC 계산"을 클릭: 도구는 제로 초기화 벡터(IV)를 사용하여 CBC 모드로 TDES로 패딩된 데이터를 암호화합니다. 각 8바이트 블록은 이전 암호화 블록과 XOR된 다음 TDES로 암호화됩니다. 최종 블록의 암호문이 MAC 값이 됩니다.',
        '생성된 MAC 복사: 계산된 MAC이 지정된 절단 길이로 16진수 형식으로 표시됩니다. 복사 버튼을 사용하여 MAC을 거래 메시지, 결제 요청, HSM 명령 또는 검증 시스템으로 전송합니다. 동일한 키, 패딩 및 절단으로 수신 측에서 MAC을 검증합니다.',
      ],
    },
    hmac: {
      title: 'HMAC 계산기 온라인 - 해시 기반 메시지 인증 | HSM Kit',
      description: '무료 온라인 HMAC 계산기로 SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-3, MD5, RIPEMD-160 등 다양한 해시 알고리즘 지원. API 보안, JWT 토큰, Webhook 검증 및 보안 통신을 위한 RFC 2104 준수 해시 기반 메시지 인증 코드 생성.',
      keywords: 'HMAC 계산기, HMAC-SHA256, HMAC-SHA512, HMAC-MD5, 해시 기반 MAC, 메시지 인증, RFC 2104, HMAC-SHA1, HMAC-SHA3, API 인증, JWT HMAC, Webhook 서명',
      faqTitle: 'HMAC FAQ',
      usageTitle: 'HMAC 계산기 사용 방법',
      faqs: [
        { question: 'HMAC이란 무엇인가요?', answer: 'HMAC(Hash-based Message Authentication Code, RFC 2104)은 암호학적 해시 함수와 비밀 키를 결합하여 메시지 인증 코드를 생성합니다. 데이터 무결성과 진위성 검증을 모두 제공합니다. HMAC은 중첩된 해시 연산을 통해 데이터를 처리합니다: HMAC(K, m) = H((K ⊕ opad) || H((K ⊕ ipad) || m)). 여기서 K는 키, m은 메시지, H는 해시 함수, opad/ipad는 패딩 상수입니다. 이 구조는 해시 함수에 약점이 있더라도 HMAC이 안전하게 유지되도록 보장합니다.' },
        { question: 'HMAC에는 어떤 해시 함수를 사용해야 하나요?', answer: '대부분의 애플리케이션에서는 128비트 보안 강도를 제공하는 SHA-256이 권장됩니다. 고가치 시스템에서는 256비트 보안을 위해 SHA-512를, 192비트 보안을 위해 SHA-384를 사용하십시오. SHA-3(Keccak)은 다른 내부 구조를 가진 최신 NIST 표준을 제공합니다. 해시 충돌 취약점으로 인해 새로운 보안 중요 애플리케이션에서는 MD5-HMAC 및 SHA-1-HMAC을 피하십시오. 다만 HMAC 구조 자체는 안전하게 유지됩니다. 레거시 시스템 호환성을 위해 HMAC이 단순 해싱보다 추가 보안을 제공하므로 SHA-1-HMAC은 여전히 허용될 수 있습니다.' },
        { question: '권장되는 HMAC 키 길이는?', answer: '최적의 보안을 위해 키 길이는 해시 출력 크기와 일치해야 합니다: SHA-256의 경우 32바이트(256비트), SHA-512의 경우 64바이트(512비트), SHA-1의 경우 20바이트(160비트). 해시 출력보다 짧은 키는 보안 강도를 감소시킵니다. 해시 블록 크기(SHA-256의 경우 64바이트, SHA-512의 경우 128바이트)보다 긴 키는 사용 전에 먼저 해시됩니다. HMAC 키 생성에는 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용하고, 비밀번호나 예측 가능한 값을 HMAC 키로 직접 사용하지 마십시오.' },
        { question: 'HMAC은 일반적으로 어디에 사용되나요?', answer: 'HMAC은 널리 배포되어 있습니다: API 인증(AWS 서명, OAuth 2.0, HMAC 기반 토큰), HS256/HS384/HS512 알고리즘을 사용하는 JWT(JSON Web Tokens), Webhook 서명 검증(GitHub, Stripe, PayPal), TLS/SSL(암호 스위트에서 레코드 무결성을 위한 HMAC), IPsec(인증 헤더 및 ESP), 챌린지-응답 프로토콜, 보안 파일 무결성 검증, 블록체인/암호화폐 거래 서명. HMAC은 비밀 키에 대한 지식이 필요하기 때문에 인증을 위해 단순 해싱보다 선호됩니다.' },
        { question: 'HMAC 출력을 절단할 수 있나요?', answer: '예, HMAC은 보안을 유지하면서 절단을 지원합니다. RFC 2104는 최소한 해시 출력 길이의 절반을 유지할 것을 권장합니다: SHA-256-HMAC의 최소 16바이트(128비트 보안), SHA-512-HMAC의 20바이트(160비트). 일반적인 절단에는 HMAC-SHA-256-128(16바이트), HMAC-SHA-512-256(32바이트)이 포함됩니다. 절단은 대역폭이 제한된 환경을 위해 MAC 크기를 줄이면서 위조 공격에 대한 인증 강도를 유지합니다. 보안 애플리케이션의 경우 80비트(10바이트) 이하로 절단하지 마십시오.' },
      ],
      usage: [
        '해시 알고리즘 선택: 표준 보안(128비트 강도)에는 SHA-256을, 높은 보안(256비트 강도)에는 SHA-512를, 최신 NIST 표준에는 SHA-3 변형을 선택하십시오. 새로운 보안 중요 시스템에서는 MD5 및 SHA-1을 피하십시오. SHA-224/SHA-384는 중간 보안 수준을 제공합니다.',
        '키 입력 형식 선택: 16진수 문자열로 표현된 이진 키(예: 키 관리 시스템의 암호화 키)에는 "16진수"를, 텍스트 기반 공유 비밀에는 "ASCII"를 선택하십시오. 16진수 형식은 결제 HSM, API 키 및 암호화 애플리케이션의 표준입니다.',
        'HMAC 키 입력: 선택한 형식으로 비밀 키를 입력하십시오. 16진수의 경우 필요한 바이트 수를 정확히 입력하십시오(32개의 16진수 문자 = SHA-256 키용 16바이트). 키는 CSPRNG를 사용하여 생성하고 안전하게 저장해야 합니다. 키를 하드코딩하거나 약한 비밀번호를 HMAC 키로 사용하지 마십시오.',
        '데이터 입력 형식 선택: 이진 메시지 데이터(결제 메시지, 이진 프로토콜)에는 "16진수"를, 텍스트 메시지(API 요청, Webhook 페이로드)에는 "ASCII"를 선택하십시오. HMAC 검증이 성공하려면 형식이 시스템이 데이터를 처리하는 방식과 일치해야 합니다.',
        '메시지 데이터 입력: 인증할 전체 메시지 또는 데이터를 입력하십시오. API 요청의 경우 일반적으로 특정 순서로 연결된 HTTP 메서드, URL 경로, 타임스탬프 및 요청 본문이 포함됩니다. HMAC 검증을 성공적으로 수행하려면 공백을 포함한 바이트 단위 정확한 일치를 보장하십시오.',
        '"HMAC 계산" 클릭: 도구는 RFC 2104 알고리즘을 사용하여 HMAC을 계산합니다: HMAC(K,m) = H((K ⊕ opad) || H((K ⊕ ipad) || m)). 키는 내부 및 외부 패딩 상수와 XOR되고 중첩된 해싱이 적용됩니다. 결과는 16진수 형식으로 표시됩니다.',
        'HMAC 복사 및 검증: 복사 버튼을 사용하여 HMAC을 애플리케이션, API 헤더(예: X-Signature, Authorization) 또는 검증 시스템으로 전송하십시오. 수신 측은 동일한 키와 알고리즘으로 HMAC을 재계산한 다음 바이트 단위로 비교합니다. 일치하는 HMAC은 메시지 무결성과 진위성을 확인합니다.',
      ],
    },
    cmac: {
      title: 'CMAC 계산기 온라인 - 암호 기반 메시지 인증 | HSM Kit',
      description: '무료 온라인 CMAC 계산기로 AES-CMAC 및 TDES-CMAC(3DES-CMAC) 지원. NIST SP 800-38B 준수 암호 기반 메시지 인증 코드를 생성하여 보안 통신, 데이터 무결성 검증 및 암호화 프로토콜에 대응.',
      keywords: 'CMAC 계산기, AES-CMAC, TDES-CMAC, 3DES-CMAC, 암호 기반 MAC, AES CMAC 96, NIST SP 800-38B, 메시지 인증, 블록 암호 MAC, AES-128 CMAC, AES-256 CMAC',
      faqTitle: 'CMAC FAQ',
      usageTitle: 'CMAC 계산기 사용 방법',
      faqs: [
        { question: 'CMAC이란 무엇인가요?', answer: 'CMAC(암호 기반 메시지 인증 코드, NIST SP 800-38B)은 블록 암호 기반 MAC 알고리즘으로 데이터 무결성 및 진위성 검증을 제공합니다. AES 또는 트리플 DES(TDES)와 같은 블록 암호를 정교한 하위 키 파생 체계에서 사용합니다. CMAC은 블록 단위로 데이터를 처리하여 암호화 키에서 두 개의 하위 키(K1 및 K2)를 생성한 다음 특정 패딩 규칙으로 암호 블록 체인을 적용합니다. 최종 블록은 최종 암호화 전에 K1(완전 블록용) 또는 K2(패딩 블록용)와 XOR됩니다. CMAC은 기본 블록 암호와 동등한 보안을 제공하며 현대 암호화 프로토콜에서 널리 사용됩니다.' },
        { question: 'CMAC에는 어떤 암호를 사용해야 하나요?', answer: '새로운 애플리케이션에는 AES-CMAC을 강력히 권장하며, 키 크기(AES-128, AES-192, AES-256)에 따라 128비트, 192비트 또는 256비트 보안을 제공합니다. AES는 AES-NI 가속이 있는 최신 하드웨어에서 우수한 성능을 제공합니다. TDES-CMAC(3DES-CMAC)은 112비트 유효 보안만 제공하고 상당히 느리지만 레거시 시스템 호환성이나 금융/결제 시스템의 규제 준수에 필요할 수 있습니다. 새로운 구현의 경우 최대 보안을 위해 AES-256-CMAC을 사용하십시오. AES-128-CMAC은 대부분의 애플리케이션에서 보안과 성능의 좋은 균형을 제공합니다.' },
        { question: 'CMAC 키 길이 요구 사항은?', answer: 'AES-CMAC은 세 가지 키 길이를 지원합니다: AES-128-CMAC의 경우 128비트(16바이트/32개의 16진수 문자), AES-192-CMAC의 경우 192비트(24바이트/48개의 16진수 문자), AES-256-CMAC의 경우 256비트(32바이트/64개의 16진수 문자). TDES-CMAC은 2키 TDES(K1=K3)의 경우 128비트(16바이트/32개의 16진수 문자) 또는 3키 TDES(모든 키 고유)의 경우 192비트(24바이트/48개의 16진수 문자)가 필요합니다. 키는 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용하여 생성해야 합니다. PBKDF2 또는 HKDF와 같은 적절한 키 파생 함수 없이 비밀번호에서 CMAC 키를 파생하지 마십시오. 하드웨어 보안 모듈(HSM) 또는 키 관리 시스템을 사용하여 키를 안전하게 저장하십시오.' },
        { question: 'CMAC은 일반적으로 어디에 사용되나요?', answer: 'CMAC은 현대 암호화 프로토콜에 널리 배포되어 있습니다: 레코드 인증을 위한 TLS 1.3 암호 스위트, VPN 보안을 위한 IPsec AH(인증 헤더) 및 ESP(캡슐화 보안 페이로드), 무선 네트워크 인증을 위한 IEEE 802.11i(WPA2/WPA3), 키 파생 및 확인을 위한 NIST 키 관리 표준(SP 800-108, SP 800-56C), 오프라인 인증을 위한 EMV 비접촉 결제 카드, 금융 메시지 인증을 위한 ISO/IEC 9797-1 알고리즘 5, 차량 내 네트워크 보호를 위한 자동차 보안(AUTOSAR SecOC), 장치 페어링을 위한 Bluetooth LE 보안 연결 및 보안 부팅 프로세스의 펌웨어 무결성 검증. CMAC은 길이 접두사 없이 가변 길이 메시지를 안전하게 처리하기 때문에 CBC-MAC보다 선호됩니다.' },
        { question: 'CMAC 출력을 절단할 수 있나요?', answer: '예, CMAC은 보안을 유지하면서 절단을 지원합니다. NIST SP 800-38B는 최소 MAC 길이를 권장합니다: AES-CMAC의 경우 일반 보안을 위해 최소 64비트(8바이트), 강력한 보안 애플리케이션을 위해 96비트(12바이트)(AES-CMAC-96은 IPsec 및 무선 프로토콜에서 일반적) 또는 최대 보안을 위해 전체 128비트(16바이트)를 사용합니다. TDES-CMAC의 경우 최소 64비트(8바이트)를 사용하며 80비트(10바이트) 또는 전체 64비트(8바이트) 출력이 일반적입니다. 절단은 보안 강도에 영향을 줍니다: 96비트 MAC은 2^96 충돌 저항성과 2^48 위조 저항성을 제공하고, 64비트 MAC은 2^64 충돌 저항성과 2^32 위조 저항성을 제공합니다(고가치 데이터에는 한계). 보안 중요 애플리케이션의 경우 64비트 미만으로 절단하지 마십시오. 절단은 전체 CMAC 출력의 가장 왼쪽(최상위) 바이트를 취하여 수행됩니다.' },
      ],
      usage: [
        '암호화 알고리즘 선택: 하드웨어 가속 지원으로 128비트에서 256비트 보안을 제공하는 최신 애플리케이션의 경우 "AES"를 선택하거나 레거시 시스템 호환성(112비트 유효 보안, 느린 성능)의 경우 "TDES"를 선택합니다. 새로운 구현에는 AES-CMAC이 권장됩니다.',
        '키 입력 형식 선택: 암호화 애플리케이션, HSM 및 키 관리 시스템의 표준인 16진수 문자열로 표현된 이진 키의 경우 "16진수"를 선택하거나 텍스트 기반 키(덜 일반적, 프로덕션에 권장되지 않음)의 경우 "ASCII"를 선택합니다. 16진수 형식은 정확한 이진 키 입력에 선호됩니다.',
        'CMAC 키 입력: 선택한 형식으로 비밀 키를 입력합니다. AES의 경우 키는 정확히 32개의 16진수 문자(128비트 AES-128), 48개의 16진수 문자(192비트 AES-192) 또는 64개의 16진수 문자(256비트 AES-256)여야 합니다. TDES의 경우 키는 32개의 16진수 문자(2키 TDES, K1=K3) 또는 48개의 16진수 문자(3키 TDES)여야 합니다. 키는 CSPRNG를 사용하여 생성하고 안전하게 저장해야 합니다. 키를 하드코딩하거나 약한 비밀번호를 CMAC 키로 직접 사용하지 마십시오.',
        '데이터 입력 형식 선택: 이진 메시지 데이터(프로토콜 메시지, 이진 파일, 결제 메시지)의 경우 "16진수"를 선택하거나 텍스트 메시지(API 요청, 문자열 데이터)의 경우 "ASCII"를 선택합니다. 형식은 CMAC 검증을 성공시키기 위해 시스템이 데이터를 처리하는 방식과 일치해야 합니다.',
        '메시지 데이터 입력: 인증할 전체 메시지 또는 데이터를 입력합니다. CMAC은 적절한 패딩(ISO/IEC 9797-1 패딩 방법 2)으로 가변 길이 메시지를 자동으로 처리합니다. 검증을 위해 원래 CMAC 계산에 사용된 것과 정확히 같은 순서로 헤더, 타임스탬프 또는 구조화된 데이터를 포함하여 메시지의 정확한 바이트 단위 일치를 보장하십시오.',
        '선택적 AES-CMAC-96 절단: AES만 해당, "AES CMAC 96" 옵션을 체크하여 출력을 전체 128비트 대신 96비트(12바이트)로 절단합니다. 이는 IPsec, IEEE 802.11i 및 대역폭이 제한된 기타 프로토콜에서 일반적으로 사용됩니다. 절단된 MAC은 오버헤드를 줄이면서 강력한 보안(2^96 충돌 저항성)을 제공합니다.',
        'CMAC 계산 및 검증: "CMAC 계산"을 클릭하여 하위 키 파생(K1/K2)을 포함한 NIST SP 800-38B 알고리즘을 사용하여 인증 코드를 생성합니다. 결과는 16진수 형식으로 표시됩니다. 복사 버튼을 사용하여 CMAC을 애플리케이션, API 헤더 또는 검증 시스템으로 전송합니다. 수신 측은 동일한 키와 알고리즘으로 CMAC을 재계산한 다음 바이트 단위로 비교합니다. 일치하는 CMAC은 메시지 무결성과 진위성을 확인합니다.',
      ],
    },
    retailMac: {
      title: 'Retail MAC 계산기 온라인 - DES & 3DES 메시지 인증 | HSM Kit',
      description: '무료 온라인 Retail MAC 계산기로 ISO 9797-1 방법 2 패딩을 사용하는 DES 및 트리플 DES 지원. 보안 강화를 위한 선택적 3DES 파이널라이제이션으로 결제 시스템용 안전한 MAC 생성.',
      keywords: 'Retail MAC, DES MAC, 3DES MAC, 트리플 DES, ISO 9797-1, 방법 2 패딩, 메시지 인증, 결제 MAC, 금융MAC, POS MAC, ATM 보안, 은행MAC, 3DES파이널라이제이션',
      faqTitle: 'Retail MAC FAQ',
      usageTitle: 'Retail MAC 계산기 사용 방법',
      faqs: [
        { question: 'Retail MAC이란 무엇인가요?', answer: 'Retail MAC은 DES 또는 트리플 DES 암호화와 ISO 9797-1 방법 2 패딩(0x80 뒤에 0)을 사용하는 결제 및 은행 시스템에서 널리 사용되는 MAC 알고리즘입니다. CBC 모드에서 데이터를 처리하고 마지막 블록을 MAC 값으로 추출합니다. Retail MAC은 레거시 시스템과의 호환성을 위해 DES 기반 보안이 필요한 POS 단말기, ATM 및 금융 메시지 인증에서 일반적으로 사용됩니다.' },
        { question: '3DES 파이널라이제이션을 사용해야 하나요?', answer: '예, 보안 강화를 위해 3DES 파이널라이제이션 사용을 강력히 권장합니다. 표준 DES Retail MAC은 전체에서 단일 DES를 사용하여 56비트 유효 보안을 제공합니다. 3DES 파이널라이제이션을 활성화하면 최종 MAC 블록이 트리플 DES로 암호화되어(112비트 유효 보안) 무차별 대입 공격에 대한 저항력이 크게 향상되면서 DES 기반 MAC을 기대하는 시스템과의 후방 호환성을 유지합니다.' },
        { question: 'DES와 3DES 알고리즘 선택의 차이점은 무엇인가요?', answer: '"DES" 알고리즘을 선택하면 전체 CBC-MAC 체인에서 단일 DES 암호화가 사용됩니다(선택적으로 마지막 블록에 3DES 파이널라이제이션). "3DES" 알고리즘을 선택하면 전체 CBC-MAC 체인에서 트리플 DES 암호화가 사용되어 전체 계산에서 더 강력한 보안을 제공합니다. 레거시 시스템 호환성을 위해 DES 모드를 사용하고 현대적인 보안 구현을 위해 3DES 모드를 사용하십시오.' },
        { question: 'Retail MAC은 어떤 패딩 방법을 사용하나요?', answer: 'Retail MAC은 ISO 9797-1 방법 2 패딩을 사용합니다: 0x80 바이트를 추가한 다음 0 바이트를 추가하여 다음 8바이트 블록 경계에 도달합니다. 예를 들어 데이터가 5바이트에서 끝나면 패딩은 0x80 00 00(3바이트)을 추가합니다. 데이터가 정확히 블록 정렬(8, 16, 24바이트...)인 경우 전체 패딩 블록(0x80 00 00 00 00 00 00 00)이 추가됩니다.' },
        { question: '지원되는 키 길이는 무엇인가요?', answer: 'DES 모드의 경우: 키 K는 정확히 16개의 16진수 문자(8바이트)여야 합니다. 3DES 파이널라이제이션이 활성화된 경우 키 K\'\'도 최종 암호화 단계를 위해 16개의 16진수 문자여야 합니다. 3DES 모드의 경우: 키 K는 16개의 16진수 문자(2키 TDES, K1=K3)이거나 키 K와 키 K\'(각 16개의 16진수 문자)를 모두 제공하여 모든 3개의 키가 고유한 완전한 3키 트리플 DES를 사용할 수 있습니다.' },
      ],
      usage: [
        '알고리즘 선택(DES 또는 3DES): 레거시 호환성을 위해 DES를 선택하여 전체 MAC 체인에서 단일 DES 암호화를 사용하거나 더 강력한 보안을 위해 3DES를 선택하여 전체 계산에서 트리플 DES 암호화를 사용합니다.',
        '파이널라이제이션 방법 선택: 표준 처리를 위해 "없음"을 선택하거나 DES 기반 MAC 구조를 유지하면서 보안을 강화하기 위해 최종 MAC 블록을 트리플 DES로 암호화하는 "3DES"를 선택합니다.',
        '키 K 입력: 기본 키를 16개의 16진수 문자(8바이트)로 입력합니다. 이 키는 CBC-MAC 체인의 DES 암호화에 사용됩니다. 키가 안전하게 생성되어 하드웨어 보안 모듈(HSM)에 저장되어 있는지 확인하십시오.',
        '키 K\' 입력(해당하는 경우): 3DES 파이널라이제이션 또는 3DES 알고리즘 모드를 사용하는 경우 두 번째 키를 16개의 16진수 문자로 제공합니다. 2키 TDES의 경우 키 K를 재사용하기 위해 비워둘 수 있습니다.',
        '메시지 데이터 입력: 인증할 데이터를 16진수 형식으로 입력합니다. 도구는 데이터를 8바이트 블록에 정렬하기 위해 ISO 9797-1 방법 2 패딩(0x80 뒤에 0)을 자동으로 적용합니다.',
        '절단 길이 설정: MAC 출력 길이를 바이트단위(1-8)로 지정합니다. 전체 MAC은 8바이트(64비트)입니다. 일반적인 값은 대역폭 제약 시스템의 경우 4바이트(32비트) 또는 최대 보안을 위해 8바이트(전체 MAC)입니다.',
        'MAC 계산 및 검증: "MAC 계산"을 클릭하여 선택한 알고리즘 및 파이널라이제이션으로 CBC 모드를 사용하여 인증 코드를 생성합니다. 결과는 16진수 형식으로 표시됩니다. MAC을 결제 시스템, API 헤더 또는 검증 모듈에 복사합니다.',
      ],
    },
    zka: {
      title: 'ZKA 독일 은행 표준 암호화 작업 | HSM Kit',
      description: '무료 온라인 ZKA 암호화 도구. 독일 은행 시스템을 위한 세션 키(SK) 파생, PIN 암호화/복호화, MAC 계산을 수행합니다. Triple DES를 사용하여 ZKA 표준을 구현하고 안전한 결제 처리를 제공합니다.',
      keywords: 'ZKA, 독일 은행, Zentraler Kreditausschuss, 세션 키 파생, SK 파생, PIN 암호화, MAC 계산, TDES, 3DES, 독일 결제 표준, 은행 암호화',
      faqTitle: 'ZKA 자주 묻는 질문',
      usageTitle: 'ZKA 도구 사용 방법',
      faqs: [
        { question: 'ZKA란 무엇인가요?', answer: 'ZKA(Zentraler Kreditausschuss, 중앙신용위원회)는 키 파생, PIN 처리, 메시지 인증을 포함한 안전한 결제 처리를 위한 암호화 작업을 정의하는 독일 은행 표준입니다. 독일 은행 인프라의 ATM 및 POS 거래에 널리 사용됩니다.' },
        { question: 'SK 파생이란 무엇인가요?', answer: '세션 키(SK) 파생은 마스터 키(MK), 명령 데이터(CM), 난수(Rnd)로부터 임시 세션 키를 생성하는 프로세스입니다. 이를 통해 각 거래가 고유한 키를 사용하고 키 재사용 공격을 방지하여 보안을 향상시킵니다.' },
        { question: 'ZKA PIN 암호화는 어떻게 작동하나요?', answer: 'ZKA는 파생된 세션 키(SK-pac)를 사용하여 PIN 블록을 암호화하기 위해 ECB 모드에서 Triple DES(3DES)를 사용합니다. PIN 블록은 8바이트(16진수 16문자)여야 합니다. 이는 결제 단말기와 호스트 시스템 간의 안전한 PIN 전송을 제공합니다.' },
        { question: 'ZKA는 어떤 MAC 알고리즘을 사용하나요?', answer: 'ZKA는 메시지 인증을 위해 Triple DES CBC-MAC을 사용합니다. MAC은 CBC 모드에서 데이터 블록을 처리하고 최종 암호화 블록을 MAC 값으로 취하여 계산됩니다. 이는 금융 거래에서 메시지의 무결성과 진위성을 보장합니다.' },
      ],
      usage: [
        'SK 파생 탭: 마스터 키(MK), 명령 데이터(CM), 난수(Rnd)를 16진수 형식으로 입력합니다(각 32개 16진수 문자). "SK 파생"을 클릭하여 세션 키를 생성합니다.',
        'PIN 탭: 세션 키(SK-pac)와 PIN 블록(8바이트, 16진수 16문자)을 입력합니다. "암호화"를 클릭하여 PIN 블록을 암호화하거나 "복호화"를 클릭하여 복호화합니다.',
        'MAC 탭: MAC 키(32개 16진수 문자)와 16진수 형식의 데이터를 입력합니다. "MAC 계산"을 클릭하여 메시지 인증 코드를 생성합니다.',
        '모든 입력은 16진수 형식이어야 합니다. 키는 16바이트(32개 16진수 문자)이고, PIN 블록은 8바이트(16개 16진수 문자)입니다.',
      ],
    },
    asn1: {
      title: 'ASN.1 파서 온라인 - 무료 DER/BER 구조 디코더 | HSM Kit',
      description: '무료 온라인 ASN.1 파서 및 디코더. ASN.1 DER/BER 구조 파싱, X.509 인증서 디코딩, PKCS 형식 분석. 16진수, Base64, PEM 입력 지원 및 RFC 정의 매칭. 100% 클라이언트 측 처리.',
      keywords: 'ASN.1 파서, DER 디코더, BER 디코더, X.509 인증서 파서, PKCS 디코더, ASN1 온라인 도구, 인증서 분석기, PEM 파서, ASN.1 디코더, 인증서 파서, PKCS 파서',
      faqTitle: 'ASN.1 파서 FAQ',
      usageTitle: 'ASN.1 파서 사용 방법',
      faqs: [
        { question: 'ASN.1이란 무엇인가요?', answer: 'ASN.1(Abstract Syntax Notation One)은 직렬화 및 역직렬화 가능한 데이터 구조를 정의하기 위한 표준 인터페이스 설명 언어입니다. 암호화, 통신, 네트워크 프로토콜에서 널리 사용됩니다.' },
        { question: '이 파서는 어떤 형식을 지원하나요?', answer: '이 파서는 DER(Distinguished Encoding Rules) 및 BER(Basic Encoding Rules)로 인코딩된 ASN.1 구조를 지원합니다. 16진수, Base64 또는 PEM 형식으로 데이터를 입력할 수 있습니다.' },
        { question: 'X.509 인증서를 파싱할 수 있나요?', answer: '네, 이 도구는 X.509 인증서, CSR, PKCS#7/8/12 구조 및 ASN.1 인코딩을 사용하는 기타 인증서 형식을 파싱할 수 있습니다.' },
        { question: '16진수 덤프 기능이란 무엇인가요?', answer: '16진수 덤프 기능은 파싱된 트리 뷰 옆에 ASN.1 구조의 원시 바이트를 표시하여 바이너리 인코딩의 이해를 돕습니다.' },
      ],
      usage: [
        'ASN.1 인코딩 데이터를 16진수, Base64 또는 PEM 형식으로 입력 필드에 붙여넣습니다.',
        '"파싱"을 클릭하여 구조를 디코딩하고 계층적 트리 표현을 봅니다.',
        '"16진수 덤프 포함"을 활성화하면 파싱된 구조 옆에 원시 바이트를 볼 수 있습니다.',
        '"정의 포함"을 사용하여 X.509, PKCS 등 알려진 RFC 정의와 구조를 매칭합니다.',
      ],
    },
    aes: {
      title: 'AES 암호화/복호화 온라인 - 무료 AES 계산기 | HSM Kit',
      description: '무료 온라인 AES 암호화 및 복호화 도구. ECB, CBC, CFB, OFB, CTR 모드로 AES-128, AES-192, AES-256 지원. KCV 계산, 브라우저에서 안전하게 16진수 또는 텍스트 데이터 암호화/복호화. 100% 클라이언트 측 처리, 데이터는 서버로 전송되지 않습니다.',
      keywords: 'AES 암호화, AES 복호화, AES-128, AES-192, AES-256, AES 계산기, AES 온라인 도구, AES ECB, AES CBC, AES KCV, 고급 암호화 표준, 대칭 암호',
      faqTitle: 'AES 암호화 FAQ',
      usageTitle: 'AES 암호화 도구 사용 방법',
      faqs: [
        { question: 'AES 암호화란 무엇인가요?', answer: 'AES(Advanced Encryption Standard)는 전 세계 표준이 된 대칭 블록 암호입니다. 128, 192 또는 256비트 키를 사용하여 128비트 블록 단위로 데이터를 암호화합니다.' },
        { question: '어떤 AES 모드를 사용해야 하나요?', answer: 'CBC 모드는 대부분의 응용 프로그램에서 일반적으로 권장됩니다. ECB 모드는 한 블록보다 큰 데이터 암호화에는 패턴이 드러나므로 피해야 합니다. CTR 모드는 스트리밍 데이터에 적합합니다.' },
        { question: 'AES가 지원하는 키 크기는?', answer: 'AES는 세 가지 키 크기를 지원합니다: AES-128(16바이트), AES-192(24바이트), AES-256(32바이트). 키가 길수록 보안이 강화됩니다.' },
        { question: 'AES 암호화에서 IV란 무엇인가요?', answer: 'IV(초기화 벡터)는 CBC, CFB, OFB, CTR 등의 모드에서 사용되는 랜덤 값으로, 동일한 평문이 다른 암호문을 생성하도록 보장합니다. IV는 고유해야 하지만 비밀일 필요는 없습니다.' },
      ],
      usage: [
        'AES 키 크기(128, 192 또는 256비트)와 암호화 모드(ECB, CBC 등)를 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'ECB 이외의 모드에서는 IV(16바이트 16진수)를 제공합니다.',
        '암호화 또는 복호화할 데이터를 입력하고 해당 버튼을 클릭합니다.',
      ],
    },
    des: {
      title: 'DES/3DES 암호화 온라인 - 무료 트리플 DES 계산기 | HSM Kit',
      description: '무료 온라인 DES 및 트리플 DES(3DES) 암호화 및 복호화 도구. DES, 2키 3DES, 3키 3DES를 ECB/CBC 모드로 지원. PKCS5, ISO 7816 등 다양한 패딩 옵션. 100% 클라이언트 측 처리, 안전한 암호화.',
      keywords: 'DES 암호화, 3DES 암호화, 트리플 DES, DES 복호화, DES 계산기, 3DES 온라인 도구, TDES, DES ECB, DES CBC, 데이터 암호화 표준, 결제 암호화',
      faqTitle: 'DES/3DES 암호화 FAQ',
      usageTitle: 'DES/3DES 도구 사용 방법',
      faqs: [
        { question: 'DES와 3DES의 차이점은?', answer: 'DES는 단일 56비트 키(패리티 포함 8바이트)를 사용하고, 3DES는 2개 또는 3개의 다른 키(16 또는 24바이트)로 DES 알고리즘을 3번 적용하여 훨씬 강력한 보안을 제공합니다.' },
        { question: 'DES는 아직 안전한가요?', answer: '단일 DES는 안전하지 않고 더 이상 사용되지 않습니다. 3DES는 레거시 시스템, 특히 결제 산업에서 여전히 사용되지만, 새 응용 프로그램에는 AES가 권장됩니다.' },
        { question: 'DES 키의 패리티 비트란?', answer: 'DES에서 키의 각 바이트에는 하나의 패리티 비트(최하위 비트)가 있어 유효 키 길이가 64비트에서 56비트가 됩니다. 이 도구는 패리티 비트를 자동으로 조정할 수 있습니다.' },
        { question: '어떤 패딩을 사용해야 하나요?', answer: 'PKCS5/PKCS7이 가장 일반적인 선택입니다. ISO 9797은 은행 응용 프로그램에서 자주 사용됩니다. 선택은 상대방이 기대하는 것과 일치해야 합니다.' },
      ],
      usage: [
        'DES(8바이트 키) 또는 3DES(16 또는 24바이트 키)를 선택합니다.',
        '암호화 모드(ECB 또는 CBC)와 패딩 방법을 선택합니다.',
        '키를 16진수 형식으로 입력합니다.',
        'CBC 모드의 경우 IV(8바이트 16진수)를 제공합니다.',
        '데이터를 입력하고 암호화 또는 복호화를 클릭합니다.',
      ],
    },
    rsa: {
      title: 'RSA 암호화 온라인 - 무료 RSA 계산기 및 키 생성기 | HSM Kit',
      description: '무료 온라인 RSA 암호화, 복호화, 서명, 검증 도구. RSA 키 쌍(1024-4096비트) 생성, 공개 키로 암호화, 개인 키로 서명. PKCS#1 및 OAEP 패딩 지원. 모든 작업은 클라이언트 측에서 처리.',
      keywords: 'RSA 암호화, RSA 복호화, RSA 키 생성기, RSA 계산기, RSA 온라인 도구, RSA 서명, RSA 검증, 공개 키 암호화, PKCS1, OAEP, 비대칭 암호화, 디지털 서명',
      faqTitle: 'RSA 암호화 FAQ',
      usageTitle: 'RSA 도구 사용 방법',
      faqs: [
        { question: 'RSA 암호화란 무엇인가요?', answer: 'RSA는 공개 키로 암호화하고 개인 키로 복호화하는 키 쌍을 사용하는 비대칭 암호화 알고리즘입니다. 안전한 데이터 전송과 디지털 서명에 널리 사용됩니다.' },
        { question: '어떤 키 크기를 사용해야 하나요?', answer: '현재 보안 표준에서 2048비트 키가 최소로 간주됩니다. 장기 보안을 위해 4096비트 키가 권장됩니다. 1024비트 키는 더 이상 권장되지 않습니다.' },
        { question: 'PKCS#1과 OAEP의 차이점은?', answer: 'PKCS#1 v1.5는 오래된 패딩 체계입니다. OAEP(최적 비대칭 암호화 패딩)는 더 안전하며 특정 공격을 방지하므로 새 응용 프로그램에 권장됩니다.' },
        { question: 'RSA 암호화의 최대 데이터 크기는?', answer: 'RSA는 키 크기에서 패딩 오버헤드를 뺀 크기보다 작은 데이터만 암호화할 수 있습니다. OAEP-SHA256이 있는 2048비트 키의 경우 최대 약 190바이트입니다. 더 큰 데이터에는 하이브리드 암호화를 사용하세요.' },
      ],
      usage: [
        '새 RSA 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '암호화: 평문을 입력하고 암호화 클릭(공개 키 사용).',
        '복호화: 암호문을 입력하고 복호화 클릭(개인 키 필요).',
        '서명: 데이터 해시를 입력하고 서명 클릭(개인 키 필요).',
        '검증: 데이터, 서명을 입력하고 검증 클릭(공개 키 사용).',
      ],
    },
    ecc: {
      title: 'ECC/ECDSA 온라인 도구 - 타원 곡선 암호화 | HSM Kit',
      description: '무료 온라인 ECC(타원 곡선 암호화) 도구. ECDSA 키 쌍 생성, secp256k1, P-256, P-384 곡선으로 데이터 서명 및 검증. 컴팩트한 키로 강력한 보안. 100% 브라우저 처리.',
      keywords: 'ECC 암호화, ECDSA, 타원 곡선, secp256k1, P-256, P-384, ECC 키 생성기, ECDSA 서명, ECDSA 검증, 비트코인 암호화, 이더리움 암호화, 디지털 서명',
      faqTitle: 'ECC/ECDSA FAQ',
      usageTitle: 'ECC/ECDSA 도구 사용 방법',
      faqs: [
        { question: 'ECC란 무엇인가요?', answer: '타원 곡선 암호화(ECC)는 타원 곡선의 대수적 구조에 기반한 공개 키 암호화 접근 방식입니다. RSA와 동등한 보안을 훨씬 작은 키 크기로 제공합니다.' },
        { question: 'secp256k1이란 무엇인가요?', answer: 'secp256k1은 비트코인과 이더리움이 디지털 서명에 사용하는 타원 곡선입니다. 보안과 성능의 좋은 균형을 제공합니다.' },
        { question: 'RSA 대신 ECC를 사용하는 이유는?', answer: 'ECC는 RSA와 동일한 보안 수준을 훨씬 작은 키로 제공합니다(256비트 ECC ≈ 3072비트 RSA). 이로 인해 더 빠른 작업과 저장/대역폭 요구 사항 감소가 가능합니다.' },
        { question: 'ECDSA란 무엇인가요?', answer: 'ECDSA(타원 곡선 디지털 서명 알고리즘)는 ECC에 기반한 서명 알고리즘입니다. 데이터의 진위를 검증할 수 있는 디지털 서명을 만드는 데 사용됩니다.' },
      ],
      usage: [
        '타원 곡선(secp256k1, P-256 또는 P-384)을 선택합니다.',
        '새 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '서명: 데이터(또는 해시)를 입력하고 서명 클릭.',
        '검증: 원본 데이터, 서명을 입력하고 검증 클릭.',
      ],
    },
    fpe: {
      title: '형식 보존 암호화(FPE) 온라인 - FF1/FF3-1 도구 | HSM Kit',
      description: 'NIST SP 800-38G를 구현한 무료 온라인 형식 보존 암호화 도구. 형식과 길이를 보존하면서 데이터 암호화. 신용카드 번호, 주민등록번호 등 구조화된 데이터의 토큰화에 이상적. PCI DSS 준수.',
      keywords: 'FPE, 형식 보존 암호화, FF1, FF3, FF3-1, NIST 800-38G, 토큰화, 신용카드 암호화, 데이터 마스킹, PCI DSS, 데이터 토큰화, 구조화된 데이터 암호화',
      faqTitle: '형식 보존 암호화 FAQ',
      usageTitle: 'FPE 도구 사용 방법',
      faqs: [
        { question: '형식 보존 암호화란 무엇인가요?', answer: 'FPE는 평문과 동일한 형식과 길이의 암호문을 생성하는 암호화 방법입니다. 예를 들어, 16자리 신용카드 번호는 다른 16자리 숫자로 암호화됩니다.' },
        { question: 'FF1과 FF3-1의 차이점은?', answer: '둘 다 NIST 승인 FPE 알고리즘입니다. FF1은 가변 길이 트윅을 지원하고, FF3-1은 고정 56비트 트윅을 사용합니다. FF3-1은 일반적으로 더 빠르지만 제약이 더 많습니다.' },
        { question: '토큰화란 무엇인가요?', answer: '토큰화는 민감한 데이터를 비민감 플레이스홀더(토큰)로 대체합니다. FPE는 토큰이 원래 데이터 형식을 유지하기 때문에 토큰화에 자주 사용됩니다.' },
        { question: 'FPE는 PCI DSS를 준수하나요?', answer: '네, NIST SP 800-38G 승인 알고리즘(FF1, FF3-1)을 사용한 FPE는 올바르게 구현된 경우 PCI DSS 준수에 허용됩니다.' },
      ],
      usage: [
        'FPE 알고리즘(FF1 또는 FF3-1)과 기수(숫자 기반)를 선택합니다.',
        'AES 키(16, 24 또는 32바이트 16진수)를 입력합니다.',
        '추가 보안을 위해 선택적으로 트윅 값을 제공합니다.',
        '평문 데이터를 입력하고 암호화를 클릭하여 형식 보존 암호문을 생성합니다.',
      ],
    },
    keyGenerator: {
      title: '보안 키 생성기 온라인 - 랜덤 AES/DES 키 생성기 | HSM Kit',
      description: '무료 온라인 암호화 키 생성기. AES, DES, 3DES 암호화를 위한 안전한 랜덤 키 생성. 키 결합(XOR), 패리티 조정, 키 검증 도구 포함. 암호학적으로 안전한 난수 생성.',
      keywords: '키 생성기, 랜덤 키, AES 키 생성기, DES 키 생성기, 3DES 키 생성기, 암호화 키, 보안 랜덤, 키 결합, XOR 키, 안전 키 생성, 랜덤 키 생성기',
      faqTitle: '키 생성기 FAQ',
      usageTitle: '키 생성기 사용 방법',
      faqs: [
        { question: '랜덤 키는 어떻게 생성되나요?', answer: '키는 Web Crypto API(crypto.getRandomValues)를 사용하여 생성됩니다. 이는 암호화 키에 적합한 암호학적으로 안전한 난수를 제공합니다.' },
        { question: '키 결합(XOR)이란 무엇인가요?', answer: '키 결합은 여러 키 구성 요소를 XOR하여 완전한 키를 형성할 수 있게 합니다. 이는 여러 관리인이 각각 구성 요소를 보유하는 의식에서 일반적으로 사용됩니다.' },
        { question: '패리티 비트란 무엇인가요?', answer: 'DES/3DES 키에서 각 바이트에는 오류 감지를 위한 패리티 비트가 있습니다. 이 도구는 DES 표준에서 요구하는 홀수 패리티로 패리티 비트를 자동 조정할 수 있습니다.' },
        { question: '지원되는 키 길이는?', answer: '생성기는 DES(8바이트/64비트), 2키 3DES(16바이트/128비트), 3키 3DES(24바이트/192비트) 및 AES-128/192/256을 지원합니다.' },
      ],
      usage: [
        '드롭다운에서 원하는 키 길이를 선택합니다.',
        '"생성"을 클릭하여 새 랜덤 키를 만듭니다.',
        '키 결합 탭을 사용하여 여러 구성 요소를 XOR합니다.',
        '패리티 탭을 사용하여 DES/3DES 키의 패리티 비트를 조정합니다.',
        '검증 탭을 사용하여 키가 올바른 형식과 패리티를 가지고 있는지 확인합니다.',
      ],
    },
    keyshare: {
      title: '키쉐어 생성기 온라인 - 키를 여러 컴포넌트로 분할 | HSM Kit',
      description: '무료 온라인 키쉐어 생성기. 암호화 키를 여러 컴포넌트로 분할. 키를 입력하면 2파트 또는 3파트 쉐어를 자동 생성, KCV 검증 지원. 키 세리머니 및 관리자 배포에 필수. 보안 모드에서 PIN 보호 지원.',
      keywords: '키쉐어 생성기, 키 분할, 키 컴포넌트, XOR 키, 키 세리머니, 키 관리자, KCV 검증, DES 키 쉐어, AES 키 쉐어, 키 배포, 키 분할, 키 보관',
      faqTitle: '키쉐어 생성기 FAQ',
      usageTitle: '키쉐어 생성기 사용 방법',
      faqs: [
        { question: '키 공유란 무엇인가요?', answer: '키 공유는 XOR 연산을 사용하여 암호화 키를 여러 컴포넌트(쉐어)로 분할합니다. 모든 컴포넌트를 XOR하면 원래 키가 재구성됩니다. 키 관리를 분산하여 보안을 강화합니다.' },
        { question: 'Insecure 모드와 Secure 모드의 차이점은?', answer: 'Insecure 모드에서는 생성된 키 쉐어가 직접 표시됩니다. Secure 모드에서는 쉐어가 숨겨지고 4자리 PIN으로 보호됩니다. 각 쉐어를 보려면 올바른 PIN을 입력해야 합니다.' },
        { question: '키 쉐어는 어떻게 생성되나요?', answer: '결합된 키를 입력하면 시스템이 랜덤 쉐어를 생성합니다: Part1 ⊕ Part2 ⊕ Part3 = 결합된 키(3파트), 또는 Part1 ⊕ Part2 = 결합된 키(2파트).' },
        { question: 'KCV(키 체크 값)란 무엇인가요?', answer: 'KCV는 키로 0을 암호화하여 계산되는 체크섬입니다. 각 쉐어와 결합된 키에는 실제 키 값을 공개하지 않고 검증하기 위한 자체 KCV가 있습니다.' },
        { question: 'Force Odd 패리티는 무엇을 하나요?', answer: 'Force Odd는 DES/3DES 키의 각 바이트를 홀수 패리티(홀수 개의 1비트)로 조정합니다. 이는 DES 표준의 정상 작동에 필요합니다.' },
      ],
      usage: [
        '결합된 키 필드에 암호화 키를 입력합니다.',
        '시스템이 자동으로 KCV를 계산하고 키 쉐어를 생성합니다.',
        '3파트 키: XOR하면 결합된 키와 같은 3개의 쉐어.',
        '2파트 키: XOR하면 결합된 키와 같은 2개의 쉐어.',
        'Secure 모드: 각 쉐어에 4자리 PIN을 설정한 후 잠금 해제를 클릭하여 확인.',
      ],
    },
    tr31: {
      title: 'TR-31 키 블록 인코더/디코더 온라인 - ANSI X9.143 | HSM Kit',
      description: '무료 온라인 TR-31 키 블록 인코더 및 디코더. KBPK 보호로 ANSI X9.143(TR-31) 표준에 따라 암호화 키를 래핑/언래핑. 버전 A-E(TDES/AES), 모든 키 용도, 알고리즘, 내보내기 가능성 옵션 지원. 결제 보안에 최적.',
      keywords: 'TR-31, 키 블록, ANSI X9.143, TR31 인코더, TR31 디코더, 키 블록 래퍼, KBPK, 결제 HSM, 키 용도, 키 내보내기 가능성, DUKPT, 키 관리, TDES 키 래핑, AES 키 래핑, 결제 보안, HSM 키 교환',
      faqTitle: 'TR-31 키 블록 FAQ',
      usageTitle: 'TR-31 키 블록 도구 사용 방법',
      faqs: [
        { question: 'TR-31이란 무엇인가요?', answer: 'TR-31(ANSI X9.143)은 결제 시스템에서 안전한 암호화 키 교환을 위한 업계 표준입니다. 암호화 키를 메타데이터(키 용도, 알고리즘, 사용 모드, 내보내기 가능성)와 함께 키 블록 보호 키(KBPK)로 래핑합니다.' },
        { question: 'TR-31의 버전은?', answer: '버전 A는 TDES 변형 바인딩, 버전 B는 TDES 키 유도, 버전 C는 TDES 변형 바인딩(대체), 버전 D는 AES 키 유도(가장 안전, 권장), 버전 E는 CMAC 바인딩이 있는 AES를 사용합니다.' },
        { question: 'KBPK란 무엇인가요?', answer: 'KBPK(키 블록 보호 키)는 TR-31 키 블록을 암호화/복호화하는 데 사용되는 마스터 키입니다. TDES 버전(A/B/C)에는 16 또는 24바이트 키를, AES 버전(D/E)에는 16, 24 또는 32바이트 AES 키를 사용합니다.' },
        { question: '키 용도란 무엇인가요?', answer: '키 용도(2자)는 래핑된 키의 목적을 정의합니다: B0/B1=BDK/DUKPT, C0=CVK, D0=데이터 암호화, E0-E6=EMV 마스터 키, K0/K1=키 래핑, M0-M8=MAC 키, P0/P1=PIN 키, V0-V4=PIN 검증.' },
        { question: '사용 모드란 무엇인가요?', answer: '사용 모드는 허용되는 작업을 정의합니다: B=암호화/복호화, C=생성/검증, D=복호화만, E=암호화만, G=생성만, N=제한 없음, X=키 유도.' },
        { question: '내보내기 가능성이란?', answer: '내보내기 가능성은 키 내보내기를 제어합니다: E=신뢰할 수 있는 키 블록에서 내보내기 가능, N=내보내기 불가, S=민감(제한적 내보내기).' },
      ],
      usage: [
        '인코딩: KBPK(3DES 또는 AES), 평문 키를 입력하고 버전, 키 용도, 알고리즘, 사용 모드, 내보내기 가능성을 선택한 후 인코드를 클릭합니다.',
        '인코딩된 키 블록에는 헤더 메타데이터 + 암호화된 키 + 무결성용 MAC가 포함됩니다.',
        '디코딩: KBPK를 입력하고 키 블록 데이터를 붙여넣은 후 디코드를 클릭합니다.',
        '디코드 결과에는 모든 헤더 필드(버전, 길이, 키 용도, 알고리즘, 사용 모드, 키 버전, 내보내기 가능성, 선택적 블록 수), 암호화된 데이터, MAC, 복호화된 키, KCV가 표시됩니다.',
      ],
    },
    kcv: {
      title: 'KCV 계산기 온라인 - 키 체크 값 생성기 | HSM Kit',
      description: 'AES 및 DES/3DES 키용 무료 온라인 KCV(키 체크 값) 계산기. 체크 값을 계산하여 암호화 키의 정확성을 검증합니다. DES 키의 자동 패리티 조정 지원. 결제 보안 및 키 검증에 필수.',
      keywords: 'KCV 계산기, 키 체크 값, KCV 생성기, AES KCV, DES KCV, 3DES KCV, CMAC, 키 검증, 결제 키, 키 체크 값 계산기, HSM 키 검증',
      faqTitle: 'KCV 계산기 FAQ',
      usageTitle: 'KCV 계산기 사용 방법',
      faqs: [
        { question: 'KCV(키 체크 값)란 무엇인가요?', answer: 'KCV는 암호화 키가 올바르게 입력되거나 전송되었는지 확인하는 데 사용되는 체크섬입니다. 0의 블록을 암호화하고 결과의 처음 3바이트를 취하여 계산됩니다.' },
        { question: 'DES/3DES의 KCV는 어떻게 계산되나요?', answer: 'DES/3DES의 경우: ECB 모드로 8바이트 0(0x0000000000000000)을 암호화한 다음 암호문의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: 'AES의 KCV는 어떻게 계산되나요?', answer: 'AES의 경우: 키를 사용하여 16바이트 0에 대해 CMAC를 계산한 다음 MAC 값의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: '자동 패리티 조정이란?', answer: 'DES 키는 각 바이트에 홀수 패리티가 필요합니다. 키에 올바른 패리티가 없으면 자동 조정을 활성화하여 KCV 계산 전에 수정할 수 있습니다.' },
      ],
      usage: [
        '알고리즘(AES 또는 DES/3DES)을 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'DES 키의 경우 선택적으로 자동 패리티 조정을 활성화합니다.',
        '"KCV 계산"을 클릭하여 키 체크 값을 생성합니다.',
        'KCV를 예상 값과 비교하여 키의 정확성을 검증합니다.',
      ],
    },
    pinBlock: {
      title: 'PIN 블록 생성기 온라인 - ISO 9564 형식 0/1/3/4 | HSM Kit',
      description: 'ISO 9564 형식(형식 0, 1, 3, 4)을 지원하는 무료 온라인 PIN 블록 생성기. 결제 거래, ATM, POS 시스템용 PIN 블록 생성. 결제 보안 테스트에 필수적인 도구. 100% 클라이언트 측 처리.',
      keywords: 'PIN 블록, ISO 9564, PIN 블록 형식 0, PIN 블록 형식 4, 결제 보안, ATM PIN, POS PIN, PIN 암호화, 카드 PIN, PIN 블록 생성기, 결제 카드 보안',
      faqTitle: 'PIN 블록 FAQ',
      usageTitle: 'PIN 블록 생성기 사용 방법',
      faqs: [
        { question: 'PIN 블록이란 무엇인가요?', answer: 'PIN 블록은 암호화 전에 PIN(개인 식별 번호)을 인코딩하기 위한 표준화된 형식입니다. PIN을 채우기 패턴 또는 PAN 데이터와 결합하여 암호화용 고정 길이 블록을 만듭니다.' },
        { question: '형식 0(ISO 9564-1)이란?', answer: '형식 0은 PIN 블록을 PAN의 오른쪽 12자리(체크 디지트 제외)와 XOR합니다. 결제 시스템에서 가장 널리 사용되는 형식입니다.' },
        { question: '형식 4(ISO 9564-1:2017)란?', answer: '형식 4는 AES 암호화를 위해 설계된 최신 형식입니다. 랜덤 패딩을 포함하며 이전 형식보다 더 나은 보안을 제공합니다.' },
        { question: 'PIN 블록에 PAN이 필요한 이유는?', answer: '형식 0 및 일부 형식에서 PAN은 PIN 데이터와 XOR되어 PIN을 특정 카드에 바인딩하고 특정 공격을 방지합니다.' },
      ],
      usage: [
        'PIN 블록 형식(0, 1, 3 또는 4)을 선택합니다.',
        'PIN(4-12자리)을 입력합니다.',
        'PAN이 필요한 형식의 경우 카드 번호를 입력합니다.',
        '"생성"을 클릭하여 PIN 블록을 만듭니다.',
        '생성된 16진수 문자열을 암호화 프로세스의 입력으로 사용합니다.',
      ],
    },
    pinBlockGeneral: {
      title: 'PIN Block 인코더/디코더 - ISO 9564 형식 0-4 | HSM Kit',
      description: '무료 온라인 PIN Block 인코더 및 디코더. 모든 ISO 9564 형식(0, 1, 2, 3, 4) 지원. PIN을 PIN Block로 인코딩하거나 PIN Block에서 PIN을 디코딩합니다. 100% 클라이언트 측 처리.',
      keywords: 'PIN Block인코더, PIN Block디코더, ISO 9564, PIN Block형식0, PIN Block형식1, PIN Block형식2, PIN암호화, 결제보안, HSM테스트, 카드PIN',
      faqTitle: 'PIN Block 인코더/디코더 FAQ',
      usageTitle: 'PIN Block 툴 사용 방법',
      faqs: [
        { question: 'PIN Block 형식의 차이점은 무엇입니다?', answer: '형식 0: PAN과 XOR(가장 일반적). 형식 1: 랜덤 패딩, PAN 불필요. 형식 2: 형식 0과 유사, 다른 제어 필드. 형식 3: PAN을 사용한 랜덤 패딩. 형식 4: AES용으로 설계, 128비트 블록 크기.' },
        { question: '형식 0과 형식 1은 언제 사용해야 합니다?', answer: '형식 0은 PIN을 특정 카드에 바인딩하기 때문에 카드 결제에서 가장 널리 사용됩니다. 형식 1은 PAN이 없거나 카드 바인딩이 필요하지 않은 일반 목적 PIN 전송에 사용됩니다.' },
        { question: 'PAN 없이 PIN Block를 디코딩할 수 있습니다?', answer: '형식 1만 PAN 없이 디코딩할 수 있습니다. 랜덤 패딩을 사용하고 PAN 데이터와 XOR하지 않기 때문입니다. 형식 0, 2, 3, 4는 XOR 연산을 반전하고 PIN을 복구하려면 PAN이 필요합니다.' },
        { question: '형식 4는 무엇에 사용됩니다?', answer: '형식 4는 최신 형식(ISO 9564-1:2017)으로 AES 암호화를 위해 특별히 설계되었습니다. 128비트 블록 크기(32개 십육진수 문자)를 사용하며 보안 강화를 위해 랜덤 패딩을 포함합니다. 현대 결제 시스템에서 점차 채택되고 있습니다.' },
        { question: '패딩 문자는 무엇에 사용됩니다?', answer: '패딩 문자(일반적으로 "F")는 PIN 숫자 뒤의 PIN Block 내 사용되지 않는 위치를 채웁니다. 이는 암호화에 적합한 고정 길이 블록을 생성합니다. 다른 시스템은 다른 패딩 문자를 사용할 수 있습니다.' },
      ],
      usage: [
        '사용할 PIN Block 형식(0, 1, 2, 3 또는 4)을 선택합니다.',
        'PIN을 PIN Block로 변환하려면 "인코딩"을, PIN Block에서 PIN을 추출하려면 "디코딩"을 선택합니다.',
        '인코딩 시: PIN(4-12자리), PAN(카드 번호)를 입력하고 선택적으로 패딩 문자를 변경합니다.',
        '디코딩 시: PIN Block(십육진수)와 PAN(형식에 필요한 경우)을 입력합니다.',
        '인코딩 또는 디코딩 버튼을 클릭하여 처리합니다.',
        '결과에 PIN Block(인코딩용) 또는 디코딩된 PIN(디코딩용)이 표시됩니다.',
      ],
    },
    pinBlockAes: {
      title: 'AES PIN 블록 형식 4 - ISO 9564-1:2017 암호화/복호화 | HSM Kit',
      keywords: 'AES PIN 블록, 형식 4, ISO 9564-1, AES-128, PIN 암호화, PIN 복호화, ECB 모드, 결제 보안, HSM, 암호화된 PIN 블록',
      faqTitle: 'AES PIN 블록 FAQ',
      usageTitle: 'AES PIN 블록 도구 사용 방법',
      faqs: [
        { question: 'PIN 블록 형식 4란 무엇입니까?', answer: '형식 4는 ISO 9564-1:2017에서 정의된 PIN 블록 형식으로 AES 암호화 전용으로 설계되었습니다. 128비트(16바이트) 블록 크기를 사용하며 이전 형식보다 강력한 보안을 제공합니다. PIN 블록은 AES 암호화 전에 PAN 블록과 XOR됩니다.' },
        { question: '형식 4와 형식 0의 차이점은 무엇입니까?', answer: '형식 0은 DES/3DES 암호화용으로 설계된 64비트(8바이트) 블록을 사용합니다. 형식 4는 AES 암호화용으로 설계된 128비트(16바이트) 블록을 사용합니다. 형식 4는 더 긴 블록 크기와 랜덤 패딩으로 보안이 강화되었습니다.' },
        { question: '어떤 암호화 알고리즘이 사용됩니까?', answer: '이 도구는 ECB(Electronic Codebook) 모드의 AES-128 암호화를 사용합니다. 키는 16바이트(32개 16진수 문자)여야 합니다. AES-192와 AES-256도 ISO 9564-1:2017에서 지원되지만 AES-128이 가장 일반적입니다.' },
        { question: 'AES-192 또는 AES-256을 사용할 수 있습니까?', answer: '이 도구는 현재 AES-128(16바이트 키)을 지원합니다. AES-192는 24바이트 키, AES-256은 32바이트 키가 필요합니다. 구현을 확장하여 다른 AES 변형을 지원할 수 있습니다.' },
        { question: '중간 단계가 표시되는 이유는 무엇입니까?', answer: '중간 단계는 암호화 프로세스를 이해하는 데 도움이 됩니다: 클리어 PIN 블록(암호화 전) → PAN 블록 → XOR 결과(AES 입력) → 암호화 결과. 이는 학습, 디버깅 및 HSM 작동 방식 이해에 유용합니다.' },
      ],
      usage: [
        '작업 모드 선택: 암호화(PIN에서 PIN 블록 생성) 또는 복호화(PIN 블록에서 PIN 추출).',
        'AES-128 키 입력(32개 16진수 문자, 16바이트).',
        'PAN(카드 번호) 입력(13-19자리 숫자).',
        '암호화 모드의 경우: PIN(4-12자리) 입력. 복호화 모드의 경우: 암호화된 블록(32개 16진수 문자) 입력.',
        '암호화 또는 복호화 버튼을 클릭하여 처리합니다.',
        '결과에 암호화된 블록(암호화용) 또는 추출된 PIN(복호화용)이 표시됩니다.',
        '선택적으로 "중간 단계 표시"를 선택하여 암호화 프로세스의 세부 분석을 확인합니다.',
      ],
    },
    pinOffset: {
      title: 'PIN Offset 계산기 - IBM 3624 방식 온라인 | HSM Kit',
      description: 'IBM 3624 방식을 사용한 무료 온라인 PIN Offset 계산기. 고객 PIN에서 PIN offset을 계산하거나 offset으로 PIN을 검증합니다. 3DES 암호화(PDK), 10진화 테이블, 유연한 검증 데이터 방식 지원. PIN 관리에 필수적인 도구.',
      keywords: 'PIN offset, IBM 3624, PIN offset 계산기, 자연 PIN, 10진화 테이블, PDK, PIN 파생 키, PIN 검증, 고객 PIN, 검증 데이터, 3DES 암호화, PIN 관리',
      faqTitle: 'PIN Offset FAQ',
      usageTitle: 'PIN Offset 도구 사용 방법',
      faqs: [
        { question: 'PIN Offset이란 무엇입니까?', answer: 'PIN Offset은 고객이 선택한 PIN과 카드 데이터에서 계산된 "자연 PIN" 간의 차이입니다. 이를 통해 발급자는 암호화 검증 방식을 유지하면서 고객 선택 PIN을 지원할 수 있습니다. offset은 (고객 PIN - 자연 PIN) mod 10으로 계산됩니다.' },
        { question: 'IBM 3624 방식이란 무엇입니까?', answer: 'IBM 3624는 널리 사용되는 PIN 생성 및 검증 방식입니다. PIN 파생 키(PDK)로 PAN을 3DES로 암호화하고, 10진화 테이블을 적용하여 16진수를 숫자로 변환하고, 검증 데이터를 추출하며, offset을 계산하거나 PIN을 검증합니다.' },
        { question: '10진화 테이블(DecTab)이란 무엇입니까?', answer: '10진화 테이블(DecTab)은 16진수 숫자(0-F)를 10진수 숫자(0-9)로 변환하는 데 사용되는 16자리 조회 테이블입니다. 기본값은 "0123456789012345"이지만 사용자 정의할 수 있습니다. 각 16진수 숫자는 테이블의 해당 위치로 대체됩니다.' },
        { question: '검증 데이터 매개변수와 마스크의 차이점은 무엇입니까?', answer: '검증 데이터 매개변수(시작, 길이, 패딩, PIN 길이)는 자연 PIN에서 고정 길이 부분 문자열을 추출합니다. 검증 데이터 마스크는 "N"이 자연 PIN 자릿수를 나타내고 0-9가 고정 값을 나타내는 패턴을 사용하여 더 유연한 추출을 가능하게 합니다(예: "0000000N0000").' },
        { question: 'offset으로 PIN을 검증하는 방법은?', answer: 'PIN 탭 사용: PDK, PAN, PIN offset, 검증 매개변수를 입력합니다. 도구가 자연 PIN을 계산하고 검증 데이터를 추출하며 offset을 추가하여 고객 PIN을 얻습니다: (검증 데이터 + Offset) mod 10.' },
      ],
      usage: [
        '"Offset" 탭에서 고객 PIN으로부터 PIN offset을 계산하거나 "PIN" 탭에서 offset으로 PIN을 검증/계산합니다.',
        'PDK(PIN 파생 키) 입력 - 32개 16진수 문자(16바이트) 3DES 키.',
        'PAN(주 계정 번호) 입력 - 12-19자리 숫자.',
        '10진화 테이블(DecTab) 입력 - 16자리 숫자, 기본값: 0123456789012345.',
        '검증 데이터 방식 선택: 매개변수(시작, 길이, 패딩, PIN 길이) 또는 마스크 패턴.',
        'Offset 탭의 경우: 고객 PIN을 입력하고 "Offset 계산"을 클릭.',
        'PIN 탭의 경우: PIN offset을 입력하고 "PIN 계산"을 클릭하여 고객의 PIN을 얻습니다.',
      ],
    },
    pinPvv: {
      title: 'PIN PVV 계산기 - Visa PIN 검증 값 온라인 | HSM Kit',
      description: 'Visa 표준 알고리즘을 사용한 무료 온라인 PIN PVV(PIN 검증 값) 계산기. 고객 PIN에서 PVV를 계산하거나 PVV로 PIN을 검증합니다. PDK를 사용한 3DES 암호화, PVKI 선택, 10진화 지원. 카드 결제 보안에 필수적인 도구.',
      keywords: 'PIN PVV, PIN 검증 값, Visa PVV, PVV 계산기, PDK, PVKI, PIN 검증, 카드 보안, 결제 보안, 3DES 암호화, 10진화, TSP, PIN 파생',
      faqTitle: 'PIN PVV FAQ',
      usageTitle: 'PIN PVV 도구 사용 방법',
      faqs: [
        { question: 'PIN PVV란 무엇입니까?', answer: 'PIN 검증 값(PVV)은 Visa의 PIN 검증 표준입니다. 이는 고객 PIN, 카드 번호(PAN), 비밀 PIN 파생 키(PDK)로부터 3DES 암호화와 10진화를 사용하여 계산되는 4자리 값입니다. 은행은 실제 PIN을 저장하지 않고 PVV를 사용하여 고객 PIN을 검증합니다.' },
        { question: 'PVV는 어떻게 계산됩니까?', answer: 'PVV 계산: 1) 3DES ECB를 사용하여 PDK로 PAN(우측 정렬, 0 패딩)을 암호화합니다. 2) 10진화 테이블을 적용하여 16진수를 숫자로 변환합니다(0-9는 유지, A-F는 0-5로 매핑). 3) 위치 PVKI(변환 선택 프로세스 - TSP)에서 4자리를 추출합니다. 4) PIN과 TSP를 자릿수별로 더하여 mod 10으로 PVV를 계산합니다.' },
        { question: 'PVKI란 무엇입니까?', answer: 'PVKI(PIN 검증 키 인덱스)는 0-9의 값으로, 암호화된 PAN에서 TSP 자릿수 추출을 시작할 위치를 결정합니다. 다른 카드는 다른 PVKI 값을 사용하여 검증 프로세스에 변화를 추가할 수 있습니다. PVKI는 일반적으로 카드 계정과 함께 저장됩니다.' },
        { question: 'PVV 계산에서 TSP란 무엇입니까?', answer: 'TSP(변환 선택 프로세스)는 PVKI가 나타내는 위치에서 시작하는 10진화된 암호화 PAN에서 추출된 4자리 값입니다. 이는 고객 PIN과 결합되어 PVV를 생성합니다. TSP는 카드마다 다른 암호화 솔트 역할을 합니다.' },
        { question: 'PVV를 사용하여 PIN을 검증하는 방법은 무엇입니까?', answer: 'PIN 탭 사용: PDK, PAN, PVV(저장된 값), PVKI를 입력합니다. 도구는 PAN을 암호화하고, TSP를 추출하고, PVV 공식을 역전하여 자연 PIN을 계산합니다: PIN = (PVV - TSP) mod 10. 결과를 고객이 입력한 PIN과 비교하여 정확성을 검증합니다.' },
      ],
      usage: [
        '"PVV" 탭을 사용하여 고객 PIN에서 PVV를 계산하거나 "PIN" 탭을 사용하여 알려진 PVV에서 PIN을 검증/계산합니다.',
        'PDK(PIN 파생 키) 입력 - 32개 16진수 문자(16바이트) 3DES 키.',
        'PAN(주 계정 번호) 입력 - 12-19자리 숫자.',
        'PVV 탭의 경우: 고객 PIN(4-12자리)과 PVKI(0-9)를 입력하고 PVV 계산을 클릭합니다.',
        'PIN 탭의 경우: PVV(4자리)와 PVKI(0-9)를 입력하고 PIN 계산을 클릭합니다.',
        '결과에는 검증을 위한 중간 값(암호화된 PAN 및 TSP)과 함께 계산된 값이 표시됩니다.',
      ],
    },
    visaCertificates: {
      title: 'VISA 인증서 검증 도구 - 발급자 서명 요청 및 서명된 공개 키 데이터 검증 | HSM Kit',
      description: '무료 온라인 VISA 인증서 검증 도구. VISA 발급자 인증서 서명 요청을 검증하고 CA 공개 키를 사용하여 서명된 발급자 공개 키 데이터를 확인합니다. VSDC CA V92, V94 및 사용자 정의 CA 키 지원. 결제 카드 인증서 관리 및 EMV 인증에 필수적인 도구.',
      keywords: 'VISA 인증서, 발급자 서명 요청, 인증서 검증, CA 공개 키, 서명된 인증서, EMV 인증서, 결제 카드 보안, VISA CA, 발급자 공개 키, 인증서 서명, VSDC CA, EMV 인증',
      faqTitle: 'VISA 인증서 FAQ',
      usageTitle: 'VISA 인증서 도구 사용 방법',
      faqs: [
        { question: 'VISA 발급자 인증서란 무엇인가요?', answer: 'VISA 발급자 인증서는 발급자의 공개 키가 포함된 VISA가 발급한 디지털 인증서입니다. EMV 칩 카드 거래에서 카드 발급자를 인증하고 결제 체계에서 카드까지의 신뢰 체인을 설정하는 데 사용됩니다.' },
        { question: '발급자 서명 요청이란 무엇인가요?', answer: '발급자 서명 요청(CSR)은 발급자의 공개 키에 서명하기 위해 VISA CA로 전송되는 요청입니다. 프로덕션에서 사용하기 전에 VISA에서 인증해야 하는 공개 키 모듈러스, 지수 및 기타 인증서 정보가 포함되어 있습니다.' },
        { question: '서명된 인증서를 어떻게 검증하나요?', answer: '서명된 인증서를 검증하려면 서명된 발급자 공개 키 데이터와 해당 VISA CA 공개 키가 필요합니다. 이 도구는 RSA 서명을 검증하여 인증서가 진짜이고 변조되지 않았으며 VISA에서 정말로 서명되었는지 확인합니다.' },
        { question: '어떤 CA 공개 키가 지원되나요?', answer: '이 도구에는 EMV 인증에서 일반적으로 사용되는 VSDC CA V92 및 V94에 대한 사전 정의된 VISA CA 공개 키가 포함되어 있습니다. 다른 VISA CA 버전 또는 테스트 CA에서 서명한 인증서를 검증해야 하는 경우 사용자 정의 CA 공개 키를 로드할 수도 있습니다.' },
        { question: '인증서 검증이 왜 중요한가요?', answer: '인증서 검증은 발급자 공개 키가 VISA에서 적절하게 인증되고 변경되지 않았음을 보장합니다. 이는 EMV 거래의 보안 체인을 유지하여 사기 카드가 단말기에서 수락되는 것을 방지합니다.' },
      ],
      usage: [
        '"발급자 서명 요청 검증" 탭을 사용하여 VISA CA로 서명을 위해 전송하기 전에 인증서 요청을 확인합니다.',
        '인증서 요청 파일을 로드하거나 16진수 데이터를 붙여넣은 다음 검증을 클릭하여 구조와 형식을 확인합니다.',
        '"서명된 발급자 공개 키 데이터 검증" 탭을 사용하여 VISA CA로부터 수신한 인증서를 검증합니다.',
        '서명된 인증서 데이터를 로드하거나 붙여넣고 사전 정의된 CA 키(VSDC CA V92/V94)를 선택하거나 사용자 정의 CA 공개 키를 로드합니다.',
        '검증을 클릭하여 선택한 CA 공개 키를 사용하여 RSA 검증으로 서명을 확인합니다.',
        '디버그 모드를 활성화하여 인증서 구조, 모듈러스, 지수 및 검증 단계에 대한 자세한 정보를 확인합니다.',
      ],
    },
    hash: {
      title: '해시 계산기 온라인 - MD5, SHA-256, SHA-512, BLAKE2 | HSM Kit',
      description: 'MD5, SHA-1, SHA-256, SHA-512, RIPEMD-160, WHIRLPOOL, BLAKE2, CRC32 등을 지원하는 무료 온라인 해시 계산기. 텍스트 또는 16진수 입력에서 해시 값 계산. 20개 이상의 해시 알고리즘 지원. 모든 처리는 브라우저에서 실행.',
      keywords: '해시 계산기, MD5 해시, SHA-256 해시, SHA-512 해시, BLAKE2, RIPEMD-160, WHIRLPOOL, CRC32, 해시 생성기, 체크섬 계산기, 메시지 다이제스트, 암호학적 해시',
      faqTitle: '해시 계산기 FAQ',
      usageTitle: '해시 계산기 사용 방법',
      faqs: [
        { question: '해시 함수란?', answer: '해시 함수는 임의 크기의 입력 데이터를 고정 크기 출력(해시 값)으로 변환하는 수학적 알고리즘입니다.' },
        { question: '어떤 해시 알고리즘을 사용해야 하나요?', answer: '보안 목적으로 SHA-256 또는 SHA-512를 사용하세요. MD5와 SHA-1은 암호화 용도로 안전하지 않습니다.' },
        { question: 'MD5와 SHA-256의 차이점은?', answer: 'MD5는 128비트 해시를 생성하며 빠르지만 암호학적으로 깨졌습니다. SHA-256은 256비트 해시를 생성하며 현재 암호학적으로 안전합니다. 보안 중심 애플리케이션에는 SHA-256을 사용하세요.' },
        { question: '해시를 복호화할 수 있나요?', answer: '아니요, 해시 함수는 설계상 단방향 함수입니다. 해시에서 원래 입력을 복구할 수 없습니다. 이 특성 때문에 비밀번호 저장 및 데이터 무결성 검증에 유용합니다.' },
      ],
      usage: ['입력 유형 선택', '알고리즘 선택', '데이터 입력', '"계산" 클릭'],
    },
    encoding: {
      title: '문자 인코딩 변환기 온라인 - ASCII, EBCDIC, Hex | HSM Kit',
      description: '무료 온라인 문자 인코딩 변환기. ASCII, EBCDIC, 16진수, 바이너리, ATM 10진수 형식 간 변환. 결제 시스템 개발 및 메인프레임 통합에 필수. 100% 클라이언트 측 변환.',
      keywords: '문자 인코딩, ASCII EBCDIC 변환, 16진수 변환기, 바이너리 변환기, EBCDIC 변환기, ATM 10진수, 인코딩 변환, 결제 시스템 인코딩, 은행 인코딩',
      faqTitle: '문자 인코딩 FAQ',
      usageTitle: '인코딩 변환기 사용 방법',
      faqs: [
        { question: '문자 인코딩이란?', answer: '문자 인코딩은 각 문자를 고유한 숫자나 바이트 시퀀스와 연결하는 시스템입니다.' },
        { question: 'EBCDIC란?', answer: 'EBCDIC는 주로 IBM 메인프레임에서 사용되는 8비트 문자 인코딩입니다.' },
        { question: 'ASCII와 EBCDIC 변환이 필요한 이유는?', answer: '많은 레거시 은행 및 금융 시스템이 EBCDIC를 사용하는 IBM 메인프레임에서 실행됩니다. 모던 시스템(ASCII/UTF-8 사용)과 이러한 메인프레임 통합 시 문자 변환이 필수적입니다.' },
        { question: 'ATM 10진 인코딩이란?', answer: 'ATM 10진은 ATM 통신에서 사용되는 특정 인코딩으로, 각 숫자(0-9)가 ASCII 코드로 표현됩니다. 금융 메시징 프로토콜에서 일반적으로 사용됩니다.' },
      ],
      usage: ['변환 유형 선택', '데이터 입력', '"변환" 클릭'],
    },
    bcd: {
      title: 'BCD 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 BCD 인코더 및 디코더. 10진수를 BCD로 변환하거나 BCD를 10진수로 변환. 금융 및 임베디드 시스템에서 사용. 결제 터미널 통합에 최적.',
      keywords: 'BCD 인코더, BCD 디코더, 이진화 10진수, 10진수 BCD 변환, 금융 인코딩, 결제 시스템 인코딩',
      faqTitle: 'BCD FAQ',
      usageTitle: 'BCD 도구 사용 방법',
      faqs: [
        { question: 'BCD란?', answer: '이진화 10진수(BCD)는 각 10진수를 4비트로 표현하는 인코딩입니다.' },
        { question: 'BCD를 사용하는 이유는?', answer: 'BCD는 정확한 10진 표현이 중요한 금융 애플리케이션에서 사용됩니다.' },
        { question: '팩드 BCD와 언팩드 BCD의 차이점은?', answer: '팩드 BCD는 1바이트에 2개의 10진수를 저장합니다(각 4비트). 언팩드 BCD는 각 10진수가 1바이트 전체를 차지합니다. 팩드 BCD가 공간 효율이 더 높습니다.' },
        { question: 'BCD는 어디서 일반적으로 사용되나요?', answer: 'BCD는 금융 시스템, 계산기, 디지털 시계 및 10진 정밀도가 중요한 애플리케이션에서 널리 사용됩니다. 결제 단말기와 ATM은 금액 표시에 BCD를 자주 사용합니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    checkDigits: {
      title: '체크 디지트 계산기 온라인 - Luhn MOD 10, MOD 9 | HSM Kit',
      description: '무료 온라인 체크 디지트 계산기 및 검증기. Luhn(MOD 10) 및 MOD 9로 체크 디지트 생성 또는 검증. 신용카드 번호, IMEI, 기타 식별자 검증. 결제 검증에 필수.',
      keywords: '체크 디지트 계산기, Luhn 알고리즘, MOD 10, MOD 9, 신용카드 검증, IMEI 체크, 체크섬 계산기, Luhn 체크, 카드 번호 검증, 식별자 검증',
      faqTitle: '체크 디지트 FAQ',
      usageTitle: '체크 디지트 계산기 사용 방법',
      faqs: [
        { question: '체크 디지트란?', answer: '체크 디지트는 오류 검출을 위해 숫자에 추가되는 숫자입니다.' },
        { question: 'Luhn 알고리즘이란?', answer: 'Luhn 알고리즘(MOD 10)은 신용카드 번호 등을 검증하는 체크섬 공식입니다.' },
        { question: '어떤 번호가 Luhn 알고리즘을 사용하나요?', answer: '신용카드 번호(Visa, MasterCard, Amex), IMEI 번호, NPI(의료 제공자 식별자), 캐나다 사회보험번호 등 많은 식별 번호가 Luhn 검증을 사용합니다.' },
        { question: 'Amex SE MOD 9 알고리즘이란?', answer: 'Amex SE(서비스 시설) MOD 9 알고리즘은 American Express가 가맹점/서비스 시설 번호를 검증하는 데 사용합니다. Luhn과 다른 계산 방법을 사용합니다.' },
      ],
      usage: ['알고리즘 선택', '검증 또는 생성 선택', '숫자 입력'],
    },
    base64: {
      title: 'Base64 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 Base64 인코더 및 디코더. 텍스트를 Base64로 변환하거나 Base64를 텍스트로 변환. 웹 애플리케이션 데이터 인코딩에 필수. 빠르고 안전한 브라우저 처리.',
      keywords: 'Base64 인코더, Base64 디코더, Base64 변환, 바이너리 텍스트 변환, Base64 변환기, MIME 인코딩',
      faqTitle: 'Base64 FAQ',
      usageTitle: 'Base64 도구 사용 방법',
      faqs: [
        { question: 'Base64란?', answer: 'Base64는 64문자를 사용하여 바이너리 데이터를 ASCII 문자열로 변환하는 인코딩입니다.' },
        { question: 'Base64를 사용하는 이유는?', answer: 'Base64는 텍스트 기반 프로토콜에서 바이너리 데이터를 전송하는 데 사용됩니다.' },
        { question: 'Base64는 암호화를 제공하나요?', answer: '아니요, Base64는 인코딩 체계이지 암호화가 아닙니다. 누구나 Base64 데이터를 디코딩할 수 있습니다. 데이터 표현용이며 보안용이 아닙니다.' },
        { question: 'Base64가 데이터 크기를 증가시키는 이유는?', answer: 'Base64는 3바이트의 바이너리 데이터를 4개의 ASCII 문자로 인코딩하여 약 33% 크기 증가가 발생합니다. 입력 길이가 3으로 나누어지지 않으면 패딩 문자 "="가 사용됩니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    base94: {
      title: 'Base94 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 Base94 인코더 및 디코더. 94개의 출력 가능한 ASCII 문자를 사용한 컴팩트 인코딩. Base64보다 약 20% 더 컴팩트. 효율적인 데이터 저장 및 전송에 유용.',
      keywords: 'Base94 인코더, Base94 디코더, 컴팩트 인코딩, 효율적인 인코딩, URL 안전 인코딩',
      faqTitle: 'Base94 FAQ',
      usageTitle: 'Base94 도구 사용 방법',
      faqs: [
        { question: 'Base94란?', answer: 'Base94는 94개의 출력 가능한 ASCII 문자를 사용하는 인코딩으로 Base64보다 효율적입니다.' },
        { question: 'Base94를 사용하는 이유는?', answer: 'Base94는 Base64보다 약 20% 더 컴팩트한 인코딩을 제공합니다.' },
        { question: 'Base94는 어떤 문자를 사용하나요?', answer: 'Base94는 !(0x21)부터 ~(0x7E)까지의 94개 출력 가능 ASCII 문자를 사용하며, 공백은 제외됩니다. 문자, 숫자, 모든 표준 구두점이 포함됩니다.' },
        { question: '언제 Base94를 사용해야 하나요?', answer: '바이너리 데이터의 컴팩트한 텍스트 표현이 필요하고, 전송/저장 시스템이 모든 출력 가능 ASCII 문자를 지원하는 경우 Base94를 사용합니다. URL, QR 코드, 저장 최적화에 적합합니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    messageParser: {
      title: '메시지 파서 온라인 - ATM NDC, Wincor, ISO 8583 | HSM Kit',
      description: '무료 온라인 ATM 및 금융 메시지 파서. ATM NDC, Wincor, ISO 8583 메시지 형식 구문 분석. 결제 시스템 개발 및 디버깅에 필수. 모든 파싱은 브라우저에서 실행.',
      keywords: '메시지 파서, ATM NDC, ATM Wincor, ISO 8583, 금융 메시지, 거래 파서, 16진수 파서, ATM 메시지 디코더, 결제 메시지 파서, 금융 거래 파서',
      faqTitle: '메시지 파서 FAQ',
      usageTitle: '메시지 파서 사용 방법',
      faqs: [
        { question: 'ATM NDC란?', answer: 'NDC(NCR Direct Connect)는 NCR ATM이 호스트 시스템과 통신하는 프로토콜입니다.' },
        { question: 'ISO 8583이란?', answer: 'ISO 8583은 금융 거래 메시지의 국제 표준입니다.' },
        { question: 'Wincor/Nixdorf 프로토콜이란?', answer: 'Wincor Nixdorf(현 Diebold Nixdorf) 프로토콜은 NDC와 유사하지만 벤더 고유 변형이 있는 독점 ATM 통신 프로토콜입니다. 유럽과 아시아 시장에서 널리 사용됩니다.' },
        { question: '메시지 형식을 어떻게 식별하나요?', answer: 'NDC 메시지는 일반적으로 특정 메시지 클래스 식별자로 시작합니다. ISO 8583 메시지는 4자리 MTI(메시지 유형 식별자)로 시작합니다. 16진 덤프 구조가 사용 중인 프로토콜을 식별하는 데 도움이 됩니다.' },
      ],
      usage: ['메시지 형식 선택', '16진수 데이터 입력', '"구문 분석" 클릭'],
    },
    rsaDer: {
      title: 'RSA DER 공개키 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 RSA DER 공개키 인코더 및 디코더. 모듈러스/지수와 DER ASN.1 형식 간 변환. PEM 출력 및 다양한 입력 인코딩(ASCII Hex, Base64, EBCDIC) 지원. 100% 브라우저 처리.',
      keywords: 'RSA DER, RSA 공개키, DER 인코딩, ASN.1, PEM 형식, 모듈러스, 지수, RSA 키 변환기, 공개키 인코더, RSA 키 파서, 인증서 키 추출기',
      faqTitle: 'RSA DER 공개키 FAQ',
      usageTitle: 'RSA DER 도구 사용 방법',
      faqs: [
        { question: 'DER 인코딩이란?', answer: 'DER(Distinguished Encoding Rules)은 ASN.1 데이터 구조를 인코딩하는 바이너리 형식입니다.' },
        { question: 'PEM 형식이란?', answer: 'PEM은 헤더/푸터 줄이 있는 DER의 Base64 인코딩 버전입니다.' },
        { question: 'RSA의 모듈러스와 지수란?', answer: '모듈러스(n)는 두 큰 소수의 곱으로 키 크기를 결정합니다. 공개 지수(e)는 일반적으로 65537(0x10001)입니다. 이 둘이 함께 공개키를 구성합니다.' },
        { question: '인증서에서 모듈러스를 어떻게 추출하나요?', answer: '이 도구를 사용하여 DER/PEM 인코딩된 공개키를 디코딩하세요. 파서가 모듈러스와 지수를 다양한 형식(16진수, 10진수, Base64)으로 추출하여 표시합니다.' },
      ],
      usage: ['인코드: 모듈러스와 지수 입력', '디코드: DER 또는 PEM 데이터 붙여넣기'],
    },
    futurexKeys: {
      title: 'Futurex 키 암호화/복호화 온라인 - HSM 키 변형 도구 | HSM Kit',
      description: '무료 온라인 Futurex HSM 키 암호화/복호화 도구. MFK(마스터 파일 키)와 수정자 변형(0-F, 1A-1F)을 사용하여 키를 암호화/복호화. Futurex, IBM, Atalla, VISA 키 변형 방식 지원. 키 조회 기능으로 KCV 매칭을 통해 올바른 수정자를 찾습니다. 100% 클라이언트 측 처리.',
      keywords: 'Futurex HSM, 키 암호화, 키 복호화, MFK, 마스터 파일 키, 키 변형, 수정자, HSM 도구, 결제 보안, 키 관리, IBM HSM, Atalla HSM, VISA PVK, KCV 검증, 3DES 암호화, 키 조회, HSM 키 관리',
      faqTitle: 'Futurex 키 FAQ',
      usageTitle: 'Futurex 키 도구 사용 방법',
      faqs: [
        { question: 'Futurex 키 암호화란?', answer: 'Futurex HSM은 특정 키 암호화 방법을 사용하며, 키는 마스터 파일 키(MFK)의 변형과 수정자(0-F, 1A-1F)를 조합하여 암호화됩니다. 변형 키는 MFK를 수정자 바이트와 XOR하여 생성됩니다.' },
        { question: '수정자란?', answer: '수정자(0-F, 1A-1F)는 MFK에서 다른 키 변형을 생성하는 데 사용됩니다. 각 수정자는 PIN 키, MAC 키, 데이터 암호화 키 등 다른 용도를 위한 고유한 암호화 키를 생성합니다.' },
        { question: 'MFK(마스터 파일 키)란?', answer: 'MFK는 Futurex HSM에서 사용되는 기본 마스터 키입니다. 일반적으로 트리플 길이 3DES 키(48자 16진수)입니다. MFK는 수정자와 결합하여 다른 키를 암호화/복호화하기 위한 변형 키를 생성합니다.' },
        { question: '키 조회란?', answer: '키 조회는 암호화된 키를 복호화하기 위해 모든 수정자(0-F, 1A-1F)를 시도합니다. KCV(키 체크 값)와 패리티 유형(홀수/짝수)으로 결과를 필터링하여 암호화에 사용된 정확한 수정자를 찾을 수 있습니다.' },
        { question: '다른 HSM 유형의 차이점은?', answer: '다른 HSM 벤더는 다른 키 변형 방식을 사용합니다: Futurex는 전체 바이트 XOR, IBM은 위치별 XOR, Atalla는 AKB 방식, VISA는 처음 8바이트만 PVK 방식을 사용합니다.' },
        { question: 'KCV란 무엇이며 어떻게 사용하나요?', answer: 'KCV(키 체크 값)는 키로 0을 암호화하여 계산됩니다. 키 조회에서 예상 KCV를 입력하여 결과를 필터링하고 해당 특정 KCV를 생성하는 수정자를 찾을 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 16진수 평문 키를 입력하고 수정자와 MFK를 선택한 후 암호화 클릭.',
        '키 복호화: 16진수 암호화 키를 입력하고 수정자와 MFK를 선택한 후 복호화 클릭.',
        '결과 표시: 입력 키, 감지된 패리티, 사용된 MFK, 수정자, 출력 키, KCV.',
        '키 조회: 암호화 키를 입력하고 선택적으로 KCV 필터와 패리티 필터를 설정.',
        'HSM 유형(임의/Futurex/IBM/Atalla/VISA)을 선택하고 조회를 클릭하여 모든 수정자 시도.',
        '결과는 수정자, 복호화 키, KCV, 패리티를 포함한 모든 일치하는 복호화를 표시.',
      ],
    },
    atallaKeys: {
      title: 'Atalla 키 (AKB) 온라인 - HSM 키 암호화/복호화 도구 | HSM Kit',
      description: '무료 온라인 Atalla HSM 키 암호화/복호화 도구. AKB(Atalla Key Block) 형식을 사용하여 키를 암호화/복호화. MFK와 AKB 헤더를 사용한 안전한 키 관리. KCV 검증 및 패리티 체크 지원. 모든 처리는 브라우저에서 실행.',
      keywords: 'Atalla HSM, AKB, Atalla Key Block, 키 암호화, 키 복호화, MFK, HSM 도구, 결제 보안, 키 관리, KCV 검증, 3DES 암호화, Atalla 키 관리',
      faqTitle: 'Atalla 키 FAQ',
      usageTitle: 'Atalla 키 도구 사용 방법',
      faqs: [
        { question: 'AKB(Atalla Key Block)란?', answer: 'AKB는 Atalla HSM에서 사용되는 키 블록 형식입니다. 8자 헤더(예: 1PUNE000)와 암호화된 키 데이터로 구성됩니다. 헤더는 키 변형을 정의합니다.' },
        { question: 'AKB 헤더란?', answer: 'AKB 헤더는 8자 접두사로, 암호화에 사용되는 키 변형을 정의합니다. 일반적인 예로 1PUNE000이 있으며, 다른 헤더는 다른 키 유형이나 용도를 나타냅니다.' },
        { question: 'MFK(마스터 파일 키)란?', answer: 'MFK는 Atalla HSM에서 사용되는 기본 마스터 키입니다. 트리플 길이 3DES 키(48자 16진수)이며, AKB 헤더와 결합하여 키 암호화/복호화를 위한 변형 키를 생성합니다.' },
        { question: 'AKB 암호화는 어떻게 작동하나요?', answer: 'AKB 헤더가 ASCII 값으로 변환되고 MFK와 XOR되어 변형 키를 생성합니다. 이 변형 키로 3DES ECB 모드를 사용하여 대상 키를 암호화하고, 헤더와 암호문으로 AKB를 형성합니다.' },
        { question: 'KCV 체크란?', answer: 'KCV(Key Check Value)는 복호화된 키의 검증에 사용됩니다. 복호화 시 KCV를 입력하면 계산된 KCV와 비교하여 올바른 MFK와 AKB 형식을 확인할 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 16진수 키를 입력하고, AKB 헤더(기본값: 1PUNE000)를 설정, MFK를 입력한 후 암호화 클릭.',
        '결과 표시: 평문 키, AKB 헤더, 생성된 AKB, KCV.',
        'AKB 복호화: AKB(예: 1PUNE000,암호화데이터)를 입력, MFK를 입력한 후 복호화 클릭.',
        '선택적으로 KCV 체크를 활성화하여 예상 KCV 입력, 패리티 필터 설정.',
        '결과 표시: AKB, 헤더, 복호화 키, KCV, 패리티.',
      ],
    },
    safenetKeys: {
      title: 'SafeNet 키 암호화/복호화 온라인 - HSM 키 변형 도구 | HSM Kit',
      description: '무료 온라인 SafeNet HSM 키 암호화/복호화 도구. KM 키와 키 형식 및 변형 옵션을 사용하여 키를 암호화/복호화. DPK, PPK, MPK, KPK 변형 지원. 키 조회로 KCV 매칭을 통해 올바른 변형을 찾습니다. 안전한 브라우저 처리.',
      keywords: 'SafeNet HSM, 키 암호화, 키 복호화, KM 키, 키 변형, DPK, PPK, MPK, KPK, HSM 도구, 결제 보안, 키 관리, KCV 검증, 3DES 암호화, 키 조회, SafeNet 키 관리',
      faqTitle: 'SafeNet 키 FAQ',
      usageTitle: 'SafeNet 키 도구 사용 방법',
      faqs: [
        { question: 'SafeNet 키 암호화란?', answer: 'SafeNet HSM은 특정 키 암호화 방법을 사용하며, 키는 키 관리 키(KM Key)의 변형을 사용하여 암호화됩니다. 변형은 키 용도 유형(DPK, PPK, MPK 등)에 의해 결정됩니다.' },
        { question: '키 형식이란?', answer: '키 형식은 암호화 방법과 키 길이를 정의: 00=평문, 10/20=싱글 DES, 11/21=더블 DES3, 12/22=트리플 DES3. 형식 1x는 ECB 모드, 2x는 CBC 모드 사용.' },
        { question: '변형이란?', answer: '변형은 키 용도를 결정: 00=DPK(데이터 보호), 01=PPK(PIN 보호), 02=MPK(MAC 보호), 03=KPK(키 보호), 04=KTK(키 전송), 05=KEK(키 암호화). 각 변형은 KM 키와 특정 마스크를 XOR합니다.' },
        { question: 'KM 키란?', answer: 'KM 키(키 관리 키)는 SafeNet HSM에서 사용되는 마스터 키입니다. 일반적으로 더블 길이 3DES 키(32자 16진수)입니다. KM 키는 변형 마스크와 XOR되어 암호화 키를 생성합니다.' },
        { question: '키 조회란?', answer: '키 조회는 모든 변형(DPK, PPK, MPK 등)을 시도하여 암호화 키를 복호화합니다. KCV와 패리티로 결과를 필터링하여 암호화에 사용된 정확한 변형을 찾을 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 평문 키를 입력하고 키 형식과 변형을 선택, KM 키를 입력하고 암호화 클릭.',
        '키 복호화: 암호화 키를 입력하고 키 형식과 변형을 선택, KM 키를 입력하고 복호화 클릭.',
        '결과 표시: 평문/암호화 키, KCV, 패리티, 키 형식, 변형, 변형 키, 출력.',
        '키 조회: 암호화 키를 입력하고 선택적으로 KCV 필터와 패리티 필터를 설정.',
        'KM 키를 입력하고 조회를 클릭하여 모든 변형을 시도하고 일치하는 복호화를 검색.',
        '결과는 복호화 키, KCV, 패리티와 함께 모든 일치하는 변형을 표시.',
      ],
    },
    thalesKeys: {
      title: 'Thales 키 (LMK) 온라인 - HSM 키 암호화/복호화 도구 | HSM Kit',
      description: '무료 온라인 Thales HSM 키 암호화/복호화 도구. LMK(로컬 마스터 키)와 키 스킴 및 변형 옵션을 사용하여 키를 암호화/복호화. 다양한 LMK 쌍과 변형 마스크 지원. 키 조회로 일치하는 복호화를 검색. 100% 클라이언트 측 처리.',
      keywords: 'Thales HSM, LMK, 로컬 마스터 키, 키 암호화, 키 복호화, 키 스킴, 키 변형, LMK 쌍, HSM 도구, 결제 보안, 키 관리, KCV 검증, 3DES 암호화, 키 조회, Thales 키 관리',
      faqTitle: 'Thales 키 (LMK) FAQ',
      usageTitle: 'Thales 키 도구 사용 방법',
      faqs: [
        { question: 'Thales 키 암호화란?', answer: 'Thales HSM은 LMK(로컬 마스터 키) 기반 암호화를 사용하며, 키는 LMK 쌍의 변형을 사용하여 암호화됩니다. 변형은 LMK에 적용되는 XOR 마스크에 의해 결정됩니다.' },
        { question: '키 스킴이란?', answer: '키 스킴은 키 길이와 형식을 정의: 0=평문, U=싱글 길이 ECB, T=더블 길이 ECB, X=트리플 길이 ECB, Y=더블 길이 변형, Z=트리플 길이 변형. 스킴 접두사가 암호화 키에 추가됩니다.' },
        { question: 'LMK 쌍이란?', answer: 'LMK 쌍은 다른 목적으로 사용되는 마스터 키 쌍: 00-01은 ZMK/ZPK/TMK/TPK용, 02-03은 PVK/CVK/BDK용, 04-05는 TAK용, 14-15는 ZEK/DEK용 등. 각 쌍은 특정 유형의 키를 암호화합니다.' },
        { question: '변형이란?', answer: '변형(0-8)은 LMK에 적용되는 XOR 마스크를 결정: 0=변형 없음, 1=A6, 2=5A, 3=6A, 4=DE, 5=2B, 6=50, 7=74, 8=9C. 마스크는 LMK의 각 8바이트 블록과 XOR됩니다.' },
        { question: 'LMK 크기란?', answer: 'LMK 크기는 LMK의 길이를 결정: 더블(16바이트/32자 16진수) 또는 트리플(24바이트/48자 16진수). 대부분의 Thales HSM은 3DES 암호화를 위해 트리플 길이로 확장된 더블 길이 LMK를 사용합니다.' },
        { question: '키 조회란?', answer: '키 조회는 모든 변형을 시도하여 암호화 키를 복호화합니다. KCV(키 체크 값)와 패리티 유형(홀수/짝수)으로 결과를 필터링하여 암호화에 사용된 정확한 변형을 찾을 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 평문 키를 입력하고 키 스킴, LMK 크기, LMK 쌍을 선택, LMK 키를 입력, 변형을 선택하고 암호화 클릭.',
        '키 복호화: 암호화 키(스킴 접두사 유무)를 입력, LMK 설정을 구성하고 복호화 클릭.',
        '결과 표시: 평문/암호화 키, KCV, 패리티, 키 스킴, LMK 쌍, 변형, 출력.',
        '키 조회: 암호화 키를 입력하고 선택적으로 KCV 필터와 패리티 필터를 설정.',
        '조회를 클릭하여 모든 변형을 시도하고 일치하는 복호화를 검색.',
        '결과는 복호화 키, KCV, 패리티와 함께 모든 일치하는 변형을 표시.',
      ],
    },
    thalesKeyBlock: {
      title: 'Thales 키 블록 온라인 - 전용 키 블록 인코딩/디코딩 | HSM Kit',
      description: '무료 온라인 Thales 키 블록 인코더 및 디코더. KBPK(키 블록 보호 키)를 사용하여 Thales 전용 키 블록을 인코딩/디코딩. 3DES/AES KBPK, 다양한 키 용도, 알고리즘, 내보내기 가능성 옵션 지원. 모든 처리는 브라우저에서 실행.',
      keywords: 'Thales 키 블록, KBPK, 키 블록 보호 키, 키 블록 인코더, 키 블록 디코더, HSM 도구, 결제 보안, 키 관리, 3DES, AES, 키 용도, 내보내기 가능성, Thales 키 블록 형식',
      faqTitle: 'Thales 키 블록 FAQ',
      usageTitle: 'Thales 키 블록 도구 사용 방법',
      faqs: [
        { question: 'Thales 키 블록이란?', answer: 'Thales 키 블록은 Thales HSM이 사용하는 전용 키 블록 형식으로, 암호화 키를 안전하게 래핑하고 전송합니다. 용도, 알고리즘, 내보내기 가능성과 같은 메타데이터를 포함합니다.' },
        { question: 'KBPK란?', answer: 'KBPK(키 블록 보호 키)는 키 블록을 암호화/복호화하는 마스터 키입니다. 3DES KBPK는 24바이트(48자 16진수), AES KBPK는 32바이트(64자 16진수)입니다.' },
        { question: '키 용도란?', answer: '키 용도(2자)는 래핑된 키의 사용 방법을 정의: B0=BDK, C0=CVK, D0=데이터 암호화, K0=키 암호화, M0-M8=MAC 키, P0=PIN 암호화 등.' },
        { question: '알고리즘이란?', answer: '알고리즘(1자)은 암호화 알고리즘을 지정: A=AES, D=DES, T=트리플 DES, R=RSA, E=타원 곡선, H=HMAC.' },
        { question: '사용 모드란?', answer: '사용 모드는 허용되는 작업을 정의: B=암호화/복호화, C=생성/검증, D=복호화만, E=암호화만, G=생성만, N=제한 없음, X=키 파생.' },
        { question: '내보내기 가능성이란?', answer: '내보내기 가능성은 키 내보내기를 제어: E=신뢰할 수 있는 키 블록에서 내보내기 가능, N=내보내기 불가, S=민감(제한된 내보내기).' },
      ],
      usage: [
        '인코딩: KBPK(3DES 또는 AES), 평문 키를 입력하고 버전, 키 용도, 알고리즘, 사용 모드, 내보내기 가능성을 선택하고 인코딩 클릭.',
        '인코딩된 키 블록에는 헤더 메타데이터 + 암호화 키 + 무결성을 위한 MAC이 포함됩니다.',
        '디코딩: KBPK를 입력하고 키 블록 데이터를 붙여넣기, ASCII 또는 16진수 형식을 선택하고 디코딩 클릭.',
        '디코딩 결과는 모든 헤더 필드, 복호화 키, KCV, MAC을 표시.',
      ],
    },
    uuid: {
      title: 'UUID 생성기 온라인 - 버전 1, 3, 4, 5 | HSM Kit',
      description: '무료 온라인 UUID 생성기. 버전 1(시간 기반), 3(MD5), 4(랜덤), 5(SHA-1) 지원. 애플리케이션용 단일 또는 배치 UUID 생성. 암호학적으로 안전한 난수 생성.',
      keywords: 'UUID 생성기, GUID 생성기, UUID v4, UUID v1, 랜덤 UUID, 고유 식별자, UUID 온라인, 배치 UUID 생성기, 고유 ID 생성기, GUID 생성기 온라인',
      faqTitle: 'UUID 생성기 FAQ',
      usageTitle: 'UUID 생성기 사용 방법',
      faqs: [
        { question: 'UUID란?', answer: 'UUID(범용 고유 식별자)는 시간과 공간에서 고유한 128비트 식별자입니다.' },
        { question: '어떤 UUID 버전을 사용해야 하나요?', answer: '버전 4(랜덤)가 가장 일반적이고 권장됩니다.' },
        { question: 'UUID와 GUID의 차이점은?', answer: 'UUID와 GUID(전역 고유 식별자)는 동일합니다. GUID는 Microsoft의 용어이고, UUID는 표준(RFC 4122)의 용어입니다. 동일한 형식, 동일한 목적입니다.' },
        { question: 'UUID는 정말 고유한가요?', answer: 'UUID v4의 충돌 확률은 약 2^122분의 1로, 10억 개를 생성해도 중복 확률이 극히 낮습니다. 실용적으로 고유하다고 봐도 안전합니다.' },
      ],
      usage: ['UUID 버전 선택', '생성 개수 입력', '"생성" 클릭'],
    },
    sslCert: {
      title: 'SSL 인증서 (X509) - 키 생성, CSR, 자체 서명 인증서 | HSM Kit',
      description: '무료 온라인 SSL 인증서 도구. 암호화된 개인 키로 RSA 키 쌍 생성, 인증서 서명 요청(CSR) 생성, 자체 서명 X.509 인증서 생성, 인증서 분석. 모든 처리는 브라우저에서 클라이언트 측으로 수행. 100% 안전.',
      keywords: 'SSL 인증서, X509, CSR 생성기, 자체 서명 인증서, RSA 키 생성기, 인증서 파서, PEM, PKI 도구, 인증서 서명 요청, X.509 인증서, SSL 도구, 인증서 생성기, TLS 인증서, HTTPS 인증서',
      faqTitle: 'SSL 인증서 FAQ',
      usageTitle: 'SSL 인증서 도구 사용 방법',
      faqs: [
        { question: 'X.509 인증서란?', answer: 'X.509는 공개 키 인증서의 표준 형식으로, 보안 웹 연결을 위한 TLS/SSL, 이메일 서명(S/MIME), 코드 서명 및 기타 PKI 응용 프로그램에 사용됩니다.' },
        { question: 'CSR(인증서 서명 요청)이란?', answer: 'CSR은 인증서를 요청하기 위해 인증 기관(CA)에 보내는 메시지입니다. 인증서에 포함될 공개 키와 주체 정보(조직, 도메인 이름 등)를 포함합니다.' },
        { question: '자체 서명 인증서란?', answer: '자체 서명 인증서는 CA가 아닌 자체 개인 키로 서명된 인증서입니다. 테스트, 개발 또는 내부 사용에 유용하지만 신뢰할 수 있는 CA에서 확인되지 않았기 때문에 브라우저에서 경고를 표시합니다.' },
        { question: '왜 개인 키에 암호 문구가 필요한가요?', answer: '암호 문구는 3DES를 사용하여 개인 키를 암호화합니다. 파일이 손상된 경우에도 키를 보호합니다. 올바른 암호 문구 없이는 개인 키를 사용할 수 없습니다.' },
        { question: '어떤 키 길이를 사용해야 하나요?', answer: 'RSA 키의 경우 2048비트가 보안의 최소 권장 사항입니다. 4096비트는 더 강력한 보안을 제공하지만 더 느립니다. 3072비트는 보안과 성능 사이의 좋은 균형입니다.' },
      ],
      usage: [
        '키 탭: 암호화된 개인 키로 RSA 키 쌍 생성. 키 길이와 암호 문구 설정.',
        'CSR 탭: 인증서 서명 요청 생성. 개인 키를 붙여넣고 주체 세부 정보를 입력하여 CSR 생성.',
        'CSR 읽기 탭: 기존 CSR을 분석하여 주체 정보와 공개 키 표시.',
        '자체 서명 인증서 탭: 테스트용 자체 서명 인증서 생성. 유효 기간, 일련 번호, 주체 세부 정보 설정.',
        '인증서 읽기 탭: X.509 인증서를 분석하여 발급자, 주체, 유효 기간, 확장, 공개 키 표시.',
      ],
    },
  },
};
