// Korean translations
export default {
  common: {
    copy: '복사',
    generate: '생성',
    calculate: '계산',
    parse: '구문 분석',
    copied: '클립보드에 복사되었습니다!',
    error: '오류',
    result: '결과',
    loading: '로딩 중...',
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: '키 생성',
    tr31: 'TR-31',
    kcv: 'KCV 계산',
    pinBlock: 'PIN 블록',
    asn1: 'ASN.1',
    cipher: '암호화',
  },
  
  footer: {
    copyright: 'HSMKit.com ©2025 | 안전한 클라이언트 측 계산',
  },

  home: {
    heroTitle: '무료 온라인 암호화 및 키 관리 도구',
    heroDescription: '보안 전문가를 위한 종합 암호화 도구 모음입니다. 모든 계산은 브라우저에서 클라이언트 측에서 수행되며, 데이터가 기기를 떠나지 않습니다.',
    availableTools: '사용 가능한 도구',
    whyChoose: '왜 HSM Kit를 선택해야 할까요?',
    tools: {
      asn1: {
        title: 'ASN.1 파서',
        description: 'ASN.1 DER/BER 구조를 분석하고 X.509 인증서 및 PKCS 형식을 디코딩합니다.',
      },
      aes: {
        title: 'AES 암호화',
        description: 'AES-128/192/256으로 데이터를 암호화/복호화. ECB, CBC, CFB, OFB, CTR 모드 지원.',
      },
      des: {
        title: 'DES/3DES 암호화',
        description: '레거시 시스템을 위한 다양한 패딩 옵션이 있는 DES 및 Triple DES 암호화.',
      },
      rsa: {
        title: 'RSA 암호화',
        description: 'RSA 비대칭 암호화, 복호화, 디지털 서명 및 검증.',
      },
      ecc: {
        title: 'ECC/ECDSA',
        description: '컴팩트한 키와 효율적인 디지털 서명을 위한 타원 곡선 암호화.',
      },
      fpe: {
        title: '형식 보존 암호화',
        description: 'FPE (FF1/FF3-1)로 형식과 길이를 보존하면서 데이터를 암호화.',
      },
      keyGenerator: {
        title: '키 생성기',
        description: 'AES, DES, 3DES용 보안 랜덤 키 생성. 키 조합 및 패리티 도구.',
      },
      tr31: {
        title: 'TR-31 키 블록',
        description: '결제 산업에서 사용되는 TR-31/ANSI X9.143 키 블록을 분석.',
      },
      kcv: {
        title: 'KCV 계산기',
        description: 'AES 및 DES/3DES 키의 키 검증값(KCV) 계산.',
      },
      pinBlock: {
        title: 'PIN 블록 생성기',
        description: '결제 거래용 ISO 9564 PIN 블록 (형식 0, 1, 3, 4) 생성.',
      },
    },
    features: {
      clientSide: {
        title: '100% 클라이언트 측',
        description: '모든 암호화 작업이 브라우저에서 완전히 실행됩니다. 데이터가 서버로 전송되지 않습니다.',
      },
      free: {
        title: '완전 무료',
        description: '모든 도구는 등록, 로그인 또는 결제 없이 무료로 사용할 수 있습니다. 숨겨진 비용이 없습니다.',
      },
      paymentReady: {
        title: '결제 산업 대응',
        description: 'TR-31, KCV, PIN 블록 및 기타 결제 보안 작업을 위한 전문 도구.',
      },
    },
  },
  
  asn1: {
    title: 'ASN.1 파서',
    description: 'ASN.1 DER/BER 구조를 구문 분석 및 분석하고 RFC 정의 매칭 지원',
    inputLabel: '입력 (Hex, Base64, 또는 PEM):',
    inputPlaceholder: 'hex, base64 또는 PEM 인코딩된 ASN.1 BER/DER 구조를 붙여넣거나 파일 업로드',
    withHexDump: 'Hex Dump 표시',
    trimBigChunks: '큰 데이터 간소화',
    withDefinitions: '정의 매칭 활성화',
    uploadFile: '파일 업로드',
    parse: '구문 분석',
    clear: '지우기',
    structureDefinition: '구조 정의:',
    selectDefinition: '구조 정의 선택...',
    parsedResult: '구문 분석 결과:',
    hexDump: 'Hex Dump:',
    offset: '오프셋',
    length: '길이',
    value: '값',
    constructed: '구조 타입',
    loadError: 'ASN.1 파싱 라이브러리 로드 실패',
    inputRequired: 'ASN.1 데이터를 입력하세요',
    parseError: '구문 분석 실패',
    copied: '복사됨',
    copyHex: 'Hex 복사',
    copyHexDump: 'Hex Dump 복사',
    copyBase64: 'Base64 복사',
    copySubtree: '하위 트리 복사',
    copyValue: '값 복사',
  },
  
  keyGenerator: {
    title: '랜덤 키 생성기',
    description: 'DES, 3DES 또는 AES용 암호학적으로 강력한 랜덤 키를 생성합니다.',
    keyLength: '키 길이',
    bytes: '바이트',
    bits: '비트',
    generateNow: '지금 생성',
    generatedKey: '생성된 키 (16진수)',
    kcv: 'KCV',
    length: '길이',
    tabKeyGen: '키 생성',
    tabCombination: '키 조합',
    tabParity: '패리티 조정',
    tabValidation: '키 검증',
    combinationTitle: '키 컴포넌트 조합',
    combinationDesc: '여러 키 컴포넌트를 XOR로 조합',
    component: '컴포넌트',
    components: '개 컴포넌트',
    combinedKey: '조합된 키',
    addComponent: '추가',
    removeComponent: '제거',
    combineKeys: '조합',
    errorInvalidComponent: '컴포넌트 {index} 무효',
    errorComponentLength: '모든 컴포넌트의 길이가 같아야 합니다',
    errorComponentLength2: '길이는 다음 중 하나여야 합니다',
    errorMinComponents: '최소 2개의 컴포넌트 필요',
    errorMaxComponents: '최대 9개 컴포넌트까지 가능',
    clearAll: '모두 지우기',
    parityTitle: '패리티 조정',
    parityDesc: 'DES/3DES 키의 패리티 비트 조정',
    keyInput: '키 입력',
    keyInputPlaceholder: '16진수 키 입력',
    parityType: '패리티 유형',
    odd: '홀수',
    even: '짝수',
    adjustParity: '조정',
    adjustedKey: '조정된 키',
    validationTitle: '키 유효성 검사',
    validationDesc: '형식, 길이 및 패리티 확인',
    validateKey: '검증',
    validKey: '유효한 키',
    invalidKey: '무효한 키',
    keyType: '키 유형',
    parityStatus: '패리티 상태',
    parityValid: '유효',
    parityInvalid: '무효',
  },
  
  kcvCalculator: {
    title: 'KCV 계산기',
    description: '키 확인 값을 계산하여 키의 정확성을 검증합니다.',
    algorithm: '알고리즘',
    keyInput: '키 (16진수)',
    keyPlaceholder: '예: 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'KCV 계산',
    keyCheckValue: '키 확인 값',
    errorInvalidHex: '키는 유효한 16진수 문자여야 합니다',
    errorDesLength: 'DES/3DES 키 길이는 8, 16 또는 24바이트여야 합니다',
    errorAesLength: 'AES 키 길이는 16, 24 또는 32바이트여야 합니다',
    errorCalculation: '계산에 실패했습니다. 키 형식을 확인하세요',
    format: '형식',
    autoAdjustParity: '패리티 비트 자동 조정',
    parityAdjustmentHint: '일부 키에는 올바른 패리티 비트가 설정되어 있지 않을 수 있습니다. 이 옵션을 선택하면 자동으로 수정됩니다',
    kcvCalcTitle: '키 확인 값 계산',
    desCalcDesc: '키의 평문을 사용하여 16자 길이의 \'0\'을 3DES-ECB 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
    aesCalcDesc: '키의 평문을 사용하여 32자 길이의 \'0\'을 CMAC-AES 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
  },
  
  pinBlock: {
    title: 'PIN 블록 생성기',
    description: '결제 거래용 ISO 형식 PIN 블록을 생성합니다.',
    format: 'PIN 블록 형식',
    pinLabel: 'PIN (4-12자리)',
    pinPlaceholder: '예: 1234',
    panLabel: 'PAN (기본 계좌 번호)',
    panPlaceholder: '예: 4111111111111111',
    generatePinBlock: 'PIN 블록 생성',
    pinBlockHex: 'PIN 블록 (16진수)',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidPan: 'PAN은 13-19자리 숫자여야 합니다',
    errorGeneration: '생성에 실패했습니다. 입력을 확인하세요',
    errorFormat1: 'ISO Format 1은 곧 출시됩니다...',
    pinLengthHint: '4-12자리 PIN 지원',
    panHint: '전체 카드 번호를 입력하세요 (13-19자리), 시스템이 자동으로 오른쪽 12자리를 추출합니다 (체크 디지트 제외)',
  },
  
  tr31: {
    title: 'TR-31 키 블록 분석기',
    description: 'TR-31 형식 키 블록을 구문 분석하고 분석합니다 (ANSI X9.143 표준).',
    keyBlock: 'TR-31 키 블록',
    keyBlockPlaceholder: '예: B0112P0TE00N0000...',
    parseKeyBlock: '키 블록 구문 분석',
    header: '키 블록 헤더',
    version: '버전',
    keyLength: '길이',
    keyUsage: '키 용도',
    mode: '모드',
    keyVersion: '키 버전',
    exportability: '내보내기 가능성',
    characters: '문자',
    errorTooShort: 'TR-31 키 블록 길이가 부족합니다',
    errorParsing: '구문 분석에 실패했습니다. TR-31 형식을 확인하세요',
    exportable: '내보내기 가능',
    nonExportable: '내보내기 불가',
    sensitive: '민감함',
    keyBlockFormatHint: 'TR-31 키 블록 형식 (예: B0112P0TE00N...), 시스템이 자동으로 형식을 검증합니다',
  },
  
  placeholder: {
    title: '출시 예정',
    description: '이 도구는 개발 중입니다. 기대해 주세요!',
  },

  cipher: {
    title: 'AES 암호화/복호화',
    description: 'AES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    aesInfo: 'AES 정보',
    keyLengthInfo: '키 길이는 선택한 알고리즘과 일치해야 합니다',
    ivInfo: 'IV(초기화 벡터)는 16바이트여야 합니다',
    paddingInfo: 'PKCS7 패딩 사용',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB/KCV 모드에서는 IV가 필요하지 않습니다',
    kcvInfo: 'KCV: 0을 암호화하고 처음 6개의 16진수 문자를 가져옴',
    calculateKcv: 'KCV 계산',
    noPaddingInfo: '패딩 없음 - 데이터 길이는 16바이트의 배수여야 합니다',
    errorDataLength: '데이터 길이는 16바이트의 배수여야 합니다',
    kcvNoDataNeeded: 'KCV 계산에는 데이터 입력이 필요하지 않습니다',
    kcvDataHint: 'KCV는 0을 사용하여 계산되므로 데이터 입력이 필요하지 않습니다',
    errorKcvCalculation: 'KCV 계산 실패',
    kcvResult: 'KCV 결과',
  },

  des: {
    title: 'DES / 3DES 암호화/복호화',
    description: 'DES 또는 3DES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    padding: '패딩',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    desInfo: 'DES/3DES 정보',
    keyLengthInfoDes: 'DES에는 8바이트(64비트) 키가 필요합니다',
    keyLengthInfo3Des: '3DES에는 16 또는 24바이트 키가 필요합니다',
    ivInfo: 'IV(초기화 벡터)는 8바이트여야 합니다',
    blockSizeInfo: '블록 크기는 8바이트입니다',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLengthDes: 'DES 키 길이는 8바이트여야 합니다',
    errorKeyLength3Des: '3DES 키 길이는 16 또는 24바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorDataLength: '패딩 없음 사용 시 데이터 길이는 8바이트의 배수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB 모드에서는 IV가 필요하지 않습니다',
    paddingNone: '패딩 없음',
    paddingZeros: '0x00으로 채움',
    paddingSpaces: '공백 0x20으로 채움',
    paddingANSIX923: '마지막 바이트는 패딩 길이, 나머지는 0x00으로 채움',
    paddingISO10126: '마지막 바이트는 패딩 길이, 나머지는 랜덤 바이트로 채움',
    paddingPKCS5: '각 패딩 바이트 값은 패딩 길이와 같음',
    paddingPKCS7: 'PKCS#5와 동일',
    paddingISO7816: '0x80을 추가한 후 0x00으로 채움',
    paddingRijndael: 'Zero 패딩과 동일',
    paddingISO9797M1: '0x00으로 블록 크기까지 채움',
    paddingISO9797M2: 'ISO 7816-4와 동일',
    mode8BitNote: '참고: 8비트 모드는 한 번에 1바이트를 처리합니다',
    mode64BitNote: '64비트 모드는 한 번에 전체 블록(8바이트)을 처리합니다',
  },

  rsa: {
    title: 'RSA 암호화/복호화',
    description: 'RSA 비대칭 암호화, 복호화, 서명 및 검증',
    tabKeys: '키',
    tabEncrypt: '암호화',
    tabDecrypt: '복호화',
    tabSign: '서명',
    tabVerify: '검증',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA 모듈러스 (16진수)',
    privateExpPlaceholder: 'RSA 개인 지수 (16진수)',
    keyLength: '키 길이',
    generateKeys: '키 생성',
    importKeys: '키 가져오기',
    clearKeys: '지우기',
    keyGenerated: '키 쌍이 성공적으로 생성되었습니다',
    keysCleared: '키가 지워졌습니다',
    keyImported: '공개 키가 성공적으로 가져왔습니다',
    privateKeyImportNote: '개인 키 가져오기에는 전체 CRT 매개변수가 필요합니다. 전체 기능을 사용하려면 "키 생성"을 사용하세요.',
    padding: '패딩',
    hashAlgorithm: '해시 알고리즘',
    data: '데이터',
    dataToEncrypt: '암호화할 데이터',
    dataPlaceholderAscii: '텍스트 데이터 입력',
    encodingMethod: '인코딩 방법',
    private: '개인',
    public: '공개',
    inputDataFormat: '입력 데이터 형식',
    hexadecimal: '16진수',
    paddingMethod: '패딩 방법',
    noPadding: '패딩 없음',
    errorDataRequired: '데이터가 필요합니다',
    privateEncryptNote: '참고: 암호화 데모에 공개 키 사용',
    dataToSign: '서명할 데이터',
    dataToVerify: '검증할 데이터',
    ciphertextToDecrypt: '복호화할 암호문',
    signatureToVerify: '서명',
    dataPlaceholder: '16진수 데이터 입력',
    ciphertextPlaceholder: '암호화된 16진수 데이터 입력',
    signaturePlaceholder: '16진수 서명 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    sign: '서명',
    verify: '검증',
    encryptedResult: '암호화 결과',
    encryptionFinished: '데이터 암호화 작업 완료',
    decryptionFinished: '데이터 복호화 작업 완료',
    decodingMethod: '디코딩 방법',
    copyResult: '결과 복사',
    result: '결과',
    decryptedResult: '복호화 결과',
    signatureResult: '서명',
    signatureValid: '✓ 서명이 유효합니다',
    signatureInvalid: '✗ 서명이 유효하지 않습니다',
    encryptInfo: 'RSA 암호화',
    encryptDesc: '공개 키로 데이터 암호화',
    decryptInfo: 'RSA 복호화',
    decryptDesc: '개인 키로 데이터 복호화',
    signInfo: 'RSA 서명',
    signDesc: '개인 키로 데이터 서명 (RSA-PSS)',
    verifyInfo: 'RSA 서명 검증',
    verifyDesc: '공개 키로 서명 검증 (RSA-PSS)',
    oaepDesc1: 'OAEP는 RSA 암호화에 사용되는 패딩 체계입니다',
    oaepDesc2: 'PKCS#1 v1.5 패딩보다 더 안전합니다',
    oaepDesc3: '선택된 암호문 공격을 방지합니다',
    oaepDesc4: '새로운 애플리케이션에 권장됩니다',
    oaepStructure: 'OAEP 구조',
    maxDataSize: '최대 데이터 크기',
    errorKeyGen: '키 생성 실패',
    errorKeyImport: '키 가져오기 실패',
    errorInvalidModulus: '유효하지 않은 모듈러스',
    errorInvalidPublicExp: '유효하지 않은 공개 지수',
    errorNoPublicKey: '먼저 공개 키를 생성하거나 가져오세요',
    errorNoPrivateKey: '먼저 키 쌍을 생성하세요 (개인 키 필요)',
    errorInvalidData: '유효하지 않은 데이터 (16진수여야 함)',
    errorInvalidCiphertext: '유효하지 않은 암호문 (16진수여야 함)',
    errorInvalidSignature: '유효하지 않은 서명 (16진수여야 함)',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorSign: '서명 실패',
    errorVerify: '검증 실패',
  },

  fpe: {
    title: '형식 보존 암호화',
    description: '형식과 길이를 유지하면서 데이터 암호화 (NIST SP 800-38G)',
    radix: '기수',
    encryptionType: '암호화 유형',
    keyInput: '키 입력',
    useTweak: 'Tweak 사용?',
    fpeInfo: 'FPE 정보',
    formatPreserving: '형식 보존: 출력이 입력과 동일한 형식과 길이를 가짐',
    radixInfo: '현재 기수가 데이터의 유효한 문자 집합을 정의합니다',
    tweakInfo: 'Tweak은 암호화에 추가 입력을 제공합니다 (IV와 유사)',
    minLength: '최소 데이터 길이: 2자',
    dataPlaceholder: '유효한 기수 문자로 데이터 입력',
    tweakPlaceholderFF1: 'Tweak을 16진수로 입력 (임의의 길이)',
    tweakPlaceholderFF3: '16자리 16진수 문자 (8바이트)',
    resultLength: '길이',
    characters: '문자',
    algorithm: '알고리즘',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorDataTooShort: '데이터는 최소 2자여야 합니다',
    errorInvalidDataForRadix: '데이터에 기수 {radix}의 유효하지 않은 문자가 포함되어 있습니다',
    errorInvalidTweakHex: 'Tweak은 유효한 16진수여야 합니다',
    errorTweakLength: '{algorithm}의 Tweak 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    algorithmNotImplemented: '이 알고리즘은 아직 완전히 구현되지 않았습니다',
  },

  // SEO Content
  seo: {
    home: {
      title: 'HSM Kit - 무료 온라인 암호화 및 키 관리 도구',
      description: 'HSM 키 관리를 위한 무료 온라인 암호화 도구. KCV 계산, TR-31 키 블록 파싱, 안전한 키 생성, AES/DES/RSA 암호화 등. 모든 계산은 브라우저에서 실행되어 최고의 보안을 보장합니다.',
      keywords: 'HSM 도구, 암호화 도구키트, 키 관리, KCV 계산기, TR-31 파서, AES 암호화, DES 암호화, RSA 암호화, PIN 블록, 키 생성기, 암호화 도구, 결제 보안',
      faqTitle: '자주 묻는 질문',
      usageTitle: 'HSM Kit 소개',
      faqs: [
        { question: 'HSM Kit은 무료인가요?', answer: '네, HSM Kit은 완전 무료입니다. 등록이나 결제 없이 모든 도구를 사용할 수 있습니다.' },
        { question: '데이터는 안전한가요?', answer: '물론입니다. 모든 암호화 작업은 브라우저(클라이언트 측)에서 완전히 실행됩니다. 데이터가 서버로 전송되는 일은 절대 없습니다.' },
        { question: '어떤 암호화 알고리즘이 지원되나요?', answer: 'HSM Kit은 AES(128/192/256비트), DES, 3DES, RSA, ECC(ECDSA), 형식 보존 암호화(FPE)를 지원합니다.' },
        { question: '결제 보안에 사용할 수 있나요?', answer: '네, HSM Kit에는 PIN 블록 생성, TR-31 키 블록 파싱, KCV 계산 등 결제 보안을 위해 설계된 도구가 포함되어 있습니다.' },
      ],
      usage: [
        'HSM Kit은 보안 전문가, 개발자 및 암호화 작업을 하는 모든 사람을 위해 설계된 포괄적인 암호화 도구 모음입니다.',
        '모든 도구는 브라우저에서 완전히 작동합니다. 서버 통신이 없으므로 민감한 데이터가 장치를 벗어나지 않습니다.',
        '암호화 및 결제 보안 분야의 테스트, 개발 및 교육 목적에 완벽합니다.',
      ],
    },
    asn1: {
      title: 'ASN.1 파서 온라인 - 무료 DER/BER 구조 디코더 | HSM Kit',
      description: '무료 온라인 ASN.1 파서 및 디코더. ASN.1 DER/BER 구조 파싱, X.509 인증서 디코딩, PKCS 형식 분석. 16진수, Base64, PEM 입력 지원 및 RFC 정의 매칭.',
      keywords: 'ASN.1 파서, DER 디코더, BER 디코더, X.509 인증서 파서, PKCS 디코더, ASN1 온라인 도구, 인증서 분석기, PEM 파서',
      faqTitle: 'ASN.1 파서 FAQ',
      usageTitle: 'ASN.1 파서 사용 방법',
      faqs: [
        { question: 'ASN.1이란 무엇인가요?', answer: 'ASN.1(Abstract Syntax Notation One)은 직렬화 및 역직렬화 가능한 데이터 구조를 정의하기 위한 표준 인터페이스 설명 언어입니다. 암호화, 통신, 네트워크 프로토콜에서 널리 사용됩니다.' },
        { question: '이 파서는 어떤 형식을 지원하나요?', answer: '이 파서는 DER(Distinguished Encoding Rules) 및 BER(Basic Encoding Rules)로 인코딩된 ASN.1 구조를 지원합니다. 16진수, Base64 또는 PEM 형식으로 데이터를 입력할 수 있습니다.' },
        { question: 'X.509 인증서를 파싱할 수 있나요?', answer: '네, 이 도구는 X.509 인증서, CSR, PKCS#7/8/12 구조 및 ASN.1 인코딩을 사용하는 기타 인증서 형식을 파싱할 수 있습니다.' },
        { question: '16진수 덤프 기능이란 무엇인가요?', answer: '16진수 덤프 기능은 파싱된 트리 뷰 옆에 ASN.1 구조의 원시 바이트를 표시하여 바이너리 인코딩의 이해를 돕습니다.' },
      ],
      usage: [
        'ASN.1 인코딩 데이터를 16진수, Base64 또는 PEM 형식으로 입력 필드에 붙여넣습니다.',
        '"파싱"을 클릭하여 구조를 디코딩하고 계층적 트리 표현을 봅니다.',
        '"16진수 덤프 포함"을 활성화하면 파싱된 구조 옆에 원시 바이트를 볼 수 있습니다.',
        '"정의 포함"을 사용하여 X.509, PKCS 등 알려진 RFC 정의와 구조를 매칭합니다.',
      ],
    },
    aes: {
      title: 'AES 암호화/복호화 온라인 - 무료 AES 계산기 | HSM Kit',
      description: '무료 온라인 AES 암호화 및 복호화 도구. ECB, CBC, CFB, OFB, CTR 모드로 AES-128, AES-192, AES-256 지원. KCV 계산, 브라우저에서 안전하게 16진수 또는 텍스트 데이터 암호화/복호화.',
      keywords: 'AES 암호화, AES 복호화, AES-128, AES-192, AES-256, AES 계산기, AES 온라인 도구, AES ECB, AES CBC, AES KCV',
      faqTitle: 'AES 암호화 FAQ',
      usageTitle: 'AES 암호화 도구 사용 방법',
      faqs: [
        { question: 'AES 암호화란 무엇인가요?', answer: 'AES(Advanced Encryption Standard)는 전 세계 표준이 된 대칭 블록 암호입니다. 128, 192 또는 256비트 키를 사용하여 128비트 블록 단위로 데이터를 암호화합니다.' },
        { question: '어떤 AES 모드를 사용해야 하나요?', answer: 'CBC 모드는 대부분의 응용 프로그램에서 일반적으로 권장됩니다. ECB 모드는 한 블록보다 큰 데이터 암호화에는 패턴이 드러나므로 피해야 합니다. CTR 모드는 스트리밍 데이터에 적합합니다.' },
        { question: 'AES가 지원하는 키 크기는?', answer: 'AES는 세 가지 키 크기를 지원합니다: AES-128(16바이트), AES-192(24바이트), AES-256(32바이트). 키가 길수록 보안이 강화됩니다.' },
        { question: 'AES 암호화에서 IV란 무엇인가요?', answer: 'IV(초기화 벡터)는 CBC, CFB, OFB, CTR 등의 모드에서 사용되는 랜덤 값으로, 동일한 평문이 다른 암호문을 생성하도록 보장합니다. IV는 고유해야 하지만 비밀일 필요는 없습니다.' },
      ],
      usage: [
        'AES 키 크기(128, 192 또는 256비트)와 암호화 모드(ECB, CBC 등)를 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'ECB 이외의 모드에서는 IV(16바이트 16진수)를 제공합니다.',
        '암호화 또는 복호화할 데이터를 입력하고 해당 버튼을 클릭합니다.',
      ],
    },
    des: {
      title: 'DES/3DES 암호화 온라인 - 무료 트리플 DES 계산기 | HSM Kit',
      description: '무료 온라인 DES 및 트리플 DES(3DES) 암호화 및 복호화 도구. DES, 2키 3DES, 3키 3DES를 ECB/CBC 모드로 지원. PKCS5, ISO 7816 등 다양한 패딩 옵션.',
      keywords: 'DES 암호화, 3DES 암호화, 트리플 DES, DES 복호화, DES 계산기, 3DES 온라인 도구, TDES, DES ECB, DES CBC',
      faqTitle: 'DES/3DES 암호화 FAQ',
      usageTitle: 'DES/3DES 도구 사용 방법',
      faqs: [
        { question: 'DES와 3DES의 차이점은?', answer: 'DES는 단일 56비트 키(패리티 포함 8바이트)를 사용하고, 3DES는 2개 또는 3개의 다른 키(16 또는 24바이트)로 DES 알고리즘을 3번 적용하여 훨씬 강력한 보안을 제공합니다.' },
        { question: 'DES는 아직 안전한가요?', answer: '단일 DES는 안전하지 않고 더 이상 사용되지 않습니다. 3DES는 레거시 시스템, 특히 결제 산업에서 여전히 사용되지만, 새 응용 프로그램에는 AES가 권장됩니다.' },
        { question: 'DES 키의 패리티 비트란?', answer: 'DES에서 키의 각 바이트에는 하나의 패리티 비트(최하위 비트)가 있어 유효 키 길이가 64비트에서 56비트가 됩니다. 이 도구는 패리티 비트를 자동으로 조정할 수 있습니다.' },
        { question: '어떤 패딩을 사용해야 하나요?', answer: 'PKCS5/PKCS7이 가장 일반적인 선택입니다. ISO 9797은 은행 응용 프로그램에서 자주 사용됩니다. 선택은 상대방이 기대하는 것과 일치해야 합니다.' },
      ],
      usage: [
        'DES(8바이트 키) 또는 3DES(16 또는 24바이트 키)를 선택합니다.',
        '암호화 모드(ECB 또는 CBC)와 패딩 방법을 선택합니다.',
        '키를 16진수 형식으로 입력합니다.',
        'CBC 모드의 경우 IV(8바이트 16진수)를 제공합니다.',
        '데이터를 입력하고 암호화 또는 복호화를 클릭합니다.',
      ],
    },
    rsa: {
      title: 'RSA 암호화 온라인 - 무료 RSA 계산기 및 키 생성기 | HSM Kit',
      description: '무료 온라인 RSA 암호화, 복호화, 서명, 검증 도구. RSA 키 쌍(1024-4096비트) 생성, 공개 키로 암호화, 개인 키로 서명. PKCS#1 및 OAEP 패딩 지원.',
      keywords: 'RSA 암호화, RSA 복호화, RSA 키 생성기, RSA 계산기, RSA 온라인 도구, RSA 서명, RSA 검증, 공개 키 암호화, PKCS1, OAEP',
      faqTitle: 'RSA 암호화 FAQ',
      usageTitle: 'RSA 도구 사용 방법',
      faqs: [
        { question: 'RSA 암호화란 무엇인가요?', answer: 'RSA는 공개 키로 암호화하고 개인 키로 복호화하는 키 쌍을 사용하는 비대칭 암호화 알고리즘입니다. 안전한 데이터 전송과 디지털 서명에 널리 사용됩니다.' },
        { question: '어떤 키 크기를 사용해야 하나요?', answer: '현재 보안 표준에서 2048비트 키가 최소로 간주됩니다. 장기 보안을 위해 4096비트 키가 권장됩니다. 1024비트 키는 더 이상 권장되지 않습니다.' },
        { question: 'PKCS#1과 OAEP의 차이점은?', answer: 'PKCS#1 v1.5는 오래된 패딩 체계입니다. OAEP(최적 비대칭 암호화 패딩)는 더 안전하며 특정 공격을 방지하므로 새 응용 프로그램에 권장됩니다.' },
        { question: 'RSA 암호화의 최대 데이터 크기는?', answer: 'RSA는 키 크기에서 패딩 오버헤드를 뺀 크기보다 작은 데이터만 암호화할 수 있습니다. OAEP-SHA256이 있는 2048비트 키의 경우 최대 약 190바이트입니다. 더 큰 데이터에는 하이브리드 암호화를 사용하세요.' },
      ],
      usage: [
        '새 RSA 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '암호화: 평문을 입력하고 암호화 클릭(공개 키 사용).',
        '복호화: 암호문을 입력하고 복호화 클릭(개인 키 필요).',
        '서명: 데이터 해시를 입력하고 서명 클릭(개인 키 필요).',
        '검증: 데이터, 서명을 입력하고 검증 클릭(공개 키 사용).',
      ],
    },
    ecc: {
      title: 'ECC/ECDSA 온라인 도구 - 타원 곡선 암호화 | HSM Kit',
      description: '무료 온라인 ECC(타원 곡선 암호화) 도구. ECDSA 키 쌍 생성, secp256k1, P-256, P-384 곡선으로 데이터 서명 및 검증. 컴팩트한 키로 강력한 보안.',
      keywords: 'ECC 암호화, ECDSA, 타원 곡선, secp256k1, P-256, P-384, ECC 키 생성기, ECDSA 서명, ECDSA 검증, 비트코인 암호화',
      faqTitle: 'ECC/ECDSA FAQ',
      usageTitle: 'ECC/ECDSA 도구 사용 방법',
      faqs: [
        { question: 'ECC란 무엇인가요?', answer: '타원 곡선 암호화(ECC)는 타원 곡선의 대수적 구조에 기반한 공개 키 암호화 접근 방식입니다. RSA와 동등한 보안을 훨씬 작은 키 크기로 제공합니다.' },
        { question: 'secp256k1이란 무엇인가요?', answer: 'secp256k1은 비트코인과 이더리움이 디지털 서명에 사용하는 타원 곡선입니다. 보안과 성능의 좋은 균형을 제공합니다.' },
        { question: 'RSA 대신 ECC를 사용하는 이유는?', answer: 'ECC는 RSA와 동일한 보안 수준을 훨씬 작은 키로 제공합니다(256비트 ECC ≈ 3072비트 RSA). 이로 인해 더 빠른 작업과 저장/대역폭 요구 사항 감소가 가능합니다.' },
        { question: 'ECDSA란 무엇인가요?', answer: 'ECDSA(타원 곡선 디지털 서명 알고리즘)는 ECC에 기반한 서명 알고리즘입니다. 데이터의 진위를 검증할 수 있는 디지털 서명을 만드는 데 사용됩니다.' },
      ],
      usage: [
        '타원 곡선(secp256k1, P-256 또는 P-384)을 선택합니다.',
        '새 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '서명: 데이터(또는 해시)를 입력하고 서명 클릭.',
        '검증: 원본 데이터, 서명을 입력하고 검증 클릭.',
      ],
    },
    fpe: {
      title: '형식 보존 암호화(FPE) 온라인 - FF1/FF3-1 도구 | HSM Kit',
      description: 'NIST SP 800-38G를 구현한 무료 온라인 형식 보존 암호화 도구. 형식과 길이를 보존하면서 데이터 암호화. 신용카드 번호, 주민등록번호 등 구조화된 데이터의 토큰화에 이상적.',
      keywords: 'FPE, 형식 보존 암호화, FF1, FF3, FF3-1, NIST 800-38G, 토큰화, 신용카드 암호화, 데이터 마스킹, PCI DSS',
      faqTitle: '형식 보존 암호화 FAQ',
      usageTitle: 'FPE 도구 사용 방법',
      faqs: [
        { question: '형식 보존 암호화란 무엇인가요?', answer: 'FPE는 평문과 동일한 형식과 길이의 암호문을 생성하는 암호화 방법입니다. 예를 들어, 16자리 신용카드 번호는 다른 16자리 숫자로 암호화됩니다.' },
        { question: 'FF1과 FF3-1의 차이점은?', answer: '둘 다 NIST 승인 FPE 알고리즘입니다. FF1은 가변 길이 트윅을 지원하고, FF3-1은 고정 56비트 트윅을 사용합니다. FF3-1은 일반적으로 더 빠르지만 제약이 더 많습니다.' },
        { question: '토큰화란 무엇인가요?', answer: '토큰화는 민감한 데이터를 비민감 플레이스홀더(토큰)로 대체합니다. FPE는 토큰이 원래 데이터 형식을 유지하기 때문에 토큰화에 자주 사용됩니다.' },
        { question: 'FPE는 PCI DSS를 준수하나요?', answer: '네, NIST SP 800-38G 승인 알고리즘(FF1, FF3-1)을 사용한 FPE는 올바르게 구현된 경우 PCI DSS 준수에 허용됩니다.' },
      ],
      usage: [
        'FPE 알고리즘(FF1 또는 FF3-1)과 기수(숫자 기반)를 선택합니다.',
        'AES 키(16, 24 또는 32바이트 16진수)를 입력합니다.',
        '추가 보안을 위해 선택적으로 트윅 값을 제공합니다.',
        '평문 데이터를 입력하고 암호화를 클릭하여 형식 보존 암호문을 생성합니다.',
      ],
    },
    keyGenerator: {
      title: '보안 키 생성기 온라인 - 랜덤 AES/DES 키 생성기 | HSM Kit',
      description: '무료 온라인 암호화 키 생성기. AES, DES, 3DES 암호화를 위한 안전한 랜덤 키 생성. 키 결합(XOR), 패리티 조정, 키 검증 도구 포함.',
      keywords: '키 생성기, 랜덤 키, AES 키 생성기, DES 키 생성기, 3DES 키 생성기, 암호화 키, 보안 랜덤, 키 결합, XOR 키',
      faqTitle: '키 생성기 FAQ',
      usageTitle: '키 생성기 사용 방법',
      faqs: [
        { question: '랜덤 키는 어떻게 생성되나요?', answer: '키는 Web Crypto API(crypto.getRandomValues)를 사용하여 생성됩니다. 이는 암호화 키에 적합한 암호학적으로 안전한 난수를 제공합니다.' },
        { question: '키 결합(XOR)이란 무엇인가요?', answer: '키 결합은 여러 키 구성 요소를 XOR하여 완전한 키를 형성할 수 있게 합니다. 이는 여러 관리인이 각각 구성 요소를 보유하는 의식에서 일반적으로 사용됩니다.' },
        { question: '패리티 비트란 무엇인가요?', answer: 'DES/3DES 키에서 각 바이트에는 오류 감지를 위한 패리티 비트가 있습니다. 이 도구는 DES 표준에서 요구하는 홀수 패리티로 패리티 비트를 자동 조정할 수 있습니다.' },
        { question: '지원되는 키 길이는?', answer: '생성기는 DES(8바이트/64비트), 2키 3DES(16바이트/128비트), 3키 3DES(24바이트/192비트) 및 AES-128/192/256을 지원합니다.' },
      ],
      usage: [
        '드롭다운에서 원하는 키 길이를 선택합니다.',
        '"생성"을 클릭하여 새 랜덤 키를 만듭니다.',
        '키 결합 탭을 사용하여 여러 구성 요소를 XOR합니다.',
        '패리티 탭을 사용하여 DES/3DES 키의 패리티 비트를 조정합니다.',
        '검증 탭을 사용하여 키가 올바른 형식과 패리티를 가지고 있는지 확인합니다.',
      ],
    },
    tr31: {
      title: 'TR-31 키 블록 파서 온라인 - ANSI X9.143 디코더 | HSM Kit',
      description: '무료 온라인 TR-31 키 블록 파서 및 분석기. ANSI X9.143(TR-31) 키 블록을 디코딩하고 버전, 키 용도, 알고리즘, 내보내기 가능성, 선택적 블록을 봅니다. 결제 HSM 운영에 필수적인 도구.',
      keywords: 'TR-31, 키 블록, ANSI X9.143, TR31 파서, 키 블록 디코더, 결제 HSM, 키 용도, 키 내보내기 가능성, DUKPT, 키 관리',
      faqTitle: 'TR-31 키 블록 FAQ',
      usageTitle: 'TR-31 파서 사용 방법',
      faqs: [
        { question: 'TR-31이란 무엇인가요?', answer: 'TR-31(현재 ANSI X9.143)은 결제 산업에서 안전한 키 교환을 위한 표준 형식입니다. 키 용도, 알고리즘, 내보내기 가능성 규칙 등의 메타데이터로 암호화 키를 래핑합니다.' },
        { question: 'TR-31의 버전은?', answer: '버전 A/B는 TDES 키 래핑을 사용하고, 버전 C는 변형 바인딩이 있는 TDES를 사용하고, 버전 D는 AES 키 래핑(가장 안전)을 사용하고, 버전 E는 변형 바인딩이 있는 AES를 사용합니다.' },
        { question: 'TR-31의 키 용도란?', answer: '키 용도(P0, B0, D0 등의 2자)는 래핑된 키의 사용 방법을 정의합니다. P0은 PIN 암호화용, B0은 BDK(기본 파생 키)용, D0은 데이터 암호화용 등입니다.' },
        { question: '내보내기 가능성이란?', answer: '내보내기 가능성 플래그는 키를 내보낼 수 있는지 나타냅니다: E=내보내기 가능, N=내보내기 불가, S=민감(특정 조건에서 내보내기 가능).' },
      ],
      usage: [
        'TR-31 키 블록 문자열을 입력 필드에 붙여넣습니다.',
        '"키 블록 파싱"을 클릭하여 구조를 디코딩합니다.',
        '버전, 길이, 키 용도를 포함한 헤더 정보를 봅니다.',
        '알고리즘, 모드, 키 버전, 내보내기 가능성 설정을 검사합니다.',
      ],
    },
    kcv: {
      title: 'KCV 계산기 온라인 - 키 체크 값 생성기 | HSM Kit',
      description: 'AES 및 DES/3DES 키용 무료 온라인 KCV(키 체크 값) 계산기. 체크 값을 계산하여 암호화 키의 정확성을 검증합니다. DES 키의 자동 패리티 조정 지원.',
      keywords: 'KCV 계산기, 키 체크 값, KCV 생성기, AES KCV, DES KCV, 3DES KCV, CMAC, 키 검증, 결제 키',
      faqTitle: 'KCV 계산기 FAQ',
      usageTitle: 'KCV 계산기 사용 방법',
      faqs: [
        { question: 'KCV(키 체크 값)란 무엇인가요?', answer: 'KCV는 암호화 키가 올바르게 입력되거나 전송되었는지 확인하는 데 사용되는 체크섬입니다. 0의 블록을 암호화하고 결과의 처음 3바이트를 취하여 계산됩니다.' },
        { question: 'DES/3DES의 KCV는 어떻게 계산되나요?', answer: 'DES/3DES의 경우: ECB 모드로 8바이트 0(0x0000000000000000)을 암호화한 다음 암호문의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: 'AES의 KCV는 어떻게 계산되나요?', answer: 'AES의 경우: 키를 사용하여 16바이트 0에 대해 CMAC를 계산한 다음 MAC 값의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: '자동 패리티 조정이란?', answer: 'DES 키는 각 바이트에 홀수 패리티가 필요합니다. 키에 올바른 패리티가 없으면 자동 조정을 활성화하여 KCV 계산 전에 수정할 수 있습니다.' },
      ],
      usage: [
        '알고리즘(AES 또는 DES/3DES)을 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'DES 키의 경우 선택적으로 자동 패리티 조정을 활성화합니다.',
        '"KCV 계산"을 클릭하여 키 체크 값을 생성합니다.',
        'KCV를 예상 값과 비교하여 키의 정확성을 검증합니다.',
      ],
    },
    pinBlock: {
      title: 'PIN 블록 생성기 온라인 - ISO 9564 형식 0/1/3/4 | HSM Kit',
      description: 'ISO 9564 형식(형식 0, 1, 3, 4)을 지원하는 무료 온라인 PIN 블록 생성기. 결제 거래, ATM, POS 시스템용 PIN 블록 생성. 결제 보안 테스트에 필수적인 도구.',
      keywords: 'PIN 블록, ISO 9564, PIN 블록 형식 0, PIN 블록 형식 4, 결제 보안, ATM PIN, POS PIN, PIN 암호화, 카드 PIN',
      faqTitle: 'PIN 블록 FAQ',
      usageTitle: 'PIN 블록 생성기 사용 방법',
      faqs: [
        { question: 'PIN 블록이란 무엇인가요?', answer: 'PIN 블록은 암호화 전에 PIN(개인 식별 번호)을 인코딩하기 위한 표준화된 형식입니다. PIN을 채우기 패턴 또는 PAN 데이터와 결합하여 암호화용 고정 길이 블록을 만듭니다.' },
        { question: '형식 0(ISO 9564-1)이란?', answer: '형식 0은 PIN 블록을 PAN의 오른쪽 12자리(체크 디지트 제외)와 XOR합니다. 결제 시스템에서 가장 널리 사용되는 형식입니다.' },
        { question: '형식 4(ISO 9564-1:2017)란?', answer: '형식 4는 AES 암호화를 위해 설계된 최신 형식입니다. 랜덤 패딩을 포함하며 이전 형식보다 더 나은 보안을 제공합니다.' },
        { question: 'PIN 블록에 PAN이 필요한 이유는?', answer: '형식 0 및 일부 형식에서 PAN은 PIN 데이터와 XOR되어 PIN을 특정 카드에 바인딩하고 특정 공격을 방지합니다.' },
      ],
      usage: [
        'PIN 블록 형식(0, 1, 3 또는 4)을 선택합니다.',
        'PIN(4-12자리)을 입력합니다.',
        'PAN이 필요한 형식의 경우 카드 번호를 입력합니다.',
        '"생성"을 클릭하여 PIN 블록을 만듭니다.',
        '생성된 16진수 문자열을 암호화 프로세스의 입력으로 사용합니다.',
      ],
    },
  },
};

