// Korean translations
export default {
  common: {
    copy: '복사',
    generate: '생성',
    calculate: '계산',
    parse: '구문 분석',
    clear: '지우기',
    copied: '클립보드에 복사되었습니다!',
    error: '오류',
    result: '결과',
    loading: '로딩 중...',
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: '키 생성',
    tr31: 'TR-31',
    kcv: 'KCV 계산',
    pinBlock: 'PIN 블록',
    asn1: 'ASN.1',
    cipher: '암호화',
    generic: '일반 도구',
    hashes: '해시',
    characterEncoding: '문자 인코딩',
    bcd: 'BCD',
    checkDigits: '체크 디지트',
    base64: 'Base64',
    base94: 'Base94',
    messageParser: '메시지 파서',
    rsaDerPublicKey: 'RSA DER 공개키',
    uuid: 'UUID',
  },
  
  footer: {
    copyright: 'HSMKit.com ©2025 | 안전한 클라이언트 측 계산',
  },

  home: {
    heroTitle: '무료 온라인 암호화 및 키 관리 도구',
    heroDescription: '보안 전문가를 위한 종합 암호화 도구 모음입니다. 모든 계산은 브라우저에서 클라이언트 측에서 수행되며, 데이터가 기기를 떠나지 않습니다.',
    searchPlaceholder: '도구 검색... (예: MD5, AES, PIN Block)',
    availableTools: '사용 가능한 도구',
    whyChoose: '왜 HSM Kit를 선택해야 할까요?',
    categories: {
      all: '전체',
      symmetric: '대칭 암호화',
      asymmetric: '비대칭 암호화',
      payment: '결제/금융',
      encoding: '인코딩',
      hashing: '해시',
    },
    tools: {
      asn1: {
        title: 'ASN.1 파서',
        description: 'ASN.1 DER/BER 구조를 분석하고 X.509 인증서 및 PKCS 형식을 디코딩합니다.',
      },
      aes: {
        title: 'AES 암호화',
        description: 'AES-128/192/256으로 데이터를 암호화/복호화. ECB, CBC, CFB, OFB, CTR 모드 지원.',
      },
      des: {
        title: 'DES/3DES 암호화',
        description: '레거시 시스템을 위한 다양한 패딩 옵션이 있는 DES 및 Triple DES 암호화.',
      },
      rsa: {
        title: 'RSA 암호화',
        description: 'RSA 비대칭 암호화, 복호화, 디지털 서명 및 검증.',
      },
      ecc: {
        title: 'ECC/ECDSA',
        description: '컴팩트한 키와 효율적인 디지털 서명을 위한 타원 곡선 암호화.',
      },
      fpe: {
        title: '형식 보존 암호화',
        description: 'FPE (FF1/FF3-1)로 형식과 길이를 보존하면서 데이터를 암호화.',
      },
      keyGenerator: {
        title: '키 생성기',
        description: 'AES, DES, 3DES용 보안 랜덤 키 생성. 키 조합 및 패리티 도구.',
      },
      tr31: {
        title: 'TR-31 키 블록',
        description: '결제 산업에서 사용되는 TR-31/ANSI X9.143 키 블록을 분석.',
      },
      kcv: {
        title: 'KCV 계산기',
        description: 'AES 및 DES/3DES 키의 키 검증값(KCV) 계산.',
      },
      pinBlock: {
        title: 'PIN 블록 생성기',
        description: '결제 거래용 ISO 9564 PIN 블록 (형식 0, 1, 3, 4) 생성.',
      },
      hash: {
        title: '해시 계산기',
        description: 'MD5, SHA-1, SHA-256, SHA-512, BLAKE2 등의 알고리즘으로 해시 값 계산.',
      },
      encoding: {
        title: '문자 인코딩',
        description: 'ASCII, EBCDIC, 16진수, 바이너리, ATM 10진수 형식 간 변환.',
      },
      bcd: {
        title: 'BCD 인코더/디코더',
        description: '10진수를 BCD로 인코딩하거나 BCD를 10진수로 디코딩.',
      },
      checkDigits: {
        title: '체크 디지트',
        description: 'Luhn (MOD 10) 및 MOD 9 알고리즘으로 체크 디지트 계산 및 검증.',
      },
      base64: {
        title: 'Base64',
        description: 'Base64 바이너리-텍스트 인코딩으로 데이터 인코딩/디코딩.',
      },
      base94: {
        title: 'Base94',
        description: '94개의 모든 출력 가능한 ASCII 문자를 사용한 컴팩트 인코딩.',
      },
      messageParser: {
        title: '메시지 파서',
        description: 'ATM NDC, Wincor, ISO 8583 금융 메시지 형식 구문 분석.',
      },
      rsaDer: {
        title: 'RSA DER 공개키',
        description: '모듈러스/지수와 DER 형식 간 RSA 공개키 인코딩/디코딩.',
      },
      uuid: {
        title: 'UUID 생성기',
        description: '범용 고유 식별자 (UUID v1, v3, v4, v5) 생성.',
      },
    },
    features: {
      clientSide: {
        title: '100% 클라이언트 측',
        description: '모든 암호화 작업이 브라우저에서 완전히 실행됩니다. 데이터가 서버로 전송되지 않습니다.',
      },
      free: {
        title: '완전 무료',
        description: '모든 도구는 등록, 로그인 또는 결제 없이 무료로 사용할 수 있습니다. 숨겨진 비용이 없습니다.',
      },
      paymentReady: {
        title: '결제 산업 대응',
        description: 'TR-31, KCV, PIN 블록 및 기타 결제 보안 작업을 위한 전문 도구.',
      },
    },
  },
  
  asn1: {
    title: 'ASN.1 파서',
    description: 'ASN.1 DER/BER 구조를 구문 분석 및 분석하고 RFC 정의 매칭 지원',
    inputLabel: '입력 (Hex, Base64, 또는 PEM):',
    inputPlaceholder: 'hex, base64 또는 PEM 인코딩된 ASN.1 BER/DER 구조를 붙여넣거나 파일 업로드',
    withHexDump: 'Hex Dump 표시',
    trimBigChunks: '큰 데이터 간소화',
    withDefinitions: '정의 매칭 활성화',
    uploadFile: '파일 업로드',
    parse: '구문 분석',
    clear: '지우기',
    structureDefinition: '구조 정의:',
    selectDefinition: '구조 정의 선택...',
    parsedResult: '구문 분석 결과:',
    hexDump: 'Hex Dump:',
    offset: '오프셋',
    length: '길이',
    value: '값',
    constructed: '구조 타입',
    loadError: 'ASN.1 파싱 라이브러리 로드 실패',
    inputRequired: 'ASN.1 데이터를 입력하세요',
    parseError: '구문 분석 실패',
    copied: '복사됨',
    copyHex: 'Hex 복사',
    copyHexDump: 'Hex Dump 복사',
    copyBase64: 'Base64 복사',
    copySubtree: '하위 트리 복사',
    copyValue: '값 복사',
  },
  
  keyGenerator: {
    title: '랜덤 키 생성기',
    description: 'DES, 3DES 또는 AES용 암호학적으로 강력한 랜덤 키를 생성합니다.',
    keyLength: '키 길이',
    bytes: '바이트',
    bits: '비트',
    generateNow: '지금 생성',
    generatedKey: '생성된 키 (16진수)',
    kcv: 'KCV',
    length: '길이',
    tabKeyGen: '키 생성',
    tabCombination: '키 조합',
    tabParity: '패리티 조정',
    tabValidation: '키 검증',
    combinationTitle: '키 컴포넌트 조합',
    combinationDesc: '여러 키 컴포넌트를 XOR로 조합',
    component: '컴포넌트',
    components: '개 컴포넌트',
    combinedKey: '조합된 키',
    addComponent: '추가',
    removeComponent: '제거',
    combineKeys: '조합',
    errorInvalidComponent: '컴포넌트 {index} 무효',
    errorComponentLength: '모든 컴포넌트의 길이가 같아야 합니다',
    errorComponentLength2: '길이는 다음 중 하나여야 합니다',
    errorMinComponents: '최소 2개의 컴포넌트 필요',
    errorMaxComponents: '최대 9개 컴포넌트까지 가능',
    clearAll: '모두 지우기',
    parityTitle: '패리티 조정',
    parityDesc: 'DES/3DES 키의 패리티 비트 조정',
    keyInput: '키 입력',
    keyInputPlaceholder: '16진수 키 입력',
    parityType: '패리티 유형',
    odd: '홀수',
    even: '짝수',
    adjustParity: '조정',
    adjustedKey: '조정된 키',
    validationTitle: '키 유효성 검사',
    validationDesc: '형식, 길이 및 패리티 확인',
    validateKey: '검증',
    validKey: '유효한 키',
    invalidKey: '무효한 키',
    keyType: '키 유형',
    parityStatus: '패리티 상태',
    parityValid: '유효',
    parityInvalid: '무효',
  },
  
  kcvCalculator: {
    title: 'KCV 계산기',
    description: '키 확인 값을 계산하여 키의 정확성을 검증합니다.',
    algorithm: '알고리즘',
    keyInput: '키 (16진수)',
    keyPlaceholder: '예: 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'KCV 계산',
    keyCheckValue: '키 확인 값',
    errorInvalidHex: '키는 유효한 16진수 문자여야 합니다',
    errorDesLength: 'DES/3DES 키 길이는 8, 16 또는 24바이트여야 합니다',
    errorAesLength: 'AES 키 길이는 16, 24 또는 32바이트여야 합니다',
    errorCalculation: '계산에 실패했습니다. 키 형식을 확인하세요',
    format: '형식',
    autoAdjustParity: '패리티 비트 자동 조정',
    parityAdjustmentHint: '일부 키에는 올바른 패리티 비트가 설정되어 있지 않을 수 있습니다. 이 옵션을 선택하면 자동으로 수정됩니다',
    kcvCalcTitle: '키 확인 값 계산',
    desCalcDesc: '키의 평문을 사용하여 16자 길이의 \'0\'을 3DES-ECB 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
    aesCalcDesc: '키의 평문을 사용하여 32자 길이의 \'0\'을 CMAC-AES 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
  },
  
  pinBlock: {
    title: 'PIN 블록 생성기',
    description: '결제 거래용 ISO 형식 PIN 블록을 생성합니다.',
    format: 'PIN 블록 형식',
    pinLabel: 'PIN (4-12자리)',
    pinPlaceholder: '예: 1234',
    panLabel: 'PAN (기본 계좌 번호)',
    panPlaceholder: '예: 4111111111111111',
    generatePinBlock: 'PIN 블록 생성',
    pinBlockHex: 'PIN 블록 (16진수)',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidPan: 'PAN은 13-19자리 숫자여야 합니다',
    errorGeneration: '생성에 실패했습니다. 입력을 확인하세요',
    errorFormat1: 'ISO Format 1은 곧 출시됩니다...',
    pinLengthHint: '4-12자리 PIN 지원',
    panHint: '전체 카드 번호를 입력하세요 (13-19자리), 시스템이 자동으로 오른쪽 12자리를 추출합니다 (체크 디지트 제외)',
  },
  
  tr31: {
    title: 'TR-31 키 블록 분석기',
    description: 'TR-31 형식 키 블록을 구문 분석하고 분석합니다 (ANSI X9.143 표준).',
    keyBlock: 'TR-31 키 블록',
    keyBlockPlaceholder: '예: B0112P0TE00N0000...',
    parseKeyBlock: '키 블록 구문 분석',
    header: '키 블록 헤더',
    version: '버전',
    keyLength: '길이',
    keyUsage: '키 용도',
    mode: '모드',
    keyVersion: '키 버전',
    exportability: '내보내기 가능성',
    characters: '문자',
    errorTooShort: 'TR-31 키 블록 길이가 부족합니다',
    errorParsing: '구문 분석에 실패했습니다. TR-31 형식을 확인하세요',
    exportable: '내보내기 가능',
    nonExportable: '내보내기 불가',
    sensitive: '민감함',
    keyBlockFormatHint: 'TR-31 키 블록 형식 (예: B0112P0TE00N...), 시스템이 자동으로 형식을 검증합니다',
  },
  
  placeholder: {
    title: '출시 예정',
    description: '이 도구는 개발 중입니다. 기대해 주세요!',
  },

  hash: {
    title: '해시 계산기',
    description: 'MD5, SHA-1, SHA-256, SHA-512 등 다양한 알고리즘으로 해시값 계산',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    hashType: '해시 유형',
    inputData: '입력 데이터',
    hashResult: '해시 결과',
    asciiPlaceholder: '텍스트 데이터 입력...',
    hexPlaceholder: '16진수 데이터 입력...',
    byteLength: '바이트',
    calculate: '해시 계산',
    algorithmInfo: '알고리즘 정보',
    outputLength: '출력 길이',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorOddHex: '16진수 입력은 짝수 개의 문자여야 합니다',
    errorCalculation: '해시 계산 실패',
    faqTitle: '해시 계산기 FAQ',
    faq1Question: '해시 함수란?',
    faq1Answer: '해시 함수는 임의 크기의 입력 데이터를 고정 크기의 출력(해시값)으로 변환하는 수학적 알고리즘입니다. 결정적이고 일방향입니다.',
    faq2Question: '어떤 해시 알고리즘을 사용해야 하나요?',
    faq2Answer: '보안 목적으로는 SHA-256 또는 SHA-512를 사용하세요. MD5와 SHA-1은 암호화 용도로는 안전하지 않지만 체크섬에는 사용할 수 있습니다.',
    usageTitle: '사용 방법',
    usage1: '입력 유형 선택 (ASCII 텍스트 또는 16진수)',
    usage2: '드롭다운에서 해시 알고리즘 선택',
    usage3: '입력 필드에 데이터 입력',
    usage4: '"해시 계산"을 클릭하여 해시값 생성',
    hashInfo: '해시 함수는 일방향 - 역변환 불가',
    inputLength: '입력',
  },

  encoding: {
    title: '문자 인코딩',
    description: '다양한 문자 인코딩과 형식 간 변환',
    encodingType: '인코딩',
    data: '데이터',
    convert: '변환',
    result: '변환 결과',
    conversionInfo: '변환 정보',
    ebcdicInfo: 'EBCDIC는 IBM 메인프레임에서 사용',
    atmInfo: 'ATM 형식은 공백으로 구분된 10진수 값을 사용 (0-255)',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorConversion: '변환 실패',
    placeholderBinary: '데이터 입력 (예: 57652C206174...)',
    placeholderHex: '16진수 데이터 입력',
    placeholderText: 'ASCII 텍스트 입력',
    placeholderAtm: '공백으로 구분된 10진수 값 입력 (예: 065 066 067)',
    faqTitle: '문자 인코딩 FAQ',
    faq1Question: '문자 인코딩이란?',
    faq1Answer: '문자 인코딩은 각 문자를 고유한 숫자 또는 바이트 시퀀스와 연결하여 컴퓨터가 텍스트를 저장하고 전송할 수 있게 하는 시스템입니다.',
    faq2Question: 'EBCDIC란?',
    faq2Answer: 'EBCDIC(확장 이진화 십진 교환 코드)는 주로 IBM 메인프레임 및 미드레인지 컴퓨터 시스템에서 사용되는 8비트 문자 인코딩입니다.',
    usageTitle: '사용 방법',
    usage1: '드롭다운에서 변환 유형 선택',
    usage2: '적절한 형식으로 데이터 입력',
    usage3: '"변환"을 클릭하여 결과 확인',
  },

  bcd: {
    title: '이진화 십진법 (BCD)',
    description: '십진수를 BCD로 인코딩하거나 BCD를 십진수로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputFormat: '입력 형식',
    binary: '이진수',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'BCD 정보',
    encodeInfo1: '각 십진 숫자 (0-9)는 4비트로 인코딩',
    encodeInfo2: '예: 25 → 0010 0101 (이진수) / 25 (16진수)',
    decodeInfo1: '각 4비트는 0-9여야 합니다 (A-F 불가)',
    decodeInfo2: '예: 0010 0101 → 25',
    encodeResult: 'BCD 인코딩 결과',
    decodeResult: '디코딩된 십진수',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidDecimal: '잘못된 입력: 0-9 숫자만 허용',
    errorInvalidBinary: '잘못된 이진수 입력 (0과 1만, 4의 배수 길이)',
    errorInvalidHex: '잘못된 16진수 입력',
    errorConversion: '변환 실패',
    placeholderEncode: '십진수 입력 (예: 12345)',
    placeholderBinary: 'BCD 이진수 입력 (예: 0010 0101)',
    placeholderHex: 'BCD 16진수 입력 (예: 25)',
    faqTitle: 'BCD FAQ',
    faq1Question: 'BCD란?',
    faq1Answer: '이진화 십진법 (BCD)는 각 십진 숫자를 고정 비트 수 (보통 4비트)로 표현하는 이진 인코딩입니다.',
    faq2Question: 'BCD를 왜 사용하나요?',
    faq2Answer: 'BCD는 십진 정밀도가 중요한 금융 및 상업 애플리케이션과 십진 숫자를 직접 표시해야 하는 시스템에서 사용됩니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 십진수를 BCD로 변환',
    usage2: '"디코딩"을 선택하여 BCD를 십진수로 변환',
    usage3: '디코딩 시 이진수 또는 16진수 입력 형식 선택',
  },

  checkDigits: {
    title: '체크 디지트',
    description: '다양한 알고리즘으로 체크 디지트 검증 또는 생성',
    operation: '작업',
    check: '검증',
    generate: '생성',
    hashType: '알고리즘',
    input: '입력',
    info: '알고리즘 정보',
    luhnInfo: 'Luhn 알고리즘 (MOD 10) - 신용카드, IMEI 등에 사용',
    amexInfo: 'Amex SE Number (MOD 9) - 숫자 합계를 9로 나눈 나머지',
    checkInfo: '체크 디지트를 포함한 완전한 번호 입력',
    generateInfo: '체크 디지트 없는 번호 입력',
    checkResult: '검증 결과',
    generateResult: '생성된 체크 디지트',
    validResult: '유효 - 체크 디지트가 올바릅니다',
    invalidResult: '무효 - 체크 디지트가 올바르지 않습니다',
    fullNumber: '전체 번호',
    errorNoInput: '번호를 입력하세요',
    errorCalculation: '계산 실패',
    placeholderCheck: '체크 디지트 포함 번호 입력 (예: 79927398713)',
    placeholderGenerate: '체크 디지트 없는 번호 입력 (예: 7992739871)',
    faqTitle: '체크 디지트 FAQ',
    faq1Question: '체크 디지트란?',
    faq1Answer: '체크 디지트는 특정 알고리즘으로 계산된 오류 검출용 숫자입니다.',
    faq2Question: 'Luhn 알고리즘이란?',
    faq2Answer: 'Luhn 알고리즘 (MOD 10)은 신용카드 번호, IMEI 번호 등의 검증에 사용되는 체크섬 공식입니다.',
    usageTitle: '사용 방법',
    usage1: '"검증"을 선택하여 체크 디지트 포함 번호 검증',
    usage2: '"생성"을 선택하여 체크 디지트 계산',
    usage3: '용도에 맞는 알고리즘 선택',
  },

  base64: {
    title: 'Base64',
    description: '데이터를 Base64로 인코딩하거나 Base64를 원래 형식으로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputEncoding: '입력 인코딩',
    outputEncoding: '출력 인코딩',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'Base64 정보',
    encodeInfo1: 'Base64는 바이너리 데이터를 ASCII 문자로 인코딩',
    encodeInfo2: '출력은 입력보다 약 33% 큼',
    decodeInfo1: 'Base64를 원래 데이터로 디코딩',
    decodeInfo2: '출력 형식 선택: ASCII 텍스트 또는 16진수',
    encodeResult: 'Base64 인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase64: '잘못된 Base64 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    placeholderAscii: '인코딩할 텍스트 입력',
    placeholderHex: '인코딩할 16진수 데이터 입력',
    placeholderBase64: '디코딩할 Base64 문자열 입력',
    faqTitle: 'Base64 FAQ',
    faq1Question: 'Base64란?',
    faq1Answer: 'Base64는 64개 문자를 사용하여 바이너리 데이터를 ASCII 문자열 형식으로 표현하는 바이너리-텍스트 인코딩 방식입니다.',
    faq2Question: '왜 Base64를 사용하나요?',
    faq2Answer: 'Base64는 JSON, XML, 이메일 첨부 파일과 같은 텍스트 기반 형식에 바이너리 데이터를 포함하는 데 일반적으로 사용됩니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 데이터를 Base64로 변환',
    usage2: '"디코딩"을 선택하여 Base64를 원래 데이터로 변환',
    usage3: '입력/출력 인코딩 선택: ASCII 또는 16진수',
  },

  base94: {
    title: 'Base94',
    description: '데이터를 Base94로 인코딩하거나 Base94를 원래 형식으로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputEncoding: '입력 인코딩',
    outputEncoding: '출력 인코딩',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'Base94 정보',
    encodeInfo1: 'ASCII 인쇄 가능 문자 사용 (0x20 공백부터 0x7E 물결표)',
    encodeInfo2: '5:4 비율 - 4바이트를 5문자로 인코딩 (25% 오버헤드)',
    decodeInfo1: 'Base94를 원래 데이터로 디코딩',
    decodeInfo2: '유효한 문자: 공백부터 ~ (ASCII 32-126)',
    encodeResult: 'Base94 인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase94: '잘못된 Base94 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    placeholderAscii: '인코딩할 텍스트 입력',
    placeholderHex: '인코딩할 16진수 데이터 입력',
    placeholderBase94: '디코딩할 Base94 문자열 입력',
    faqTitle: 'Base94 FAQ',
    faq1Question: 'Base94란?',
    faq1Answer: 'Base94는 94개의 인쇄 가능한 ASCII 문자 (!부터 ~)를 모두 사용하는 바이너리-텍스트 인코딩으로, Base64보다 효율적인 인코딩을 제공합니다.',
    faq2Question: '왜 Base64 대신 Base94를 사용하나요?',
    faq2Answer: 'Base94는 Base64 (약 33%)에 비해 오버헤드가 적어 (약 22%), 동일한 데이터의 인코딩 출력이 더 작습니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 데이터를 Base94로 변환',
    usage2: '"디코딩"을 선택하여 Base94를 원래 데이터로 변환',
    usage3: '입력/출력 인코딩 선택: ASCII 또는 16진수',
  },

  messageParser: {
    title: '메시지 파서',
    description: 'ATM 및 금융 거래 메시지 파싱',
    parseMode: '파싱 모드',
    hexData: '16진수 데이터',
    info: '파싱 모드 정보',
    ndcDesc: 'NCR NDC/DDC 프로토콜, ATM 통신용',
    wincorDesc: 'Wincor Nixdorf 프로토콜, ATM 통신용',
    iso8583Desc: 'ISO 8583:1987 금융 거래 메시지 형식',
    hexInputInfo: '입력은 유효한 16진수 데이터여야 합니다',
    placeholder: '파싱할 16진수 메시지 데이터 입력...',
    parsedResult: '파싱 결과',
    fields: '필드',
    fieldName: '필드',
    length: '길이',
    value: '값',
    errorNoInput: '16진수 데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorParseFailed: '메시지 파싱 실패',
    faqTitle: '메시지 파서 FAQ',
    faq1Question: 'ATM NDC란?',
    faq1Answer: 'NDC(NCR Direct Connect)는 NCR ATM이 호스트 시스템과 통신하는 데 사용하는 통신 프로토콜입니다.',
    faq2Question: 'ISO 8583이란?',
    faq2Answer: 'ISO 8583은 카드 결제 거래에 사용되는 금융 거래 카드 발신 메시지의 국제 표준입니다.',
    usageTitle: '사용 방법',
    usage1: '적절한 파싱 모드 선택 (ATM_NDC, ATM_WINCOR 또는 ISO_8583_1987)',
    usage2: '입력 필드에 16진수 메시지 데이터 입력',
    usage3: '파싱을 클릭하여 파싱된 필드와 값 보기',
  },

  rsaDer: {
    title: 'RSA DER 공개키',
    description: 'DER ASN.1 형식으로 RSA 공개키 인코딩/디코딩',
    info: 'RSA DER 정보',
    encode: '인코딩',
    decode: '디코딩',
    modulus: '모듈러스',
    modulusEncoding: '모듈러스 인코딩',
    exponent: '지수',
    exponentEncoding: '지수 인코딩',
    modulusNegative: '모듈러스 음수 (부호 없는 인코딩)',
    outputEncoding: '출력 인코딩',
    inputEncoding: '입력 인코딩',
    derInput: 'DER/PEM 입력',
    modulusPlaceholder: '모듈러스 입력 (16진수 또는 base64)',
    exponentPlaceholder: '지수 입력 (예: 65537의 경우 010001)',
    derInputPlaceholder: 'DER (16진수/base64) 또는 PEM 형식 공개키 입력',
    encodeInfo: 'RSA 공개키 인코딩',
    encodeInfo1: 'RSA 모듈러스와 지수를 DER/PEM 형식으로 인코딩',
    encodeInfo2: '부호 있는 및 부호 없는 정수 인코딩 지원',
    decodeInfo: 'RSA 공개키 디코딩',
    decodeInfo1: 'DER/PEM 형식을 디코딩하여 모듈러스와 지수 추출',
    decodeInfo2: '16진수, base64, PEM 입력 형식 지원',
    encodeResult: '인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoModulus: '모듈러스를 입력하세요',
    errorNoExponent: '지수를 입력하세요',
    errorNoInput: 'DER 데이터를 입력하세요',
    errorInvalidModulusHex: '잘못된 모듈러스 16진수',
    errorInvalidModulusBase64: '잘못된 모듈러스 base64',
    errorInvalidExponentHex: '잘못된 지수 16진수',
    errorInvalidExponentBase64: '잘못된 지수 base64',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase64: '잘못된 base64 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    faqTitle: 'RSA DER 공개키 FAQ',
    faq1Question: 'DER 인코딩이란?',
    faq1Answer: 'DER(Distinguished Encoding Rules)은 ASN.1 데이터 구조를 인코딩하는 바이너리 형식으로, 암호화 키와 인증서에 일반적으로 사용됩니다.',
    faq2Question: 'PEM 형식이란?',
    faq2Answer: 'PEM은 헤더와 푸터 라인이 있는 DER의 Base64 인코딩 버전으로, 텍스트 형식으로 쉽게 복사하여 붙여넣을 수 있습니다.',
    usageTitle: '사용 방법',
    usage1: '인코딩: 모듈러스와 지수를 입력하여 DER/PEM 인코딩된 공개키 생성',
    usage2: '디코딩: DER 또는 PEM 형식 공개키를 입력하여 모듈러스와 지수 추출',
    usage3: '16진수 및 base64 입출력 형식 지원',
  },

  uuid: {
    title: 'UUID 생성기',
    description: '범용 고유 식별자 (UUID) 생성',
    variant: '버전',
    count: '수량',
    info: 'UUID 정보',
    infoFormat: '형식: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36자)',
    v1Desc: '타임스탬프와 랜덤 노드를 사용하는 시간 기반 UUID',
    v4Desc: '랜덤 UUID - 가장 일반적',
    v3Desc: 'MD5 해시를 사용하는 이름 기반 UUID',
    v5Desc: 'SHA-1 해시를 사용하는 이름 기반 UUID',
    generatedUUIDs: '생성된 UUID',
    copyAll: '모두 복사',
    errorInvalidCount: '수량은 1에서 100 사이여야 합니다',
    errorGenerate: '생성 실패',
    withoutHyphen: '"-" 제외',
    maxCount: '최대 100개',
    faqTitle: 'UUID FAQ',
    faq1Question: 'UUID란?',
    faq1Answer: 'UUID(범용 고유 식별자)는 시간과 공간 모두에서 고유한 128비트 식별자로, 분산 시스템에서 일반적으로 사용됩니다.',
    faq2Question: '어떤 UUID 버전을 사용해야 하나요?',
    faq2Answer: '버전 4(랜덤)가 가장 일반적입니다. 버전 1은 시간 기반이고, 버전 3과 5는 각각 MD5와 SHA-1을 사용하는 이름 기반입니다.',
    usageTitle: '사용 방법',
    usage1: 'UUID 버전 선택',
    usage2: '생성할 UUID 수 입력 (1-100)',
    usage3: '생성을 클릭하여 UUID 생성',
  },

  cipher: {
    title: 'AES 암호화/복호화',
    description: 'AES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    aesInfo: 'AES 정보',
    keyLengthInfo: '키 길이는 선택한 알고리즘과 일치해야 합니다',
    ivInfo: 'IV(초기화 벡터)는 16바이트여야 합니다',
    paddingInfo: 'PKCS7 패딩 사용',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB/KCV 모드에서는 IV가 필요하지 않습니다',
    kcvInfo: 'KCV: 0을 암호화하고 처음 6개의 16진수 문자를 가져옴',
    calculateKcv: 'KCV 계산',
    noPaddingInfo: '패딩 없음 - 데이터 길이는 16바이트의 배수여야 합니다',
    errorDataLength: '데이터 길이는 16바이트의 배수여야 합니다',
    kcvNoDataNeeded: 'KCV 계산에는 데이터 입력이 필요하지 않습니다',
    kcvDataHint: 'KCV는 0을 사용하여 계산되므로 데이터 입력이 필요하지 않습니다',
    errorKcvCalculation: 'KCV 계산 실패',
    kcvResult: 'KCV 결과',
  },

  des: {
    title: 'DES / 3DES 암호화/복호화',
    description: 'DES 또는 3DES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    padding: '패딩',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    desInfo: 'DES/3DES 정보',
    keyLengthInfoDes: 'DES에는 8바이트(64비트) 키가 필요합니다',
    keyLengthInfo3Des: '3DES에는 16 또는 24바이트 키가 필요합니다',
    ivInfo: 'IV(초기화 벡터)는 8바이트여야 합니다',
    blockSizeInfo: '블록 크기는 8바이트입니다',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLengthDes: 'DES 키 길이는 8바이트여야 합니다',
    errorKeyLength3Des: '3DES 키 길이는 16 또는 24바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorDataLength: '패딩 없음 사용 시 데이터 길이는 8바이트의 배수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB 모드에서는 IV가 필요하지 않습니다',
    paddingNone: '패딩 없음',
    paddingZeros: '0x00으로 채움',
    paddingSpaces: '공백 0x20으로 채움',
    paddingANSIX923: '마지막 바이트는 패딩 길이, 나머지는 0x00으로 채움',
    paddingISO10126: '마지막 바이트는 패딩 길이, 나머지는 랜덤 바이트로 채움',
    paddingPKCS5: '각 패딩 바이트 값은 패딩 길이와 같음',
    paddingPKCS7: 'PKCS#5와 동일',
    paddingISO7816: '0x80을 추가한 후 0x00으로 채움',
    paddingRijndael: 'Zero 패딩과 동일',
    paddingISO9797M1: '0x00으로 블록 크기까지 채움',
    paddingISO9797M2: 'ISO 7816-4와 동일',
    mode8BitNote: '참고: 8비트 모드는 한 번에 1바이트를 처리합니다',
    mode64BitNote: '64비트 모드는 한 번에 전체 블록(8바이트)을 처리합니다',
  },

  rsa: {
    title: 'RSA 암호화/복호화',
    description: 'RSA 비대칭 암호화, 복호화, 서명 및 검증',
    rsaInfo: 'RSA 정보',
    rsaInfo1: 'RSA는 비대칭 암호화 알고리즘입니다',
    rsaInfo2: '키 크기: 1024, 2048, 4096비트 (2048 이상 권장)',
    rsaInfo3: 'PKCS#1 v1.5 및 OAEP 패딩 지원',
    tabKeys: '키',
    tabEncrypt: '암호화',
    tabDecrypt: '복호화',
    tabSign: '서명',
    tabVerify: '검증',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA 모듈러스 (16진수)',
    privateExpPlaceholder: 'RSA 개인 지수 (16진수)',
    keyLength: '키 길이',
    generateKeys: '키 생성',
    importKeys: '키 가져오기',
    clearKeys: '지우기',
    keyGenerated: '키 쌍이 성공적으로 생성되었습니다',
    keysCleared: '키가 지워졌습니다',
    keyImported: '공개 키가 성공적으로 가져왔습니다',
    privateKeyImportNote: '개인 키 가져오기에는 전체 CRT 매개변수가 필요합니다. 전체 기능을 사용하려면 "키 생성"을 사용하세요.',
    padding: '패딩',
    hashAlgorithm: '해시 알고리즘',
    data: '데이터',
    dataToEncrypt: '암호화할 데이터',
    dataPlaceholderAscii: '텍스트 데이터 입력',
    encodingMethod: '인코딩 방법',
    private: '개인',
    public: '공개',
    inputDataFormat: '입력 데이터 형식',
    hexadecimal: '16진수',
    paddingMethod: '패딩 방법',
    noPadding: '패딩 없음',
    errorDataRequired: '데이터가 필요합니다',
    privateEncryptNote: '참고: 암호화 데모에 공개 키 사용',
    dataToSign: '서명할 데이터',
    dataToVerify: '검증할 데이터',
    ciphertextToDecrypt: '복호화할 암호문',
    signatureToVerify: '서명',
    dataPlaceholder: '16진수 데이터 입력',
    ciphertextPlaceholder: '암호화된 16진수 데이터 입력',
    signaturePlaceholder: '16진수 서명 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    sign: '서명',
    verify: '검증',
    encryptedResult: '암호화 결과',
    encryptionFinished: '데이터 암호화 작업 완료',
    decryptionFinished: '데이터 복호화 작업 완료',
    decodingMethod: '디코딩 방법',
    copyResult: '결과 복사',
    result: '결과',
    decryptedResult: '복호화 결과',
    signatureResult: '서명',
    signatureValid: '✓ 서명이 유효합니다',
    signatureInvalid: '✗ 서명이 유효하지 않습니다',
    encryptInfo: 'RSA 암호화',
    encryptDesc: '공개 키로 데이터 암호화',
    decryptInfo: 'RSA 복호화',
    decryptDesc: '개인 키로 데이터 복호화',
    signInfo: 'RSA 서명',
    signDesc: '개인 키로 데이터 서명 (RSA-PSS)',
    verifyInfo: 'RSA 서명 검증',
    verifyDesc: '공개 키로 서명 검증 (RSA-PSS)',
    oaepDesc1: 'OAEP는 RSA 암호화에 사용되는 패딩 체계입니다',
    oaepDesc2: 'PKCS#1 v1.5 패딩보다 더 안전합니다',
    oaepDesc3: '선택된 암호문 공격을 방지합니다',
    oaepDesc4: '새로운 애플리케이션에 권장됩니다',
    oaepStructure: 'OAEP 구조',
    maxDataSize: '최대 데이터 크기',
    errorKeyGen: '키 생성 실패',
    errorKeyImport: '키 가져오기 실패',
    errorInvalidModulus: '유효하지 않은 모듈러스',
    errorInvalidPublicExp: '유효하지 않은 공개 지수',
    errorNoPublicKey: '먼저 공개 키를 생성하거나 가져오세요',
    errorNoPrivateKey: '먼저 키 쌍을 생성하세요 (개인 키 필요)',
    errorInvalidData: '유효하지 않은 데이터 (16진수여야 함)',
    errorInvalidCiphertext: '유효하지 않은 암호문 (16진수여야 함)',
    errorInvalidSignature: '유효하지 않은 서명 (16진수여야 함)',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorSign: '서명 실패',
    errorVerify: '검증 실패',
  },

  fpe: {
    title: '형식 보존 암호화',
    description: '형식과 길이를 유지하면서 데이터 암호화 (NIST SP 800-38G)',
    radix: '기수',
    encryptionType: '암호화 유형',
    keyInput: '키 입력',
    useTweak: 'Tweak 사용?',
    fpeInfo: 'FPE 정보',
    formatPreserving: '형식 보존: 출력이 입력과 동일한 형식과 길이를 가짐',
    radixInfo: '현재 기수가 데이터의 유효한 문자 집합을 정의합니다',
    tweakInfo: 'Tweak은 암호화에 추가 입력을 제공합니다 (IV와 유사)',
    minLength: '최소 데이터 길이: 2자',
    dataPlaceholder: '유효한 기수 문자로 데이터 입력',
    tweakPlaceholderFF1: 'Tweak을 16진수로 입력 (임의의 길이)',
    tweakPlaceholderFF3: '16자리 16진수 문자 (8바이트)',
    resultLength: '길이',
    characters: '문자',
    algorithm: '알고리즘',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorDataTooShort: '데이터는 최소 2자여야 합니다',
    errorInvalidDataForRadix: '데이터에 기수 {radix}의 유효하지 않은 문자가 포함되어 있습니다',
    errorInvalidTweakHex: 'Tweak은 유효한 16진수여야 합니다',
    errorTweakLength: '{algorithm}의 Tweak 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    algorithmNotImplemented: '이 알고리즘은 아직 완전히 구현되지 않았습니다',
  },

  // SEO Content
  seo: {
    home: {
      title: 'HSM Kit - 무료 온라인 암호화 및 키 관리 도구',
      description: 'HSM 키 관리를 위한 무료 온라인 암호화 도구. KCV 계산, TR-31 키 블록 파싱, 안전한 키 생성, AES/DES/RSA 암호화 등. 모든 계산은 브라우저에서 실행되어 최고의 보안을 보장합니다.',
      keywords: 'HSM 도구, 암호화 도구키트, 키 관리, KCV 계산기, TR-31 파서, AES 암호화, DES 암호화, RSA 암호화, PIN 블록, 키 생성기, 암호화 도구, 결제 보안',
      faqTitle: '자주 묻는 질문',
      usageTitle: 'HSM Kit 소개',
      faqs: [
        { question: 'HSM Kit은 무료인가요?', answer: '네, HSM Kit은 완전 무료입니다. 등록이나 결제 없이 모든 도구를 사용할 수 있습니다.' },
        { question: '데이터는 안전한가요?', answer: '물론입니다. 모든 암호화 작업은 브라우저(클라이언트 측)에서 완전히 실행됩니다. 데이터가 서버로 전송되는 일은 절대 없습니다.' },
        { question: '어떤 암호화 알고리즘이 지원되나요?', answer: 'HSM Kit은 AES(128/192/256비트), DES, 3DES, RSA, ECC(ECDSA), 형식 보존 암호화(FPE)를 지원합니다.' },
        { question: '결제 보안에 사용할 수 있나요?', answer: '네, HSM Kit에는 PIN 블록 생성, TR-31 키 블록 파싱, KCV 계산 등 결제 보안을 위해 설계된 도구가 포함되어 있습니다.' },
      ],
      usage: [
        'HSM Kit은 보안 전문가, 개발자 및 암호화 작업을 하는 모든 사람을 위해 설계된 포괄적인 암호화 도구 모음입니다.',
        '모든 도구는 브라우저에서 완전히 작동합니다. 서버 통신이 없으므로 민감한 데이터가 장치를 벗어나지 않습니다.',
        '암호화 및 결제 보안 분야의 테스트, 개발 및 교육 목적에 완벽합니다.',
      ],
    },
    asn1: {
      title: 'ASN.1 파서 온라인 - 무료 DER/BER 구조 디코더 | HSM Kit',
      description: '무료 온라인 ASN.1 파서 및 디코더. ASN.1 DER/BER 구조 파싱, X.509 인증서 디코딩, PKCS 형식 분석. 16진수, Base64, PEM 입력 지원 및 RFC 정의 매칭.',
      keywords: 'ASN.1 파서, DER 디코더, BER 디코더, X.509 인증서 파서, PKCS 디코더, ASN1 온라인 도구, 인증서 분석기, PEM 파서',
      faqTitle: 'ASN.1 파서 FAQ',
      usageTitle: 'ASN.1 파서 사용 방법',
      faqs: [
        { question: 'ASN.1이란 무엇인가요?', answer: 'ASN.1(Abstract Syntax Notation One)은 직렬화 및 역직렬화 가능한 데이터 구조를 정의하기 위한 표준 인터페이스 설명 언어입니다. 암호화, 통신, 네트워크 프로토콜에서 널리 사용됩니다.' },
        { question: '이 파서는 어떤 형식을 지원하나요?', answer: '이 파서는 DER(Distinguished Encoding Rules) 및 BER(Basic Encoding Rules)로 인코딩된 ASN.1 구조를 지원합니다. 16진수, Base64 또는 PEM 형식으로 데이터를 입력할 수 있습니다.' },
        { question: 'X.509 인증서를 파싱할 수 있나요?', answer: '네, 이 도구는 X.509 인증서, CSR, PKCS#7/8/12 구조 및 ASN.1 인코딩을 사용하는 기타 인증서 형식을 파싱할 수 있습니다.' },
        { question: '16진수 덤프 기능이란 무엇인가요?', answer: '16진수 덤프 기능은 파싱된 트리 뷰 옆에 ASN.1 구조의 원시 바이트를 표시하여 바이너리 인코딩의 이해를 돕습니다.' },
      ],
      usage: [
        'ASN.1 인코딩 데이터를 16진수, Base64 또는 PEM 형식으로 입력 필드에 붙여넣습니다.',
        '"파싱"을 클릭하여 구조를 디코딩하고 계층적 트리 표현을 봅니다.',
        '"16진수 덤프 포함"을 활성화하면 파싱된 구조 옆에 원시 바이트를 볼 수 있습니다.',
        '"정의 포함"을 사용하여 X.509, PKCS 등 알려진 RFC 정의와 구조를 매칭합니다.',
      ],
    },
    aes: {
      title: 'AES 암호화/복호화 온라인 - 무료 AES 계산기 | HSM Kit',
      description: '무료 온라인 AES 암호화 및 복호화 도구. ECB, CBC, CFB, OFB, CTR 모드로 AES-128, AES-192, AES-256 지원. KCV 계산, 브라우저에서 안전하게 16진수 또는 텍스트 데이터 암호화/복호화.',
      keywords: 'AES 암호화, AES 복호화, AES-128, AES-192, AES-256, AES 계산기, AES 온라인 도구, AES ECB, AES CBC, AES KCV',
      faqTitle: 'AES 암호화 FAQ',
      usageTitle: 'AES 암호화 도구 사용 방법',
      faqs: [
        { question: 'AES 암호화란 무엇인가요?', answer: 'AES(Advanced Encryption Standard)는 전 세계 표준이 된 대칭 블록 암호입니다. 128, 192 또는 256비트 키를 사용하여 128비트 블록 단위로 데이터를 암호화합니다.' },
        { question: '어떤 AES 모드를 사용해야 하나요?', answer: 'CBC 모드는 대부분의 응용 프로그램에서 일반적으로 권장됩니다. ECB 모드는 한 블록보다 큰 데이터 암호화에는 패턴이 드러나므로 피해야 합니다. CTR 모드는 스트리밍 데이터에 적합합니다.' },
        { question: 'AES가 지원하는 키 크기는?', answer: 'AES는 세 가지 키 크기를 지원합니다: AES-128(16바이트), AES-192(24바이트), AES-256(32바이트). 키가 길수록 보안이 강화됩니다.' },
        { question: 'AES 암호화에서 IV란 무엇인가요?', answer: 'IV(초기화 벡터)는 CBC, CFB, OFB, CTR 등의 모드에서 사용되는 랜덤 값으로, 동일한 평문이 다른 암호문을 생성하도록 보장합니다. IV는 고유해야 하지만 비밀일 필요는 없습니다.' },
      ],
      usage: [
        'AES 키 크기(128, 192 또는 256비트)와 암호화 모드(ECB, CBC 등)를 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'ECB 이외의 모드에서는 IV(16바이트 16진수)를 제공합니다.',
        '암호화 또는 복호화할 데이터를 입력하고 해당 버튼을 클릭합니다.',
      ],
    },
    des: {
      title: 'DES/3DES 암호화 온라인 - 무료 트리플 DES 계산기 | HSM Kit',
      description: '무료 온라인 DES 및 트리플 DES(3DES) 암호화 및 복호화 도구. DES, 2키 3DES, 3키 3DES를 ECB/CBC 모드로 지원. PKCS5, ISO 7816 등 다양한 패딩 옵션.',
      keywords: 'DES 암호화, 3DES 암호화, 트리플 DES, DES 복호화, DES 계산기, 3DES 온라인 도구, TDES, DES ECB, DES CBC',
      faqTitle: 'DES/3DES 암호화 FAQ',
      usageTitle: 'DES/3DES 도구 사용 방법',
      faqs: [
        { question: 'DES와 3DES의 차이점은?', answer: 'DES는 단일 56비트 키(패리티 포함 8바이트)를 사용하고, 3DES는 2개 또는 3개의 다른 키(16 또는 24바이트)로 DES 알고리즘을 3번 적용하여 훨씬 강력한 보안을 제공합니다.' },
        { question: 'DES는 아직 안전한가요?', answer: '단일 DES는 안전하지 않고 더 이상 사용되지 않습니다. 3DES는 레거시 시스템, 특히 결제 산업에서 여전히 사용되지만, 새 응용 프로그램에는 AES가 권장됩니다.' },
        { question: 'DES 키의 패리티 비트란?', answer: 'DES에서 키의 각 바이트에는 하나의 패리티 비트(최하위 비트)가 있어 유효 키 길이가 64비트에서 56비트가 됩니다. 이 도구는 패리티 비트를 자동으로 조정할 수 있습니다.' },
        { question: '어떤 패딩을 사용해야 하나요?', answer: 'PKCS5/PKCS7이 가장 일반적인 선택입니다. ISO 9797은 은행 응용 프로그램에서 자주 사용됩니다. 선택은 상대방이 기대하는 것과 일치해야 합니다.' },
      ],
      usage: [
        'DES(8바이트 키) 또는 3DES(16 또는 24바이트 키)를 선택합니다.',
        '암호화 모드(ECB 또는 CBC)와 패딩 방법을 선택합니다.',
        '키를 16진수 형식으로 입력합니다.',
        'CBC 모드의 경우 IV(8바이트 16진수)를 제공합니다.',
        '데이터를 입력하고 암호화 또는 복호화를 클릭합니다.',
      ],
    },
    rsa: {
      title: 'RSA 암호화 온라인 - 무료 RSA 계산기 및 키 생성기 | HSM Kit',
      description: '무료 온라인 RSA 암호화, 복호화, 서명, 검증 도구. RSA 키 쌍(1024-4096비트) 생성, 공개 키로 암호화, 개인 키로 서명. PKCS#1 및 OAEP 패딩 지원.',
      keywords: 'RSA 암호화, RSA 복호화, RSA 키 생성기, RSA 계산기, RSA 온라인 도구, RSA 서명, RSA 검증, 공개 키 암호화, PKCS1, OAEP',
      faqTitle: 'RSA 암호화 FAQ',
      usageTitle: 'RSA 도구 사용 방법',
      faqs: [
        { question: 'RSA 암호화란 무엇인가요?', answer: 'RSA는 공개 키로 암호화하고 개인 키로 복호화하는 키 쌍을 사용하는 비대칭 암호화 알고리즘입니다. 안전한 데이터 전송과 디지털 서명에 널리 사용됩니다.' },
        { question: '어떤 키 크기를 사용해야 하나요?', answer: '현재 보안 표준에서 2048비트 키가 최소로 간주됩니다. 장기 보안을 위해 4096비트 키가 권장됩니다. 1024비트 키는 더 이상 권장되지 않습니다.' },
        { question: 'PKCS#1과 OAEP의 차이점은?', answer: 'PKCS#1 v1.5는 오래된 패딩 체계입니다. OAEP(최적 비대칭 암호화 패딩)는 더 안전하며 특정 공격을 방지하므로 새 응용 프로그램에 권장됩니다.' },
        { question: 'RSA 암호화의 최대 데이터 크기는?', answer: 'RSA는 키 크기에서 패딩 오버헤드를 뺀 크기보다 작은 데이터만 암호화할 수 있습니다. OAEP-SHA256이 있는 2048비트 키의 경우 최대 약 190바이트입니다. 더 큰 데이터에는 하이브리드 암호화를 사용하세요.' },
      ],
      usage: [
        '새 RSA 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '암호화: 평문을 입력하고 암호화 클릭(공개 키 사용).',
        '복호화: 암호문을 입력하고 복호화 클릭(개인 키 필요).',
        '서명: 데이터 해시를 입력하고 서명 클릭(개인 키 필요).',
        '검증: 데이터, 서명을 입력하고 검증 클릭(공개 키 사용).',
      ],
    },
    ecc: {
      title: 'ECC/ECDSA 온라인 도구 - 타원 곡선 암호화 | HSM Kit',
      description: '무료 온라인 ECC(타원 곡선 암호화) 도구. ECDSA 키 쌍 생성, secp256k1, P-256, P-384 곡선으로 데이터 서명 및 검증. 컴팩트한 키로 강력한 보안.',
      keywords: 'ECC 암호화, ECDSA, 타원 곡선, secp256k1, P-256, P-384, ECC 키 생성기, ECDSA 서명, ECDSA 검증, 비트코인 암호화',
      faqTitle: 'ECC/ECDSA FAQ',
      usageTitle: 'ECC/ECDSA 도구 사용 방법',
      faqs: [
        { question: 'ECC란 무엇인가요?', answer: '타원 곡선 암호화(ECC)는 타원 곡선의 대수적 구조에 기반한 공개 키 암호화 접근 방식입니다. RSA와 동등한 보안을 훨씬 작은 키 크기로 제공합니다.' },
        { question: 'secp256k1이란 무엇인가요?', answer: 'secp256k1은 비트코인과 이더리움이 디지털 서명에 사용하는 타원 곡선입니다. 보안과 성능의 좋은 균형을 제공합니다.' },
        { question: 'RSA 대신 ECC를 사용하는 이유는?', answer: 'ECC는 RSA와 동일한 보안 수준을 훨씬 작은 키로 제공합니다(256비트 ECC ≈ 3072비트 RSA). 이로 인해 더 빠른 작업과 저장/대역폭 요구 사항 감소가 가능합니다.' },
        { question: 'ECDSA란 무엇인가요?', answer: 'ECDSA(타원 곡선 디지털 서명 알고리즘)는 ECC에 기반한 서명 알고리즘입니다. 데이터의 진위를 검증할 수 있는 디지털 서명을 만드는 데 사용됩니다.' },
      ],
      usage: [
        '타원 곡선(secp256k1, P-256 또는 P-384)을 선택합니다.',
        '새 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '서명: 데이터(또는 해시)를 입력하고 서명 클릭.',
        '검증: 원본 데이터, 서명을 입력하고 검증 클릭.',
      ],
    },
    fpe: {
      title: '형식 보존 암호화(FPE) 온라인 - FF1/FF3-1 도구 | HSM Kit',
      description: 'NIST SP 800-38G를 구현한 무료 온라인 형식 보존 암호화 도구. 형식과 길이를 보존하면서 데이터 암호화. 신용카드 번호, 주민등록번호 등 구조화된 데이터의 토큰화에 이상적.',
      keywords: 'FPE, 형식 보존 암호화, FF1, FF3, FF3-1, NIST 800-38G, 토큰화, 신용카드 암호화, 데이터 마스킹, PCI DSS',
      faqTitle: '형식 보존 암호화 FAQ',
      usageTitle: 'FPE 도구 사용 방법',
      faqs: [
        { question: '형식 보존 암호화란 무엇인가요?', answer: 'FPE는 평문과 동일한 형식과 길이의 암호문을 생성하는 암호화 방법입니다. 예를 들어, 16자리 신용카드 번호는 다른 16자리 숫자로 암호화됩니다.' },
        { question: 'FF1과 FF3-1의 차이점은?', answer: '둘 다 NIST 승인 FPE 알고리즘입니다. FF1은 가변 길이 트윅을 지원하고, FF3-1은 고정 56비트 트윅을 사용합니다. FF3-1은 일반적으로 더 빠르지만 제약이 더 많습니다.' },
        { question: '토큰화란 무엇인가요?', answer: '토큰화는 민감한 데이터를 비민감 플레이스홀더(토큰)로 대체합니다. FPE는 토큰이 원래 데이터 형식을 유지하기 때문에 토큰화에 자주 사용됩니다.' },
        { question: 'FPE는 PCI DSS를 준수하나요?', answer: '네, NIST SP 800-38G 승인 알고리즘(FF1, FF3-1)을 사용한 FPE는 올바르게 구현된 경우 PCI DSS 준수에 허용됩니다.' },
      ],
      usage: [
        'FPE 알고리즘(FF1 또는 FF3-1)과 기수(숫자 기반)를 선택합니다.',
        'AES 키(16, 24 또는 32바이트 16진수)를 입력합니다.',
        '추가 보안을 위해 선택적으로 트윅 값을 제공합니다.',
        '평문 데이터를 입력하고 암호화를 클릭하여 형식 보존 암호문을 생성합니다.',
      ],
    },
    keyGenerator: {
      title: '보안 키 생성기 온라인 - 랜덤 AES/DES 키 생성기 | HSM Kit',
      description: '무료 온라인 암호화 키 생성기. AES, DES, 3DES 암호화를 위한 안전한 랜덤 키 생성. 키 결합(XOR), 패리티 조정, 키 검증 도구 포함.',
      keywords: '키 생성기, 랜덤 키, AES 키 생성기, DES 키 생성기, 3DES 키 생성기, 암호화 키, 보안 랜덤, 키 결합, XOR 키',
      faqTitle: '키 생성기 FAQ',
      usageTitle: '키 생성기 사용 방법',
      faqs: [
        { question: '랜덤 키는 어떻게 생성되나요?', answer: '키는 Web Crypto API(crypto.getRandomValues)를 사용하여 생성됩니다. 이는 암호화 키에 적합한 암호학적으로 안전한 난수를 제공합니다.' },
        { question: '키 결합(XOR)이란 무엇인가요?', answer: '키 결합은 여러 키 구성 요소를 XOR하여 완전한 키를 형성할 수 있게 합니다. 이는 여러 관리인이 각각 구성 요소를 보유하는 의식에서 일반적으로 사용됩니다.' },
        { question: '패리티 비트란 무엇인가요?', answer: 'DES/3DES 키에서 각 바이트에는 오류 감지를 위한 패리티 비트가 있습니다. 이 도구는 DES 표준에서 요구하는 홀수 패리티로 패리티 비트를 자동 조정할 수 있습니다.' },
        { question: '지원되는 키 길이는?', answer: '생성기는 DES(8바이트/64비트), 2키 3DES(16바이트/128비트), 3키 3DES(24바이트/192비트) 및 AES-128/192/256을 지원합니다.' },
      ],
      usage: [
        '드롭다운에서 원하는 키 길이를 선택합니다.',
        '"생성"을 클릭하여 새 랜덤 키를 만듭니다.',
        '키 결합 탭을 사용하여 여러 구성 요소를 XOR합니다.',
        '패리티 탭을 사용하여 DES/3DES 키의 패리티 비트를 조정합니다.',
        '검증 탭을 사용하여 키가 올바른 형식과 패리티를 가지고 있는지 확인합니다.',
      ],
    },
    tr31: {
      title: 'TR-31 키 블록 파서 온라인 - ANSI X9.143 디코더 | HSM Kit',
      description: '무료 온라인 TR-31 키 블록 파서 및 분석기. ANSI X9.143(TR-31) 키 블록을 디코딩하고 버전, 키 용도, 알고리즘, 내보내기 가능성, 선택적 블록을 봅니다. 결제 HSM 운영에 필수적인 도구.',
      keywords: 'TR-31, 키 블록, ANSI X9.143, TR31 파서, 키 블록 디코더, 결제 HSM, 키 용도, 키 내보내기 가능성, DUKPT, 키 관리',
      faqTitle: 'TR-31 키 블록 FAQ',
      usageTitle: 'TR-31 파서 사용 방법',
      faqs: [
        { question: 'TR-31이란 무엇인가요?', answer: 'TR-31(현재 ANSI X9.143)은 결제 산업에서 안전한 키 교환을 위한 표준 형식입니다. 키 용도, 알고리즘, 내보내기 가능성 규칙 등의 메타데이터로 암호화 키를 래핑합니다.' },
        { question: 'TR-31의 버전은?', answer: '버전 A/B는 TDES 키 래핑을 사용하고, 버전 C는 변형 바인딩이 있는 TDES를 사용하고, 버전 D는 AES 키 래핑(가장 안전)을 사용하고, 버전 E는 변형 바인딩이 있는 AES를 사용합니다.' },
        { question: 'TR-31의 키 용도란?', answer: '키 용도(P0, B0, D0 등의 2자)는 래핑된 키의 사용 방법을 정의합니다. P0은 PIN 암호화용, B0은 BDK(기본 파생 키)용, D0은 데이터 암호화용 등입니다.' },
        { question: '내보내기 가능성이란?', answer: '내보내기 가능성 플래그는 키를 내보낼 수 있는지 나타냅니다: E=내보내기 가능, N=내보내기 불가, S=민감(특정 조건에서 내보내기 가능).' },
      ],
      usage: [
        'TR-31 키 블록 문자열을 입력 필드에 붙여넣습니다.',
        '"키 블록 파싱"을 클릭하여 구조를 디코딩합니다.',
        '버전, 길이, 키 용도를 포함한 헤더 정보를 봅니다.',
        '알고리즘, 모드, 키 버전, 내보내기 가능성 설정을 검사합니다.',
      ],
    },
    kcv: {
      title: 'KCV 계산기 온라인 - 키 체크 값 생성기 | HSM Kit',
      description: 'AES 및 DES/3DES 키용 무료 온라인 KCV(키 체크 값) 계산기. 체크 값을 계산하여 암호화 키의 정확성을 검증합니다. DES 키의 자동 패리티 조정 지원.',
      keywords: 'KCV 계산기, 키 체크 값, KCV 생성기, AES KCV, DES KCV, 3DES KCV, CMAC, 키 검증, 결제 키',
      faqTitle: 'KCV 계산기 FAQ',
      usageTitle: 'KCV 계산기 사용 방법',
      faqs: [
        { question: 'KCV(키 체크 값)란 무엇인가요?', answer: 'KCV는 암호화 키가 올바르게 입력되거나 전송되었는지 확인하는 데 사용되는 체크섬입니다. 0의 블록을 암호화하고 결과의 처음 3바이트를 취하여 계산됩니다.' },
        { question: 'DES/3DES의 KCV는 어떻게 계산되나요?', answer: 'DES/3DES의 경우: ECB 모드로 8바이트 0(0x0000000000000000)을 암호화한 다음 암호문의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: 'AES의 KCV는 어떻게 계산되나요?', answer: 'AES의 경우: 키를 사용하여 16바이트 0에 대해 CMAC를 계산한 다음 MAC 값의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: '자동 패리티 조정이란?', answer: 'DES 키는 각 바이트에 홀수 패리티가 필요합니다. 키에 올바른 패리티가 없으면 자동 조정을 활성화하여 KCV 계산 전에 수정할 수 있습니다.' },
      ],
      usage: [
        '알고리즘(AES 또는 DES/3DES)을 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'DES 키의 경우 선택적으로 자동 패리티 조정을 활성화합니다.',
        '"KCV 계산"을 클릭하여 키 체크 값을 생성합니다.',
        'KCV를 예상 값과 비교하여 키의 정확성을 검증합니다.',
      ],
    },
    pinBlock: {
      title: 'PIN 블록 생성기 온라인 - ISO 9564 형식 0/1/3/4 | HSM Kit',
      description: 'ISO 9564 형식(형식 0, 1, 3, 4)을 지원하는 무료 온라인 PIN 블록 생성기. 결제 거래, ATM, POS 시스템용 PIN 블록 생성. 결제 보안 테스트에 필수적인 도구.',
      keywords: 'PIN 블록, ISO 9564, PIN 블록 형식 0, PIN 블록 형식 4, 결제 보안, ATM PIN, POS PIN, PIN 암호화, 카드 PIN',
      faqTitle: 'PIN 블록 FAQ',
      usageTitle: 'PIN 블록 생성기 사용 방법',
      faqs: [
        { question: 'PIN 블록이란 무엇인가요?', answer: 'PIN 블록은 암호화 전에 PIN(개인 식별 번호)을 인코딩하기 위한 표준화된 형식입니다. PIN을 채우기 패턴 또는 PAN 데이터와 결합하여 암호화용 고정 길이 블록을 만듭니다.' },
        { question: '형식 0(ISO 9564-1)이란?', answer: '형식 0은 PIN 블록을 PAN의 오른쪽 12자리(체크 디지트 제외)와 XOR합니다. 결제 시스템에서 가장 널리 사용되는 형식입니다.' },
        { question: '형식 4(ISO 9564-1:2017)란?', answer: '형식 4는 AES 암호화를 위해 설계된 최신 형식입니다. 랜덤 패딩을 포함하며 이전 형식보다 더 나은 보안을 제공합니다.' },
        { question: 'PIN 블록에 PAN이 필요한 이유는?', answer: '형식 0 및 일부 형식에서 PAN은 PIN 데이터와 XOR되어 PIN을 특정 카드에 바인딩하고 특정 공격을 방지합니다.' },
      ],
      usage: [
        'PIN 블록 형식(0, 1, 3 또는 4)을 선택합니다.',
        'PIN(4-12자리)을 입력합니다.',
        'PAN이 필요한 형식의 경우 카드 번호를 입력합니다.',
        '"생성"을 클릭하여 PIN 블록을 만듭니다.',
        '생성된 16진수 문자열을 암호화 프로세스의 입력으로 사용합니다.',
      ],
    },
    hash: {
      title: '해시 계산기 온라인 - MD5, SHA-256, SHA-512, BLAKE2 | HSM Kit',
      description: 'MD5, SHA-1, SHA-256, SHA-512, RIPEMD-160, WHIRLPOOL, BLAKE2, CRC32 등을 지원하는 무료 온라인 해시 계산기. 텍스트 또는 16진수 입력에서 해시 값 계산.',
      keywords: '해시 계산기, MD5 해시, SHA-256 해시, SHA-512 해시, BLAKE2, RIPEMD-160, WHIRLPOOL, CRC32, 해시 생성기, 체크섬 계산기',
      faqTitle: '해시 계산기 FAQ',
      usageTitle: '해시 계산기 사용 방법',
      faqs: [
        { question: '해시 함수란?', answer: '해시 함수는 임의 크기의 입력 데이터를 고정 크기 출력(해시 값)으로 변환하는 수학적 알고리즘입니다.' },
        { question: '어떤 해시 알고리즘을 사용해야 하나요?', answer: '보안 목적으로 SHA-256 또는 SHA-512를 사용하세요. MD5와 SHA-1은 암호화 용도로 안전하지 않습니다.' },
        { question: 'MD5와 SHA-256의 차이점은?', answer: 'MD5는 128비트 해시를 생성하며 빠르지만 암호학적으로 깨졌습니다. SHA-256은 256비트 해시를 생성하며 현재 암호학적으로 안전합니다. 보안 중심 애플리케이션에는 SHA-256을 사용하세요.' },
        { question: '해시를 복호화할 수 있나요?', answer: '아니요, 해시 함수는 설계상 단방향 함수입니다. 해시에서 원래 입력을 복구할 수 없습니다. 이 특성 때문에 비밀번호 저장 및 데이터 무결성 검증에 유용합니다.' },
      ],
      usage: ['입력 유형 선택', '알고리즘 선택', '데이터 입력', '"계산" 클릭'],
    },
    encoding: {
      title: '문자 인코딩 변환기 온라인 - ASCII, EBCDIC, Hex | HSM Kit',
      description: '무료 온라인 문자 인코딩 변환기. ASCII, EBCDIC, 16진수, 바이너리, ATM 10진수 형식 간 변환.',
      keywords: '문자 인코딩, ASCII EBCDIC 변환, 16진수 변환기, 바이너리 변환기, EBCDIC 변환기, ATM 10진수',
      faqTitle: '문자 인코딩 FAQ',
      usageTitle: '인코딩 변환기 사용 방법',
      faqs: [
        { question: '문자 인코딩이란?', answer: '문자 인코딩은 각 문자를 고유한 숫자나 바이트 시퀀스와 연결하는 시스템입니다.' },
        { question: 'EBCDIC란?', answer: 'EBCDIC는 주로 IBM 메인프레임에서 사용되는 8비트 문자 인코딩입니다.' },
        { question: 'ASCII와 EBCDIC 변환이 필요한 이유는?', answer: '많은 레거시 은행 및 금융 시스템이 EBCDIC를 사용하는 IBM 메인프레임에서 실행됩니다. 모던 시스템(ASCII/UTF-8 사용)과 이러한 메인프레임 통합 시 문자 변환이 필수적입니다.' },
        { question: 'ATM 10진 인코딩이란?', answer: 'ATM 10진은 ATM 통신에서 사용되는 특정 인코딩으로, 각 숫자(0-9)가 ASCII 코드로 표현됩니다. 금융 메시징 프로토콜에서 일반적으로 사용됩니다.' },
      ],
      usage: ['변환 유형 선택', '데이터 입력', '"변환" 클릭'],
    },
    bcd: {
      title: 'BCD 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 BCD 인코더 및 디코더. 10진수를 BCD로 변환하거나 BCD를 10진수로 변환.',
      keywords: 'BCD 인코더, BCD 디코더, 이진화 10진수, 10진수 BCD 변환',
      faqTitle: 'BCD FAQ',
      usageTitle: 'BCD 도구 사용 방법',
      faqs: [
        { question: 'BCD란?', answer: '이진화 10진수(BCD)는 각 10진수를 4비트로 표현하는 인코딩입니다.' },
        { question: 'BCD를 사용하는 이유는?', answer: 'BCD는 정확한 10진 표현이 중요한 금융 애플리케이션에서 사용됩니다.' },
        { question: '팩드 BCD와 언팩드 BCD의 차이점은?', answer: '팩드 BCD는 1바이트에 2개의 10진수를 저장합니다(각 4비트). 언팩드 BCD는 각 10진수가 1바이트 전체를 차지합니다. 팩드 BCD가 공간 효율이 더 높습니다.' },
        { question: 'BCD는 어디서 일반적으로 사용되나요?', answer: 'BCD는 금융 시스템, 계산기, 디지털 시계 및 10진 정밀도가 중요한 애플리케이션에서 널리 사용됩니다. 결제 단말기와 ATM은 금액 표시에 BCD를 자주 사용합니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    checkDigits: {
      title: '체크 디지트 계산기 온라인 - Luhn MOD 10, MOD 9 | HSM Kit',
      description: '무료 온라인 체크 디지트 계산기 및 검증기. Luhn(MOD 10) 및 MOD 9로 체크 디지트 생성 또는 검증.',
      keywords: '체크 디지트 계산기, Luhn 알고리즘, MOD 10, MOD 9, 신용카드 검증',
      faqTitle: '체크 디지트 FAQ',
      usageTitle: '체크 디지트 계산기 사용 방법',
      faqs: [
        { question: '체크 디지트란?', answer: '체크 디지트는 오류 검출을 위해 숫자에 추가되는 숫자입니다.' },
        { question: 'Luhn 알고리즘이란?', answer: 'Luhn 알고리즘(MOD 10)은 신용카드 번호 등을 검증하는 체크섬 공식입니다.' },
        { question: '어떤 번호가 Luhn 알고리즘을 사용하나요?', answer: '신용카드 번호(Visa, MasterCard, Amex), IMEI 번호, NPI(의료 제공자 식별자), 캐나다 사회보험번호 등 많은 식별 번호가 Luhn 검증을 사용합니다.' },
        { question: 'Amex SE MOD 9 알고리즘이란?', answer: 'Amex SE(서비스 시설) MOD 9 알고리즘은 American Express가 가맹점/서비스 시설 번호를 검증하는 데 사용합니다. Luhn과 다른 계산 방법을 사용합니다.' },
      ],
      usage: ['알고리즘 선택', '검증 또는 생성 선택', '숫자 입력'],
    },
    base64: {
      title: 'Base64 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 Base64 인코더 및 디코더. 텍스트를 Base64로 변환하거나 Base64를 텍스트로 변환.',
      keywords: 'Base64 인코더, Base64 디코더, Base64 변환, 바이너리 텍스트 변환',
      faqTitle: 'Base64 FAQ',
      usageTitle: 'Base64 도구 사용 방법',
      faqs: [
        { question: 'Base64란?', answer: 'Base64는 64문자를 사용하여 바이너리 데이터를 ASCII 문자열로 변환하는 인코딩입니다.' },
        { question: 'Base64를 사용하는 이유는?', answer: 'Base64는 텍스트 기반 프로토콜에서 바이너리 데이터를 전송하는 데 사용됩니다.' },
        { question: 'Base64는 암호화를 제공하나요?', answer: '아니요, Base64는 인코딩 체계이지 암호화가 아닙니다. 누구나 Base64 데이터를 디코딩할 수 있습니다. 데이터 표현용이며 보안용이 아닙니다.' },
        { question: 'Base64가 데이터 크기를 증가시키는 이유는?', answer: 'Base64는 3바이트의 바이너리 데이터를 4개의 ASCII 문자로 인코딩하여 약 33% 크기 증가가 발생합니다. 입력 길이가 3으로 나누어지지 않으면 패딩 문자 "="가 사용됩니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    base94: {
      title: 'Base94 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 Base94 인코더 및 디코더. 94개의 출력 가능한 ASCII 문자를 사용한 컴팩트 인코딩.',
      keywords: 'Base94 인코더, Base94 디코더, 컴팩트 인코딩',
      faqTitle: 'Base94 FAQ',
      usageTitle: 'Base94 도구 사용 방법',
      faqs: [
        { question: 'Base94란?', answer: 'Base94는 94개의 출력 가능한 ASCII 문자를 사용하는 인코딩으로 Base64보다 효율적입니다.' },
        { question: 'Base94를 사용하는 이유는?', answer: 'Base94는 Base64보다 약 20% 더 컴팩트한 인코딩을 제공합니다.' },
        { question: 'Base94는 어떤 문자를 사용하나요?', answer: 'Base94는 !(0x21)부터 ~(0x7E)까지의 94개 출력 가능 ASCII 문자를 사용하며, 공백은 제외됩니다. 문자, 숫자, 모든 표준 구두점이 포함됩니다.' },
        { question: '언제 Base94를 사용해야 하나요?', answer: '바이너리 데이터의 컴팩트한 텍스트 표현이 필요하고, 전송/저장 시스템이 모든 출력 가능 ASCII 문자를 지원하는 경우 Base94를 사용합니다. URL, QR 코드, 저장 최적화에 적합합니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    messageParser: {
      title: '메시지 파서 온라인 - ATM NDC, Wincor, ISO 8583 | HSM Kit',
      description: '무료 온라인 ATM 및 금융 메시지 파서. ATM NDC, Wincor, ISO 8583 메시지 형식 구문 분석.',
      keywords: '메시지 파서, ATM NDC, ATM Wincor, ISO 8583, 금융 메시지',
      faqTitle: '메시지 파서 FAQ',
      usageTitle: '메시지 파서 사용 방법',
      faqs: [
        { question: 'ATM NDC란?', answer: 'NDC(NCR Direct Connect)는 NCR ATM이 호스트 시스템과 통신하는 프로토콜입니다.' },
        { question: 'ISO 8583이란?', answer: 'ISO 8583은 금융 거래 메시지의 국제 표준입니다.' },
        { question: 'Wincor/Nixdorf 프로토콜이란?', answer: 'Wincor Nixdorf(현 Diebold Nixdorf) 프로토콜은 NDC와 유사하지만 벤더 고유 변형이 있는 독점 ATM 통신 프로토콜입니다. 유럽과 아시아 시장에서 널리 사용됩니다.' },
        { question: '메시지 형식을 어떻게 식별하나요?', answer: 'NDC 메시지는 일반적으로 특정 메시지 클래스 식별자로 시작합니다. ISO 8583 메시지는 4자리 MTI(메시지 유형 식별자)로 시작합니다. 16진 덤프 구조가 사용 중인 프로토콜을 식별하는 데 도움이 됩니다.' },
      ],
      usage: ['메시지 형식 선택', '16진수 데이터 입력', '"구문 분석" 클릭'],
    },
    rsaDer: {
      title: 'RSA DER 공개키 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 RSA DER 공개키 인코더 및 디코더. 모듈러스/지수와 DER ASN.1 형식 간 변환.',
      keywords: 'RSA DER, RSA 공개키, DER 인코딩, ASN.1, PEM 형식',
      faqTitle: 'RSA DER 공개키 FAQ',
      usageTitle: 'RSA DER 도구 사용 방법',
      faqs: [
        { question: 'DER 인코딩이란?', answer: 'DER(Distinguished Encoding Rules)은 ASN.1 데이터 구조를 인코딩하는 바이너리 형식입니다.' },
        { question: 'PEM 형식이란?', answer: 'PEM은 헤더/푸터 줄이 있는 DER의 Base64 인코딩 버전입니다.' },
        { question: 'RSA의 모듈러스와 지수란?', answer: '모듈러스(n)는 두 큰 소수의 곱으로 키 크기를 결정합니다. 공개 지수(e)는 일반적으로 65537(0x10001)입니다. 이 둘이 함께 공개키를 구성합니다.' },
        { question: '인증서에서 모듈러스를 어떻게 추출하나요?', answer: '이 도구를 사용하여 DER/PEM 인코딩된 공개키를 디코딩하세요. 파서가 모듈러스와 지수를 다양한 형식(16진수, 10진수, Base64)으로 추출하여 표시합니다.' },
      ],
      usage: ['인코드: 모듈러스와 지수 입력', '디코드: DER 또는 PEM 데이터 붙여넣기'],
    },
    uuid: {
      title: 'UUID 생성기 온라인 - 버전 1, 3, 4, 5 | HSM Kit',
      description: '무료 온라인 UUID 생성기. 버전 1(시간 기반), 3(MD5), 4(랜덤), 5(SHA-1) 지원.',
      keywords: 'UUID 생성기, GUID 생성기, UUID v4, UUID v1, 랜덤 UUID',
      faqTitle: 'UUID 생성기 FAQ',
      usageTitle: 'UUID 생성기 사용 방법',
      faqs: [
        { question: 'UUID란?', answer: 'UUID(범용 고유 식별자)는 시간과 공간에서 고유한 128비트 식별자입니다.' },
        { question: '어떤 UUID 버전을 사용해야 하나요?', answer: '버전 4(랜덤)가 가장 일반적이고 권장됩니다.' },
        { question: 'UUID와 GUID의 차이점은?', answer: 'UUID와 GUID(전역 고유 식별자)는 동일합니다. GUID는 Microsoft의 용어이고, UUID는 표준(RFC 4122)의 용어입니다. 동일한 형식, 동일한 목적입니다.' },
        { question: 'UUID는 정말 고유한가요?', answer: 'UUID v4의 충돌 확률은 약 2^122분의 1로, 10억 개를 생성해도 중복 확률이 극히 낮습니다. 실용적으로 고유하다고 봐도 안전합니다.' },
      ],
      usage: ['UUID 버전 선택', '생성 개수 입력', '"생성" 클릭'],
    },
  },
};

