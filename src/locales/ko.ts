// Korean translations
export default {
  common: {
    copy: '복사',
    generate: '생성',
    calculate: '계산',
    parse: '구문 분석',
    clear: '지우기',
    copied: '클립보드에 복사되었습니다!',
    error: '오류',
    result: '결과',
    loading: '로딩 중...',
    close: '닫기',
    cancel: '취소',
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: '키 생성',
    tr31: 'TR-31',
    kcv: 'KCV',
    pinBlock: 'PIN 블록',
    asn1: 'ASN.1',
    cipher: '암호화',
    generic: '일반 도구',
    hashes: '해시',
    characterEncoding: '문자 인코딩',
    bcd: 'BCD',
    checkDigits: '체크 디지트',
    base64: 'Base64',
    base94: 'Base94',
    messageParser: '메시지 파서',
    rsaDerPublicKey: 'RSA DER 공개키',
    uuid: 'UUID',
    // PKI 메뉴
    pki: 'PKI',
    asn1Decoder: 'ASN.1 디코더',
    sslCertificates: 'SSL 인증서',
    // Keys 메뉴
    keys: '키',
    keysDea: 'Keys DEA',
    keyshareGenerator: 'Keyshare Generator',
    keysHsm: 'Keys HSM',
    keysFuturex: 'Keys Futurex',
    keysAtalla: 'Keys Atalla',
    keysSafeNet: 'Keys SafeNet',
    keysThales: 'Keys Thales',
    keyBlocks: 'Key Blocks',
    thalesKeyBlock: 'Thales Key Block',
    tr31KeyBlock: 'TR-31 Key Block',
    // Payments 메뉴
    payments: 'Payments',
    as2805: 'AS2805',
    bitmap: 'Bitmap',
    cardValidation: 'Card Validation',
    cvvs: 'CVVs',
    amexCscs: 'AMEX CSCs',
    mastercardCvc3: 'MasterCard dynamic CVC3',
    dukpt: 'DUKPT',
    dukptIso9797: 'DUKPT (ISO 9797)',
    dukptAes: 'DUKPT (AES)',
    macAlgorithms: 'MAC Algorithms',
    iso9797_1: 'ISO/IEC 9797-1',
    ansix9: 'ANSI X9.9 & X9.19',
    as2805_4_1: 'AS2805.4.1',
    tdesCbcMac: 'TDES CBC-MAC',
    hmac: 'HMAC',
    cmac: 'CMAC',
    retail: 'Retail',
    pinBlocks: 'PIN Blocks',
    pinBlocksGeneral: 'PIN Blocks General',
    pinBlocksAes: 'PIN Blocks AES',
    pinOffset: 'PIN Offset',
    pinPvv: 'PIN PVV',
    visaCertificates: 'Visa Certificates',
    zka: 'ZKA',
  },
  
  as2805: {
    infoTitle: 'AS2805 도구 소개',
    info1: '터미널 키 세트, PIN 블록 변환, MAC 및 OWF 포함',
    description: '결제 관련 일반 작업을 브라우저에서 구현',
    tabGenerate: '터미널 키 세트 생성',
    tabTranslatePin: 'PIN 블록 변환',
    kekFlag: 'KEK 플래그',
    kekrKey: 'KEKr 키',
    schemeKek: 'KEK 키 스킴',
    schemeLmk: 'LMK 키 스킴',
    kcvType: 'KCV 유형',
    translate: '변환',
    sysZpk: '시스템 ZPK',
    termTpk: '터미널 TPK',
    stan: 'STAN',
    amount: '거래 금액',
    inFmt: '수신 PIN 블록 형식',
    outFmt: '발신 PIN 블록 형식',
    inPinBlock: '수신 PIN 블록',
    account: '계좌 번호',
    key: '키',
    data: '데이터',
    errorInvalidHex: '잘못된 16진수 입력',
    errorGeneration: '생성 실패',
    errorPinBlock: 'PIN 블록은 16개의 16진수 문자여야 합니다',
    errorAccount: '계좌 번호는 12~19자리 숫자여야 합니다',
    errorKeyLength: '키 길이가 잘못되었습니다',
    errorCalculation: '계산 실패',
  },
  
  footer: {
    tagline: '브라우저 기반 보안 계산 도구',
    privacyPolicy: '개인정보 처리방침',
    termsOfService: '이용약관',
    disclaimer: '면책 조항',
    contact: '문의 및 피드백',
  },

  privacyPolicy: {
    seoTitle: '개인정보 처리방침 | HSM Kit',
    seoDescription: 'HSM Kit 개인정보 처리방침 - 클라이언트 측 처리를 통한 데이터 보호 방법을 알아보세요.',
    seoKeywords: '개인정보 처리방침, 데이터 보호, 클라이언트 측 처리, HSM Kit',
    title: '개인정보 처리방침',
    introTitle: '소개',
    introContent: 'HSM Kit에서는 귀하의 보안과 개인정보를 중요하게 생각합니다. 본 개인정보 처리방침은 온라인 암호화 도구를 사용할 때 데이터를 처리하는 방법을 설명합니다.',
    clientSideTitle: '클라이언트 측 처리',
    clientSideContent: '당사는 귀하의 입력 데이터를 수집, 저장 또는 전송하지 않습니다. 모든 암호화 작업(암호화, 복호화, 해싱, 키 포맷팅)은 JavaScript를 사용하여 귀하의 웹 브라우저 내에서 완전히 수행됩니다. 귀하의 키, PIN 및 데이터는 장치를 떠나지 않으며 당사 서버로 전송되지 않습니다.',
    dataCollectionTitle: '데이터 수집',
    dataCollectionContent: '당사는 개인 정보를 추적하거나 저장하지 않습니다.',
    analyticsTitle: '사용 분석',
    analyticsContent: '페이지 조회수 및 사이트 성능을 추적하기 위해 익명 분석 도구(예: Google Analytics)를 사용할 수 있습니다. 이러한 도구는 계산 양식에 입력한 데이터에 액세스할 수 없습니다.',
    localStorageTitle: '로컬 스토리지',
    localStorageContent: '인터페이스 기본 설정(예: 다크 모드 설정)을 저장하기 위해 브라우저의 로컬 스토리지를 사용할 수 있습니다. 이 데이터는 귀하의 장치에 저장되며 당사에 전송되지 않습니다.',
    thirdPartyTitle: '제3자 서비스',
    thirdPartyContent: '당사 웹사이트는 퍼블릭 클라우드 제공업체에서 호스팅됩니다. 당사는 데이터를 수집하지 않지만 표준 서버 로그(IP 주소, 사용자 에이전트)는 보안 및 유지 관리 목적으로 호스팅 제공업체에서 처리될 수 있습니다.',
    changesTitle: '정책 변경',
    changesContent: '당사는 수시로 본 개인정보 처리방침을 업데이트할 수 있습니다. 변경 사항이 있는지 정기적으로 이 페이지를 검토하시기 바랍니다.',
    lastUpdated: '최종 업데이트',
    lastUpdatedDate: '{year}년 1월',
    backToHome: '홈으로 돌아가기',
    contactTitle: '문의하기',
    contactContent: '본 개인정보 처리방침에 대해 궁금한 점이 있으시면 다음 이메일로 문의해 주세요: ',
  },

  termsOfService: {
    seoTitle: '이용약관 | HSM Kit',
    seoDescription: 'HSM Kit 이용약관 - 암호화 도구 사용에 관한 이용약관을 확인하세요.',
    seoKeywords: '이용약관, 서비스 약관, 사용자 계약, HSM Kit',
    title: '이용약관',
    acceptanceTitle: '1. 약관 동의',
    acceptanceContent: 'HSM Kit (hsmkit.com)에 접속하고 사용함으로써 귀하는 본 계약의 조건에 구속되는 것에 동의합니다. 이 약관에 동의하지 않으시면 본 웹사이트를 사용하지 마십시오.',
    useOfServiceTitle: '2. 서비스 이용',
    useOfServiceIntro: 'HSM Kit는 개발자와 보안 전문가를 위한 온라인 암호화 도구를 제공합니다.',
    licenseTitle: '라이선스',
    licenseContent: '개인, 교육 및 전문 테스트 목적으로 도구를 사용할 수 있는 제한적이고 비독점적이며 양도 불가능한 라이선스를 부여합니다.',
    restrictionsTitle: '제한 사항',
    restrictionsContent: '서비스를 오용하지 않기로 동의합니다. 여기에는 다음이 포함되지만 이에 국한되지 않습니다:',
    restriction1: '웹사이트의 정상적인 작동을 방해하려는 시도(예: DDoS 공격).',
    restriction2: '당사의 허가 없이 자동화 시스템(로봇, 스파이더)을 사용하여 웹사이트에 접근하는 행위.',
    restriction3: '불법 활동이나 악의적인 행위를 용이하게 하기 위해 도구를 사용하는 행위.',
    intellectualPropertyTitle: '3. 지적 재산권',
    intellectualPropertyContent: '본 웹사이트의 콘텐츠, 레이아웃, 디자인, 데이터, 데이터베이스 및 그래픽은 지적 재산권법에 의해 보호되며, 달리 명시되지 않는 한 HSM Kit가 소유합니다. 당사의 명시적인 서면 허가 없이 서비스의 어떤 부분도 복제, 복사, 판매 또는 이용할 수 없습니다.',
    disclaimerTitle: '4. 보증 면책',
    disclaimerContent: '도구는 "있는 그대로" 및 "이용 가능한 상태"로 제공됩니다. HSM Kit는 계산의 정확성, 신뢰성 또는 완전성에 대해 명시적이든 묵시적이든 어떠한 진술이나 보증도 하지 않습니다.',
    limitationTitle: '5. 책임 제한',
    limitationContent: '어떠한 경우에도 HSM Kit 또는 그 운영자는 본 웹사이트의 사용으로 인해 또는 이와 관련하여 발생하는 직접적, 간접적, 우발적, 특별 또는 결과적 손해에 대해 책임을 지지 않습니다. 여기에는 데이터 손실, 이익 손실 또는 사업 중단이 포함되지만 이에 국한되지 않습니다.',
    changesTitle: '6. 약관 변경',
    changesContent: '당사는 언제든지 이 약관을 수정할 권리를 보유합니다. 변경 후에도 웹사이트를 계속 사용하면 새 약관에 동의하는 것으로 간주됩니다.',
    lastUpdated: '최종 업데이트',
    lastUpdatedDate: '{year}년 1월',
    backToHome: '홈으로 돌아가기',
    contactTitle: '문의하기',
    contactContent: '본 이용약관에 대해 궁금한 점이 있으시면 다음 이메일로 문의해 주세요: ',
  },

  disclaimer: {
    seoTitle: '면책 조항 | HSM Kit',
    seoDescription: 'HSM Kit 법적 면책 조항 - 암호화 도구 사용에 관한 중요 정보.',
    seoKeywords: '면책 조항, 법적 고지, 이용 약관, HSM Kit',
    title: '면책 조항',
    generalTitle: '일반 면책 조항',
    generalContent: 'HSM Kit에서 제공하는 도구 및 정보는 교육, 테스트 및 개발 목적으로만 사용됩니다. 알고리즘과 계산의 정확성을 보장하기 위해 노력하지만, 본 소프트웨어는 명시적이든 묵시적이든 어떠한 종류의 보증 없이 "있는 그대로" 제공됩니다.',
    noLiabilityTitle: '책임 제한',
    noLiabilityContent: '어떠한 경우에도 저자 또는 저작권 보유자는 계약, 불법 행위 또는 기타 소송에서 소프트웨어 또는 소프트웨어의 사용 또는 기타 거래와 관련하여 발생하는 청구, 손해 또는 기타 책임에 대해 책임을 지지 않습니다.',
    securityTitle: '보안 경고',
    securityContent: '이 웹사이트에서 실제 프로덕션 키, 민감한 금융 데이터 또는 실제 개인 정보를 사용하지 마십시오. 모든 계산이 클라이언트 측에서 수행되지만 브라우저 환경에서 실제 암호화 자료를 노출하지 않는 것이 보안 업계의 모범 사례입니다.',
    securityWarningTitle: '중요 보안 공지',
    securityWarningContent: '이 웹사이트에서 실제 프로덕션 키, 민감한 데이터 또는 실제 자격 증명을 사용하지 마십시오. 이 도구는 교육 및 테스트 목적으로만 사용됩니다.',
    complianceTitle: '규정 준수',
    complianceContent: '사용자는 이러한 도구의 사용이 모든 적용 가능한 지역, 주 및 연방 법률 및 규정을 준수하는지 확인할 책임이 있습니다.',
    lastUpdated: '최종 업데이트',
    lastUpdatedDate: '{year}년 1월',
    backToHome: '홈으로 돌아가기',
    contactTitle: '문의하기',
    contactContent: '본 면책 조항에 대해 궁금한 점이 있으시면 다음 이메일로 문의해 주세요: ',
  },

  home: {
    heroTitle: '무료 온라인 암호화 및 키 관리 도구',
    heroDescription: '보안 전문가를 위한 종합 암호화 도구 모음입니다. 모든 계산은 브라우저에서 클라이언트 측에서 수행되며, 데이터가 기기를 떠나지 않습니다.',
    searchPlaceholder: '도구 검색... (예: MD5, AES, PIN Block)',
    availableTools: '인기 도구',
    gridView: '그리드 보기',
    listView: '목록 보기',
    whyChoose: '왜 HSM Kit를 선택해야 할까요?',
    categories: {
      all: '전체',
      symmetric: '대칭 암호화',
      asymmetric: '비대칭 암호화',
      payment: '결제/금융',
      encoding: '인코딩',
      hashing: '해시',
    },
    tools: {
      asn1: {
        title: 'ASN.1 파서',
        description: 'ASN.1 DER/BER 구조를 분석하고 X.509 인증서 및 PKCS 형식을 디코딩합니다.',
      },
      aes: {
        title: 'AES 암호화',
        description: 'AES-128/192/256으로 데이터를 암호화/복호화. ECB, CBC, CFB, OFB, CTR 모드 지원.',
      },
      des: {
        title: 'DES/3DES 암호화',
        description: '레거시 시스템을 위한 다양한 패딩 옵션이 있는 DES 및 Triple DES 암호화.',
      },
      rsa: {
        title: 'RSA 암호화',
        description: 'RSA 비대칭 암호화, 복호화, 디지털 서명 및 검증.',
      },
      ecc: {
        title: 'ECC/ECDSA',
        description: '컴팩트한 키와 효율적인 디지털 서명을 위한 타원 곡선 암호화.',
      },
      fpe: {
        title: '형식 보존 암호화',
        description: 'FPE (FF1/FF3-1)로 형식과 길이를 보존하면서 데이터를 암호화.',
      },
      keyGenerator: {
        title: '키 생성기',
        description: 'AES, DES, 3DES용 보안 랜덤 키 생성. 키 조합 및 패리티 도구.',
      },
      tr31: {
        title: 'TR-31 키 블록',
        description: 'KBPK 보호로 TR-31/ANSI X9.143 키 블록 인코딩/디코딩. TDES 및 AES 버전 지원.',
      },
      kcv: {
        title: 'KCV 계산기',
        description: 'AES 및 DES/3DES 키의 키 검증값(KCV) 계산.',
      },
      pinBlock: {
        title: 'PIN 블록 생성기',
        description: '결제 거래용 ISO 9564 PIN 블록 (형식 0, 1, 3, 4) 생성.',
      },
      as2805: {
        title: 'AS2805 도구',
        description: 'AS2805 결제 메시지(ISO 8583 변형)를 파싱하고 분석합니다.',
      },
      hash: {
        title: '해시 계산기',
        description: 'MD5, SHA-1, SHA-256, SHA-512, BLAKE2 등의 알고리즘으로 해시 값 계산.',
      },
      encoding: {
        title: '문자 인코딩',
        description: 'ASCII, EBCDIC, 16진수, 바이너리, ATM 10진수 형식 간 변환.',
      },
      bcd: {
        title: 'BCD 인코더/디코더',
        description: '10진수를 BCD로 인코딩하거나 BCD를 10진수로 디코딩.',
      },
      checkDigits: {
        title: '체크 디지트',
        description: 'Luhn (MOD 10) 및 MOD 9 알고리즘으로 체크 디지트 계산 및 검증.',
      },
      base64: {
        title: 'Base64',
        description: 'Base64 바이너리-텍스트 인코딩으로 데이터 인코딩/디코딩.',
      },
      base94: {
        title: 'Base94',
        description: '94개의 모든 출력 가능한 ASCII 문자를 사용한 컴팩트 인코딩.',
      },
      messageParser: {
        title: '메시지 파서',
        description: 'ATM NDC, Wincor, ISO 8583 금융 메시지 형식 구문 분석.',
      },
      rsaDer: {
        title: 'RSA DER 공개키',
        description: '모듈러스/지수와 DER 형식 간 RSA 공개키 인코딩/디코딩.',
      },
      uuid: {
        title: 'UUID 생성기',
        description: '범용 고유 식별자 (UUID v1, v3, v4, v5) 생성.',
      },
      // Keys HSM Tools
      keyshareGenerator: {
        title: '키 공유 생성기',
        description: 'KCV 계산을 지원하는 안전한 키 분할 및 구성 요소 관리를 위한 키 공유 생성.',
      },
      futurexKeys: {
        title: 'Futurex 키',
        description: 'Futurex HSM 키 암호화, 복호화 및 여러 변형으로 조회.',
      },
      atallaKeys: {
        title: 'Atalla 키 (AKB)',
        description: 'MFK 및 MAC 검증을 지원하는 Atalla AKB 형식 키 암호화 및 복호화.',
      },
      safeNetKeys: {
        title: 'SafeNet 키',
        description: 'KM 키 변형을 지원하는 SafeNet HSM 키 암호화, 복호화 및 조회.',
      },
      thalesKeys: {
        title: 'Thales 키',
        description: '변형을 지원하는 Thales HSM LMK 키 암호화, 복호화 및 조회.',
      },
      thalesKeyBlock: {
        title: 'Thales 키 블록',
        description: 'KBPK 보호를 사용한 Thales 독점 키 블록 인코딩 및 디코딩.',
      },
      sslCert: {
        title: 'SSL 인증서',
        description: 'RSA 키 쌍 생성, CSR 생성, 자체 서명 X.509 인증서 생성 및 인증서 분석.',
      },
    },
    features: {
      clientSide: {
        title: '100% 브라우저 기반',
        description: '모든 암호화 작업이 브라우저에서 완전히 실행됩니다. 키, PIN, 민감한 데이터가 장치를 떠나지 않습니다.',
      },
      free: {
        title: '무료 & 오픈',
        description: '25개 이상의 도구가 모두 무료입니다. 등록 불필요, 로그인 불필요, 숨겨진 비용 없음. 즉시 사용 가능.',
      },
      paymentReady: {
        title: 'HSM & 결제 대응',
        description: 'Thales, Futurex, Atalla, SafeNet HSM을 전문적으로 지원. TR-31, KCV, PIN 블록 등.',
      },
    },
  },
  
  asn1: {
    title: 'ASN.1 파서',
    description: 'ASN.1 DER/BER 구조를 구문 분석 및 분석하고 RFC 정의 매칭 지원',
    infoTitle: 'ASN.1 파서 정보',
    infoContent1: 'ASN.1 DER/BER 인코딩된 데이터 구조 구문 분석',
    infoContent2: '16진수, Base64, PEM 입력 형식 지원',
    infoContent3: 'RFC 정의를 활성화하여 X.509, PKCS 등 알려진 구조와 매칭',
    inputLabel: '입력 (Hex, Base64, 또는 PEM):',
    inputPlaceholder: 'hex, base64 또는 PEM 인코딩된 ASN.1 BER/DER 구조를 붙여넣거나 파일 업로드',
    withHexDump: 'Hex Dump 표시',
    trimBigChunks: '큰 데이터 간소화',
    withDefinitions: '정의 매칭 활성화',
    uploadFile: '파일 업로드',
    parse: '구문 분석',
    clear: '지우기',
    structureDefinition: '구조 정의:',
    selectDefinition: '구조 정의 선택...',
    parsedResult: '구문 분석 결과:',
    hexDump: 'Hex Dump:',
    offset: '오프셋',
    length: '길이',
    value: '값',
    constructed: '구조 타입',
    loadError: 'ASN.1 파싱 라이브러리 로드 실패',
    inputRequired: 'ASN.1 데이터를 입력하세요',
    parseError: '구문 분석 실패',
    copied: '복사됨',
    copyHex: 'Hex 복사',
    copyHexDump: 'Hex Dump 복사',
    copyBase64: 'Base64 복사',
    copySubtree: '하위 트리 복사',
    copyValue: '값 복사',
  },
  
  keyGenerator: {
    title: '랜덤 키 생성기',
    description: 'DES, 3DES 또는 AES용 암호학적으로 강력한 랜덤 키를 생성합니다.',
    infoTitle: '키 생성기 정보',
    infoContent1: 'Web Crypto API를 사용하여 암호학적으로 안전한 랜덤 키 생성',
    infoContent2: 'DES (8바이트), 3DES (16/24바이트), AES (16/24/32바이트) 지원',
    infoContent3: '키 검증을 위한 KCV (키 체크 값) 자동 계산',
    keyLength: '키 길이',
    bytes: '바이트',
    bits: '비트',
    generateNow: '지금 생성',
    generatedKey: '생성된 키 (16진수)',
    kcv: 'KCV',
    length: '길이',
    tabKeyGen: '키 생성',
    tabCombination: '키 조합',
    tabParity: '패리티 조정',
    tabValidation: '키 검증',
    combinationTitle: '키 컴포넌트 조합',
    combinationDesc: '여러 키 컴포넌트를 XOR로 조합',
    component: '컴포넌트',
    components: '개 컴포넌트',
    combinedKey: '조합된 키',
    addComponent: '추가',
    removeComponent: '제거',
    combineKeys: '조합',
    errorInvalidComponent: '컴포넌트 {index} 무효',
    errorComponentLength: '모든 컴포넌트의 길이가 같아야 합니다',
    errorComponentLength2: '길이는 다음 중 하나여야 합니다',
    errorMinComponents: '최소 2개의 컴포넌트 필요',
    errorMaxComponents: '최대 9개 컴포넌트까지 가능',
    clearAll: '모두 지우기',
    parityTitle: '패리티 조정',
    parityDesc: 'DES/3DES 키의 패리티 비트 조정',
    keyInput: '키 입력',
    keyInputPlaceholder: '16진수 키 입력',
    parityType: '패리티 유형',
    odd: '홀수',
    even: '짝수',
    adjustParity: '조정',
    adjustedKey: '조정된 키',
    validationTitle: '키 유효성 검사',
    validationDesc: '형식, 길이 및 패리티 확인',
    validateKey: '검증',
    validKey: '유효한 키',
    invalidKey: '무효한 키',
    keyType: '키 유형',
    parityStatus: '패리티 상태',
    parityValid: '유효',
    parityInvalid: '무효',
  },
  
  kcvCalculator: {
    title: 'KCV 계산기',
    description: '키 확인 값을 계산하여 키의 정확성을 검증합니다.',
    algorithm: '알고리즘',
    keyInput: '키 (16진수)',
    keyPlaceholder: '예: 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'KCV 계산',
    keyCheckValue: '키 확인 값',
    errorInvalidHex: '키는 유효한 16진수 문자여야 합니다',
    errorDesLength: 'DES/3DES 키 길이는 8, 16 또는 24바이트여야 합니다',
    errorAesLength: 'AES 키 길이는 16, 24 또는 32바이트여야 합니다',
    errorCalculation: '계산에 실패했습니다. 키 형식을 확인하세요',
    format: '형식',
    autoAdjustParity: '패리티 비트 자동 조정',
    parityAdjustmentHint: '일부 키에는 올바른 패리티 비트가 설정되어 있지 않을 수 있습니다. 이 옵션을 선택하면 자동으로 수정됩니다',
    kcvCalcTitle: '키 확인 값 계산',
    desCalcDesc: '키의 평문을 사용하여 16자 길이의 \'0\'을 3DES-ECB 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
    aesCalcDesc: '키의 평문을 사용하여 32자 길이의 \'0\'을 CMAC-AES 알고리즘으로 암호화한 다음 암호화된 값의 처음 6자를 키 확인 값으로 사용합니다',
  },
  
  pinBlock: {
    title: 'PIN 블록 생성기',
    description: '결제 거래용 ISO 형식 PIN 블록을 생성합니다.',
    format: 'PIN 블록 형식',
    pinLabel: 'PIN (4-12자리)',
    pinPlaceholder: '예: 1234',
    panLabel: 'PAN (기본 계좌 번호)',
    panPlaceholder: '예: 4111111111111111',
    generatePinBlock: 'PIN 블록 생성',
    pinBlockHex: 'PIN 블록 (16진수)',
    errorInvalidPin: 'PIN은 4-12자리 숫자여야 합니다',
    errorInvalidPan: 'PAN은 13-19자리 숫자여야 합니다',
    errorGeneration: '생성에 실패했습니다. 입력을 확인하세요',
    errorFormat1: 'ISO Format 1은 곧 출시됩니다...',
    pinLengthHint: '4-12자리 PIN 지원',
    panHint: '전체 카드 번호를 입력하세요 (13-19자리), 시스템이 자동으로 오른쪽 12자리를 추출합니다 (체크 디지트 제외)',
  },
  
  tr31: {
    title: 'TR-31 키 블록',
    description: 'KBPK 보호로 TR-31/ANSI X9.143 키 블록 인코딩/디코딩',
    keyBlock: 'TR-31 키 블록',
    keyBlockPlaceholder: '예: D0144B1AX00E0000...',
    parseKeyBlock: '키 블록 구문 분석',
    header: '키 블록 헤더',
    version: '버전',
    keyLength: '길이',
    keyUsage: '키 용도',
    mode: '모드',
    keyVersion: '키 버전',
    exportability: '내보내기 가능성',
    characters: '문자',
    errorTooShort: 'TR-31 키 블록 길이가 부족합니다',
    errorParsing: '구문 분석에 실패했습니다. TR-31 형식을 확인하세요',
    exportable: '내보내기 가능',
    nonExportable: '내보내기 불가',
    sensitive: '민감함',
    keyBlockFormatHint: 'TR-31 키 블록 형식 (예: D0144B1AX00E0000...), 시스템이 자동으로 형식을 검증합니다',
  },

  tr31KeyBlock: {
    title: 'TR-31 키 블록',
    description: 'KBPK 보호로 TR-31/ANSI X9.143 키 블록 인코딩/디코딩',
    infoTitle: 'TR-31 키 블록 정보',
    infoContent1: 'TR-31 (ANSI X9.143)은 결제 시스템에서 안전한 암호화 키 교환을 위한 업계 표준입니다.',
    infoContent2: '키 블록에는 메타데이터(용도, 알고리즘, 내보내기 가능성)와 함께 암호화된 키 데이터가 포함됩니다.',
    infoContent3: 'KBPK(키 블록 보호 키)는 TDES 또는 AES 암호화로 래핑된 키를 보호합니다.',
    kbpkPlaceholder: 'KBPK 입력 - TDES용 32/48자리 16진수, AES용 32/48/64자리 16진수',
    keyBlockVersion: '키 블록 버전',
    tabEncode: '인코드',
    tabDecode: '디코드',
    plainKey: '평문 키',
    plainKeyPlaceholder: '16진수로 평문 키 입력 (16/24/32바이트)',
    header: '헤더',
    versionId: '버전 ID',
    keyUsage: '키 용도',
    algorithm: '알고리즘',
    modeOfUse: '사용 모드',
    keyVersionNum: '키 버전#',
    exportability: '내보내기 가능성',
    optKeyBlocks: '선택적 키 블록 수',
    reserved: '예약됨',
    optionalHeadersSection: '선택적 헤더',
    optionalHeaders: '선택적 헤더',
    encode: '인코드',
    decode: '디코드',
    keyBlock: '키 블록',
    keyBlockPlaceholder: 'TR-31 키 블록 데이터 입력 (예: D0144B1AX00E0000...)',
    encodeResult: '인코딩된 키 블록',
    decodeResult: '디코딩된 키 블록',
    headerInfo: '헤더',
    encodeSuccess: '키 블록 인코딩 성공',
    decodeSuccess: '키 블록 디코딩 성공',
    errorInvalidKey: '잘못된 평문 키 형식',
    errorInvalidKbpk: '잘못된 KBPK 형식(최소 32자 16진수 필요)',
    errorKeyBlockShort: '키 블록이 너무 짧습니다',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
  },
  
  placeholder: {
    title: '출시 예정',
    description: '이 도구는 개발 중입니다. 기대해 주세요!',
  },

  hash: {
    title: '해시 계산기',
    description: 'MD5, SHA-1, SHA-256, SHA-512 등 다양한 알고리즘으로 해시값 계산',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    hashType: '해시 유형',
    inputData: '입력 데이터',
    hashResult: '해시 결과',
    asciiPlaceholder: '텍스트 데이터 입력...',
    hexPlaceholder: '16진수 데이터 입력...',
    byteLength: '바이트',
    calculate: '해시 계산',
    algorithmInfo: '알고리즘 정보',
    outputLength: '출력 길이',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorOddHex: '16진수 입력은 짝수 개의 문자여야 합니다',
    errorCalculation: '해시 계산 실패',
    faqTitle: '해시 계산기 FAQ',
    faq1Question: '해시 함수란?',
    faq1Answer: '해시 함수는 임의 크기의 입력 데이터를 고정 크기의 출력(해시값)으로 변환하는 수학적 알고리즘입니다. 결정적이고 일방향입니다.',
    faq2Question: '어떤 해시 알고리즘을 사용해야 하나요?',
    faq2Answer: '보안 목적으로는 SHA-256 또는 SHA-512를 사용하세요. MD5와 SHA-1은 암호화 용도로는 안전하지 않지만 체크섬에는 사용할 수 있습니다.',
    usageTitle: '사용 방법',
    usage1: '입력 유형 선택 (ASCII 텍스트 또는 16진수)',
    usage2: '드롭다운에서 해시 알고리즘 선택',
    usage3: '입력 필드에 데이터 입력',
    usage4: '"해시 계산"을 클릭하여 해시값 생성',
    hashInfo: '해시 함수는 일방향 - 역변환 불가',
    inputLength: '입력',
  },

  encoding: {
    title: '문자 인코딩',
    description: '다양한 문자 인코딩과 형식 간 변환',
    encodingType: '인코딩',
    data: '데이터',
    convert: '변환',
    result: '변환 결과',
    conversionInfo: '변환 정보',
    ebcdicInfo: 'EBCDIC는 IBM 메인프레임에서 사용',
    atmInfo: 'ATM 형식은 공백으로 구분된 10진수 값을 사용 (0-255)',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorConversion: '변환 실패',
    placeholderBinary: '데이터 입력 (예: 57652C206174...)',
    placeholderHex: '16진수 데이터 입력',
    placeholderText: 'ASCII 텍스트 입력',
    placeholderAtm: '공백으로 구분된 10진수 값 입력 (예: 065 066 067)',
    faqTitle: '문자 인코딩 FAQ',
    faq1Question: '문자 인코딩이란?',
    faq1Answer: '문자 인코딩은 각 문자를 고유한 숫자 또는 바이트 시퀀스와 연결하여 컴퓨터가 텍스트를 저장하고 전송할 수 있게 하는 시스템입니다.',
    faq2Question: 'EBCDIC란?',
    faq2Answer: 'EBCDIC(확장 이진화 십진 교환 코드)는 주로 IBM 메인프레임 및 미드레인지 컴퓨터 시스템에서 사용되는 8비트 문자 인코딩입니다.',
    usageTitle: '사용 방법',
    usage1: '드롭다운에서 변환 유형 선택',
    usage2: '적절한 형식으로 데이터 입력',
    usage3: '"변환"을 클릭하여 결과 확인',
  },

  bcd: {
    title: '이진화 십진법 (BCD)',
    description: '십진수를 BCD로 인코딩하거나 BCD를 십진수로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputFormat: '입력 형식',
    binary: '이진수',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'BCD 정보',
    encodeInfo1: '각 십진 숫자 (0-9)는 4비트로 인코딩',
    encodeInfo2: '예: 25 → 0010 0101 (이진수) / 25 (16진수)',
    decodeInfo1: '각 4비트는 0-9여야 합니다 (A-F 불가)',
    decodeInfo2: '예: 0010 0101 → 25',
    encodeResult: 'BCD 인코딩 결과',
    decodeResult: '디코딩된 십진수',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidDecimal: '잘못된 입력: 0-9 숫자만 허용',
    errorInvalidBinary: '잘못된 이진수 입력 (0과 1만, 4의 배수 길이)',
    errorInvalidHex: '잘못된 16진수 입력',
    errorConversion: '변환 실패',
    placeholderEncode: '십진수 입력 (예: 12345)',
    placeholderBinary: 'BCD 이진수 입력 (예: 0010 0101)',
    placeholderHex: 'BCD 16진수 입력 (예: 25)',
    faqTitle: 'BCD FAQ',
    faq1Question: 'BCD란?',
    faq1Answer: '이진화 십진법 (BCD)는 각 십진 숫자를 고정 비트 수 (보통 4비트)로 표현하는 이진 인코딩입니다.',
    faq2Question: 'BCD를 왜 사용하나요?',
    faq2Answer: 'BCD는 십진 정밀도가 중요한 금융 및 상업 애플리케이션과 십진 숫자를 직접 표시해야 하는 시스템에서 사용됩니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 십진수를 BCD로 변환',
    usage2: '"디코딩"을 선택하여 BCD를 십진수로 변환',
    usage3: '디코딩 시 이진수 또는 16진수 입력 형식 선택',
  },

  checkDigits: {
    title: '체크 디지트',
    description: '다양한 알고리즘으로 체크 디지트 검증 또는 생성',
    operation: '작업',
    check: '검증',
    generate: '생성',
    hashType: '알고리즘',
    input: '입력',
    info: '알고리즘 정보',
    luhnInfo: 'Luhn 알고리즘 (MOD 10) - 신용카드, IMEI 등에 사용',
    amexInfo: 'Amex SE Number (MOD 9) - 숫자 합계를 9로 나눈 나머지',
    checkInfo: '체크 디지트를 포함한 완전한 번호 입력',
    generateInfo: '체크 디지트 없는 번호 입력',
    checkResult: '검증 결과',
    generateResult: '생성된 체크 디지트',
    validResult: '유효 - 체크 디지트가 올바릅니다',
    invalidResult: '무효 - 체크 디지트가 올바르지 않습니다',
    fullNumber: '전체 번호',
    errorNoInput: '번호를 입력하세요',
    errorCalculation: '계산 실패',
    placeholderCheck: '체크 디지트 포함 번호 입력 (예: 79927398713)',
    placeholderGenerate: '체크 디지트 없는 번호 입력 (예: 7992739871)',
    faqTitle: '체크 디지트 FAQ',
    faq1Question: '체크 디지트란?',
    faq1Answer: '체크 디지트는 특정 알고리즘으로 계산된 오류 검출용 숫자입니다.',
    faq2Question: 'Luhn 알고리즘이란?',
    faq2Answer: 'Luhn 알고리즘 (MOD 10)은 신용카드 번호, IMEI 번호 등의 검증에 사용되는 체크섬 공식입니다.',
    usageTitle: '사용 방법',
    usage1: '"검증"을 선택하여 체크 디지트 포함 번호 검증',
    usage2: '"생성"을 선택하여 체크 디지트 계산',
    usage3: '용도에 맞는 알고리즘 선택',
  },

  base64: {
    title: 'Base64',
    description: '데이터를 Base64로 인코딩하거나 Base64를 원래 형식으로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputEncoding: '입력 인코딩',
    outputEncoding: '출력 인코딩',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'Base64 정보',
    encodeInfo1: 'Base64는 바이너리 데이터를 ASCII 문자로 인코딩',
    encodeInfo2: '출력은 입력보다 약 33% 큼',
    decodeInfo1: 'Base64를 원래 데이터로 디코딩',
    decodeInfo2: '출력 형식 선택: ASCII 텍스트 또는 16진수',
    encodeResult: 'Base64 인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase64: '잘못된 Base64 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    placeholderAscii: '인코딩할 텍스트 입력',
    placeholderHex: '인코딩할 16진수 데이터 입력',
    placeholderBase64: '디코딩할 Base64 문자열 입력',
    faqTitle: 'Base64 FAQ',
    faq1Question: 'Base64란?',
    faq1Answer: 'Base64는 64개 문자를 사용하여 바이너리 데이터를 ASCII 문자열 형식으로 표현하는 바이너리-텍스트 인코딩 방식입니다.',
    faq2Question: '왜 Base64를 사용하나요?',
    faq2Answer: 'Base64는 JSON, XML, 이메일 첨부 파일과 같은 텍스트 기반 형식에 바이너리 데이터를 포함하는 데 일반적으로 사용됩니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 데이터를 Base64로 변환',
    usage2: '"디코딩"을 선택하여 Base64를 원래 데이터로 변환',
    usage3: '입력/출력 인코딩 선택: ASCII 또는 16진수',
  },

  base94: {
    title: 'Base94',
    description: '데이터를 Base94로 인코딩하거나 Base94를 원래 형식으로 디코딩',
    encode: '인코딩',
    decode: '디코딩',
    inputEncoding: '입력 인코딩',
    outputEncoding: '출력 인코딩',
    hexadecimal: '16진수',
    data: '데이터',
    info: 'Base94 정보',
    encodeInfo1: 'ASCII 인쇄 가능 문자 사용 (0x20 공백부터 0x7E 물결표)',
    encodeInfo2: '5:4 비율 - 4바이트를 5문자로 인코딩 (25% 오버헤드)',
    decodeInfo1: 'Base94를 원래 데이터로 디코딩',
    decodeInfo2: '유효한 문자: 공백부터 ~ (ASCII 32-126)',
    encodeResult: 'Base94 인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoInput: '데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase94: '잘못된 Base94 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    placeholderAscii: '인코딩할 텍스트 입력',
    placeholderHex: '인코딩할 16진수 데이터 입력',
    placeholderBase94: '디코딩할 Base94 문자열 입력',
    faqTitle: 'Base94 FAQ',
    faq1Question: 'Base94란?',
    faq1Answer: 'Base94는 94개의 인쇄 가능한 ASCII 문자 (!부터 ~)를 모두 사용하는 바이너리-텍스트 인코딩으로, Base64보다 효율적인 인코딩을 제공합니다.',
    faq2Question: '왜 Base64 대신 Base94를 사용하나요?',
    faq2Answer: 'Base94는 Base64 (약 33%)에 비해 오버헤드가 적어 (약 22%), 동일한 데이터의 인코딩 출력이 더 작습니다.',
    usageTitle: '사용 방법',
    usage1: '"인코딩"을 선택하여 데이터를 Base94로 변환',
    usage2: '"디코딩"을 선택하여 Base94를 원래 데이터로 변환',
    usage3: '입력/출력 인코딩 선택: ASCII 또는 16진수',
  },

  messageParser: {
    title: '메시지 파서',
    description: 'ATM 및 금융 거래 메시지 파싱',
    parseMode: '파싱 모드',
    hexData: '16진수 데이터',
    info: '파싱 모드 정보',
    ndcDesc: 'NCR NDC/DDC 프로토콜, ATM 통신용',
    wincorDesc: 'Wincor Nixdorf 프로토콜, ATM 통신용',
    iso8583Desc: 'ISO 8583:1987 금융 거래 메시지 형식',
    hexInputInfo: '입력은 유효한 16진수 데이터여야 합니다',
    placeholder: '파싱할 16진수 메시지 데이터 입력...',
    parsedResult: '파싱 결과',
    fields: '필드',
    fieldName: '필드',
    length: '길이',
    value: '값',
    errorNoInput: '16진수 데이터를 입력하세요',
    errorInvalidHex: '잘못된 16진수 입력',
    errorParseFailed: '메시지 파싱 실패',
    faqTitle: '메시지 파서 FAQ',
    faq1Question: 'ATM NDC란?',
    faq1Answer: 'NDC(NCR Direct Connect)는 NCR ATM이 호스트 시스템과 통신하는 데 사용하는 통신 프로토콜입니다.',
    faq2Question: 'ISO 8583이란?',
    faq2Answer: 'ISO 8583은 카드 결제 거래에 사용되는 금융 거래 카드 발신 메시지의 국제 표준입니다.',
    usageTitle: '사용 방법',
    usage1: '적절한 파싱 모드 선택 (ATM_NDC, ATM_WINCOR 또는 ISO_8583_1987)',
    usage2: '입력 필드에 16진수 메시지 데이터 입력',
    usage3: '파싱을 클릭하여 파싱된 필드와 값 보기',
  },

  rsaDer: {
    title: 'RSA DER 공개키',
    description: 'DER ASN.1 형식으로 RSA 공개키 인코딩/디코딩',
    info: 'RSA DER 정보',
    encode: '인코딩',
    decode: '디코딩',
    modulus: '모듈러스',
    modulusEncoding: '모듈러스 인코딩',
    exponent: '지수',
    exponentEncoding: '지수 인코딩',
    modulusNegative: '모듈러스 음수 (부호 없는 인코딩)',
    outputEncoding: '출력 인코딩',
    inputEncoding: '입력 인코딩',
    derInput: 'DER/PEM 입력',
    modulusPlaceholder: '모듈러스 입력 (16진수 또는 base64)',
    exponentPlaceholder: '지수 입력 (예: 65537의 경우 010001)',
    derInputPlaceholder: 'DER (16진수/base64) 또는 PEM 형식 공개키 입력',
    encodeInfo: 'RSA 공개키 인코딩',
    encodeInfo1: 'RSA 모듈러스와 지수를 DER/PEM 형식으로 인코딩',
    encodeInfo2: '부호 있는 및 부호 없는 정수 인코딩 지원',
    decodeInfo: 'RSA 공개키 디코딩',
    decodeInfo1: 'DER/PEM 형식을 디코딩하여 모듈러스와 지수 추출',
    decodeInfo2: '16진수, base64, PEM 입력 형식 지원',
    encodeResult: '인코딩 결과',
    decodeResult: '디코딩 결과',
    errorNoModulus: '모듈러스를 입력하세요',
    errorNoExponent: '지수를 입력하세요',
    errorNoInput: 'DER 데이터를 입력하세요',
    errorInvalidModulusHex: '잘못된 모듈러스 16진수',
    errorInvalidModulusBase64: '잘못된 모듈러스 base64',
    errorInvalidExponentHex: '잘못된 지수 16진수',
    errorInvalidExponentBase64: '잘못된 지수 base64',
    errorInvalidHex: '잘못된 16진수 입력',
    errorInvalidBase64: '잘못된 base64 입력',
    errorEncode: '인코딩 실패',
    errorDecode: '디코딩 실패',
    faqTitle: 'RSA DER 공개키 FAQ',
    faq1Question: 'DER 인코딩이란?',
    faq1Answer: 'DER(Distinguished Encoding Rules)은 ASN.1 데이터 구조를 인코딩하는 바이너리 형식으로, 암호화 키와 인증서에 일반적으로 사용됩니다.',
    faq2Question: 'PEM 형식이란?',
    faq2Answer: 'PEM은 헤더와 푸터 라인이 있는 DER의 Base64 인코딩 버전으로, 텍스트 형식으로 쉽게 복사하여 붙여넣을 수 있습니다.',
    usageTitle: '사용 방법',
    usage1: '인코딩: 모듈러스와 지수를 입력하여 DER/PEM 인코딩된 공개키 생성',
    usage2: '디코딩: DER 또는 PEM 형식 공개키를 입력하여 모듈러스와 지수 추출',
    usage3: '16진수 및 base64 입출력 형식 지원',
  },

  uuid: {
    title: 'UUID 생성기',
    description: '범용 고유 식별자 (UUID) 생성',
    variant: '버전',
    count: '수량',
    info: 'UUID 정보',
    infoFormat: '형식: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36자)',
    v1Desc: '타임스탬프와 랜덤 노드를 사용하는 시간 기반 UUID',
    v4Desc: '랜덤 UUID - 가장 일반적',
    v3Desc: 'MD5 해시를 사용하는 이름 기반 UUID',
    v5Desc: 'SHA-1 해시를 사용하는 이름 기반 UUID',
    generatedUUIDs: '생성된 UUID',
    copyAll: '모두 복사',
    errorInvalidCount: '수량은 1에서 100 사이여야 합니다',
    errorGenerate: '생성 실패',
    withoutHyphen: '"-" 제외',
    maxCount: '최대 100개',
    faqTitle: 'UUID FAQ',
    faq1Question: 'UUID란?',
    faq1Answer: 'UUID(범용 고유 식별자)는 시간과 공간 모두에서 고유한 128비트 식별자로, 분산 시스템에서 일반적으로 사용됩니다.',
    faq2Question: '어떤 UUID 버전을 사용해야 하나요?',
    faq2Answer: '버전 4(랜덤)가 가장 일반적입니다. 버전 1은 시간 기반이고, 버전 3과 5는 각각 MD5와 SHA-1을 사용하는 이름 기반입니다.',
    usageTitle: '사용 방법',
    usage1: 'UUID 버전 선택',
    usage2: '생성할 UUID 수 입력 (1-100)',
    usage3: '생성을 클릭하여 UUID 생성',
  },

  cipher: {
    title: 'AES 암호화/복호화',
    description: 'AES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    aesInfo: 'AES 정보',
    keyLengthInfo: '키 길이는 선택한 알고리즘과 일치해야 합니다',
    ivInfo: 'IV(초기화 벡터)는 16바이트여야 합니다',
    paddingInfo: 'PKCS7 패딩 사용',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB/KCV 모드에서는 IV가 필요하지 않습니다',
    kcvInfo: 'KCV: 0을 암호화하고 처음 6개의 16진수 문자를 가져옴',
    calculateKcv: 'KCV 계산',
    noPaddingInfo: '패딩 없음 - 데이터 길이는 16바이트의 배수여야 합니다',
    errorDataLength: '데이터 길이는 16바이트의 배수여야 합니다',
    kcvNoDataNeeded: 'KCV 계산에는 데이터 입력이 필요하지 않습니다',
    kcvDataHint: 'KCV는 0을 사용하여 계산되므로 데이터 입력이 필요하지 않습니다',
    errorKcvCalculation: 'KCV 계산 실패',
    kcvResult: 'KCV 결과',
  },

  des: {
    title: 'DES / 3DES 암호화/복호화',
    description: 'DES 또는 3DES 알고리즘을 사용하여 데이터를 암호화 및 복호화',
    algorithm: '알고리즘',
    mode: '모드',
    dataInput: '데이터 입력',
    hexadecimal: '16진수',
    padding: '패딩',
    key: '키',
    data: '데이터',
    hexChars: '16진수 문자',
    dataPlaceholderHex: '16진수 데이터 입력',
    dataPlaceholderAscii: 'ASCII 텍스트 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    desInfo: 'DES/3DES 정보',
    keyLengthInfoDes: 'DES에는 8바이트(64비트) 키가 필요합니다',
    keyLengthInfo3Des: '3DES에는 16 또는 24바이트 키가 필요합니다',
    ivInfo: 'IV(초기화 벡터)는 8바이트여야 합니다',
    blockSizeInfo: '블록 크기는 8바이트입니다',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLengthDes: 'DES 키 길이는 8바이트여야 합니다',
    errorKeyLength3Des: '3DES 키 길이는 16 또는 24바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorInvalidDataHex: '데이터는 유효한 16진수여야 합니다',
    errorDataLength: '패딩 없음 사용 시 데이터 길이는 8바이트의 배수여야 합니다',
    errorInvalidIvHex: 'IV는 유효한 16진수여야 합니다',
    errorIvLength: 'IV 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorInvalidCiphertext: '암호문은 유효한 16진수여야 합니다',
    ivNotRequired: 'ECB 모드에서는 IV가 필요하지 않습니다',
    paddingNone: '패딩 없음',
    paddingZeros: '0x00으로 채움',
    paddingSpaces: '공백 0x20으로 채움',
    paddingANSIX923: '마지막 바이트는 패딩 길이, 나머지는 0x00으로 채움',
    paddingISO10126: '마지막 바이트는 패딩 길이, 나머지는 랜덤 바이트로 채움',
    paddingPKCS5: '각 패딩 바이트 값은 패딩 길이와 같음',
    paddingPKCS7: 'PKCS#5와 동일',
    paddingISO7816: '0x80을 추가한 후 0x00으로 채움',
    paddingRijndael: 'Zero 패딩과 동일',
    paddingISO9797M1: '0x00으로 블록 크기까지 채움',
    paddingISO9797M2: 'ISO 7816-4와 동일',
    mode8BitNote: '참고: 8비트 모드는 한 번에 1바이트를 처리합니다',
    mode64BitNote: '64비트 모드는 한 번에 전체 블록(8바이트)을 처리합니다',
  },

  rsa: {
    title: 'RSA 암호화/복호화',
    description: 'RSA 비대칭 암호화, 복호화, 서명 및 검증',
    rsaInfo: 'RSA 정보',
    rsaInfo1: 'RSA는 비대칭 암호화 알고리즘입니다',
    rsaInfo2: '키 크기: 1024, 2048, 4096비트 (2048 이상 권장)',
    rsaInfo3: 'PKCS#1 v1.5 및 OAEP 패딩 지원',
    tabKeys: '키',
    tabEncrypt: '암호화',
    tabDecrypt: '복호화',
    tabSign: '서명',
    tabVerify: '검증',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA 모듈러스 (16진수)',
    privateExpPlaceholder: 'RSA 개인 지수 (16진수)',
    keyLength: '키 길이',
    generateKeys: '키 생성',
    importKeys: '키 가져오기',
    clearKeys: '지우기',
    keyGenerated: '키 쌍이 성공적으로 생성되었습니다',
    keysCleared: '키가 지워졌습니다',
    keyImported: '공개 키가 성공적으로 가져왔습니다',
    privateKeyImportNote: '개인 키 가져오기에는 전체 CRT 매개변수가 필요합니다. 전체 기능을 사용하려면 "키 생성"을 사용하세요.',
    padding: '패딩',
    hashAlgorithm: '해시 알고리즘',
    data: '데이터',
    dataToEncrypt: '암호화할 데이터',
    dataPlaceholderAscii: '텍스트 데이터 입력',
    encodingMethod: '인코딩 방법',
    private: '개인',
    public: '공개',
    inputDataFormat: '입력 데이터 형식',
    hexadecimal: '16진수',
    paddingMethod: '패딩 방법',
    noPadding: '패딩 없음',
    errorDataRequired: '데이터가 필요합니다',
    privateEncryptNote: '참고: 암호화 데모에 공개 키 사용',
    dataToSign: '서명할 데이터',
    dataToVerify: '검증할 데이터',
    ciphertextToDecrypt: '복호화할 암호문',
    signatureToVerify: '서명',
    dataPlaceholder: '16진수 데이터 입력',
    ciphertextPlaceholder: '암호화된 16진수 데이터 입력',
    signaturePlaceholder: '16진수 서명 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    sign: '서명',
    verify: '검증',
    encryptedResult: '암호화 결과',
    encryptionFinished: '데이터 암호화 작업 완료',
    decryptionFinished: '데이터 복호화 작업 완료',
    decodingMethod: '디코딩 방법',
    copyResult: '결과 복사',
    result: '결과',
    decryptedResult: '복호화 결과',
    signatureResult: '서명',
    signatureValid: '✓ 서명이 유효합니다',
    signatureInvalid: '✗ 서명이 유효하지 않습니다',
    encryptInfo: 'RSA 암호화',
    encryptDesc: '공개 키로 데이터 암호화',
    decryptInfo: 'RSA 복호화',
    decryptDesc: '개인 키로 데이터 복호화',
    signInfo: 'RSA 서명',
    signDesc: '개인 키로 데이터 서명 (RSA-PSS)',
    verifyInfo: 'RSA 서명 검증',
    verifyDesc: '공개 키로 서명 검증 (RSA-PSS)',
    oaepDesc1: 'OAEP는 RSA 암호화에 사용되는 패딩 체계입니다',
    oaepDesc2: 'PKCS#1 v1.5 패딩보다 더 안전합니다',
    oaepDesc3: '선택된 암호문 공격을 방지합니다',
    oaepDesc4: '새로운 애플리케이션에 권장됩니다',
    oaepStructure: 'OAEP 구조',
    maxDataSize: '최대 데이터 크기',
    errorKeyGen: '키 생성 실패',
    errorKeyImport: '키 가져오기 실패',
    errorInvalidModulus: '유효하지 않은 모듈러스',
    errorInvalidPublicExp: '유효하지 않은 공개 지수',
    errorNoPublicKey: '먼저 공개 키를 생성하거나 가져오세요',
    errorNoPrivateKey: '먼저 키 쌍을 생성하세요 (개인 키 필요)',
    errorInvalidData: '유효하지 않은 데이터 (16진수여야 함)',
    errorInvalidCiphertext: '유효하지 않은 암호문 (16진수여야 함)',
    errorInvalidSignature: '유효하지 않은 서명 (16진수여야 함)',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    errorSign: '서명 실패',
    errorVerify: '검증 실패',
  },

  ecc: {
    title: 'ECC (ECDSA)',
    description: '타원 곡선 암호학 - 디지털 서명 알고리즘',
    infoTitle: 'ECC/ECDSA 정보',
    infoContent1: '타원 곡선 암호학은 더 작은 키 크기로 강력한 보안 제공',
    infoContent2: '디지털 서명을 위한 P-256, P-384, P-521 곡선 지원',
    infoContent3: 'ECDSA 서명으로 데이터의 진위성과 무결성 검증 가능',
  },

  sslCert: {
    title: 'SSL 인증서 (X509)',
    description: 'RSA 키 생성, CSR 생성, 자체 서명 인증서 및 X.509 인증서 분석',
    infoTitle: 'X.509 인증서 정보',
    info1: 'X.509는 공개 키 인증서의 표준 형식입니다',
    info2: 'TLS/SSL, 이메일 서명, 코드 서명에 사용됩니다',
    info3: 'CSR(인증서 서명 요청)은 CA에 인증서를 요청하는 데 사용됩니다',
    tabKeys: '키',
    tabCSRs: 'CSR',
    tabReadCSR: 'CSR 읽기',
    tabSelfSigned: '자체 서명 인증서',
    tabReadCert: '인증서 읽기',
    publicExponent: '공개 지수(e)',
    keyLength: '키 길이',
    passPhrase: '암호 문구',
    passPhrasePlaceholder: '개인 키를 암호화할 암호 문구 입력',
    generateKeys: '키 생성',
    privateKey: '개인 키',
    keyGenerated: '키 쌍 생성 성공',
    generating: 'RSA 키 쌍 생성 중...',
    privateKeyPlaceholder: '암호화된 PEM 개인 키 붙여넣기',
    version: '버전',
    country: '국가명',
    state: '시/도',
    locality: '시/군/구',
    organization: '조직',
    unit: '부서',
    commonName: '일반 이름',
    email: '이메일 주소',
    generateCSR: 'CSR 생성',
    generatedCSR: '생성된 CSR',
    csrGenerated: '인증서 서명 요청이 생성되었습니다',
    inputPK: '입력된 개인 키',
    certificateSigningRequest: '인증서 서명 요청',
    generatingCSR: 'CSR 생성 중...',
    inputCSR: 'CSR 입력',
    csrPlaceholder: 'PEM 형식 CSR 붙여넣기 (-----BEGIN CERTIFICATE REQUEST-----)',
    parseCSR: 'CSR 분석',
    parsedCSRInfo: '분석된 CSR 정보',
    csrParsed: 'CSR 분석 성공',
    csrRead: '인증서 서명 요청 읽기',
    pemData: 'PEM 데이터',
    publicKey: '공개 키',
    validityBefore: '유효 기간 시작',
    validityAfter: '유효 기간 종료',
    days: '일',
    serialNumber: '일련 번호',
    generateCert: '인증서 생성',
    generatedCert: '생성된 인증서',
    certGenerated: '인증서가 생성되었습니다',
    generatingCert: '인증서 생성 중...',
    certificate: '인증서',
    inputCert: '인증서 입력',
    certPlaceholder: 'PEM 형식 인증서 붙여넣기 (-----BEGIN CERTIFICATE-----)',
    parseCert: '인증서 분석',
    parsedCertInfo: '분석된 인증서 정보',
    certParsed: '인증서 분석 성공',
    validFrom: '유효 기간 시작',
    validTo: '유효 기간 종료',
    issuer: '발급자',
    subject: '주체',
    extensions: '확장',
    errorPassPhraseRequired: '암호 문구를 입력하세요',
    errorPrivateKeyRequired: '개인 키를 입력하세요',
    errorCommonNameRequired: '일반 이름을 입력하세요',
    errorInvalidPrivateKey: '개인 키 또는 암호 문구가 잘못되었습니다',
    errorCSRRequired: 'CSR을 입력하세요',
    errorCertRequired: '인증서를 입력하세요',
    errorKeyGen: '키 생성 실패',
    errorCSRGen: 'CSR 생성 실패',
    errorCSRParse: 'CSR 분석 실패',
    errorCertGen: '인증서 생성 실패',
    errorCertParse: '인증서 분석 실패',
  },

  keyshareGenerator: {
    title: '키쉐어 생성기',
    description: '키를 입력하여 여러 쉐어로 분할, KCV 검증 지원',
    infoTitle: '키쉐어 생성기 정보',
    infoContent: 'XOR 연산을 사용하여 암호화 키를 여러 쉐어로 분할합니다.',
    infoContent2: '각 쉐어는 키 세리머니에서 다른 관리자에게 배포할 수 있습니다.',
    mode: '모드',
    insecure: 'Insecure',
    secure: 'Secure',
    parity: '패리티',
    ignore: '무시',
    forceOdd: '홀수 패리티 강제',
    combinedKey: '결합된 키',
    threePartKey: '3파트 키',
    twoPartKey: '2파트 키',
    parityAdjusted: '패리티 조정됨',
    setPinFirst: '먼저 4자리 PIN을 설정하세요',
    keyRevealed: '키 쉐어가 공개되었습니다',
    wrongPin: 'PIN이 올바르지 않습니다',
    enterPin: 'PIN 입력',
    enterPinToReveal: '키 쉐어를 보려면 4자리 PIN을 입력하세요',
    unlock: '잠금 해제',
    regenerate: '재생성',
  },

  futurexKeys: {
    title: 'Futurex 키 암호화/복호화',
    description: 'Futurex HSM 키 변형 방식으로 키 암호화/복호화',
    infoTitle: 'Futurex 키 정보',
    infoContent1: 'Futurex HSM 변형으로 키 암호화/복호화.',
    infoContent2: '모디파이어 (0-F)로 MFK에서 다른 변형 생성.',
    infoContent3: 'MFK (Master File Key)는 기본 암호화 키.',
    tabEncrypt: '키 암호화/복호화',
    tabLookup: '키 조회',
    key: '키',
    modifier: '모디파이어',
    modifierHint: '키 변형 선택기 (0-F)',
    mfk: 'MFK (Master File Key)',
    customMfk: '사용자 정의 MFK...',
    encrypt: '암호화',
    decrypt: '복호화',
    encryptedKey: '암호화된 키',
    decryptedKey: '복호화된 키',
    encryptedKeyInput: '암호화된 키',
    lookup: '모든 모디파이어 조회',
    lookupResults: '조회 결과',
    encryptSuccess: '키 암호화 성공',
    decryptSuccess: '키 복호화 성공',
    errorInvalidKey: '잘못된 키 형식',
    errorKeyLength: '키는 16, 24, 32바이트여야 합니다',
    errorInvalidMfk: '잘못된 MFK 형식(32자 이상의 16진수 필요)',
    errorEncrypt: '암호화 실패',
    errorDecrypt: '복호화 실패',
    errorLookup: '조회 실패',
    noResults: '유효한 복호화를 찾을 수 없습니다',
    encryptResult: '키 암호화 결과',
    decryptResult: '키 복호화 결과',
    plainKey: '평문 키',
    encryptedKeyLabel: '암호화된 키',
    parityDetected: '패리티 감지',
    mfkLabel: 'MFK',
    keyModifier: '키 모디파이어',
    decodedKey: '복호화된 키',
    kcvLabel: 'KCV',
    checkKcv: 'KCV 확인?',
    type: '유형',
    typeAny: '모두',
    typeFuturex: 'Futurex',
    typeIbm: 'IBM',
    typeAtalla: 'Atalla',
    typeVisa: 'VISA',
    parityLabel: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
    keyPlaceholder: '조회할 암호화된 키 입력',
    kcvPlaceholder: '일치할 KCV 입력(6자 16진수)',
    errorInvalidKcv: '잘못된 KCV 형식(6자 이상의 16진수 필요)',
  },

  atallaKeys: {
    title: 'Atalla 키 (AKB)',
    description: 'Atalla HSM AKB 형식으로 키 암호화/복호화',
    infoTitle: 'Atalla 키 정보',
    infoContent1: 'Atalla Key Block (AKB) 형식으로 키 암호화/복호화.',
    infoContent2: 'AKB 헤더(8자)로 키 변형 정의.',
    infoContent3: 'MFK (Master File Key)는 기본 암호화 키.',
    tabEncrypt: '키 암호화',
    tabDecode: 'AKB 디코드',
    key: '키',
    akbHeader: 'AKB 헤더',
    akbHeaderHint: 'Atalla Key Block 헤더(8자)',
    mfkKey: 'MFK 키',
    mfkPlaceholder: 'MFK 입력(48자 16진수)',
    keyPlaceholder: '16진수 키 입력(16/24/32바이트)',
    encrypt: '암호화',
    decode: '디코드',
    akb: 'AKB',
    akbPlaceholder: 'AKB 입력(헤더,암호화데이터)',
    checkKcv: 'KCV 확인?',
    kcvS: 'KCV (S)',
    kcvPlaceholder: '예상 KCV 입력',
    parity: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
    encryptSuccess: '키 암호화 성공',
    decodeSuccess: 'AKB 디코드 성공',
    errorInvalidKey: '잘못된 키 형식',
    errorKeyLength: '키는 16, 24, 32바이트여야 합니다',
    errorHeaderLength: 'AKB 헤더는 8자여야 합니다',
    errorInvalidMfk: 'MFK는 48자 이상의 16진수여야 합니다',
    errorInvalidAkb: '잘못된 AKB 형식(헤더,데이터 필요)',
    errorInvalidAkbData: 'AKB의 암호화 데이터가 잘못됨',
    errorInvalidKcv: '잘못된 KCV 형식',
    errorEncrypt: '암호화 실패',
    errorDecode: '디코드 실패',
    kcvMismatch: 'KCV가 일치하지 않습니다',
    macMismatch: 'MAC 검증 실패',
    parityMismatch: '패리티가 일치하지 않습니다',
    decodeFailed: 'AKB 디코드 실패',
    encryptResult: '암호화 결과',
    decodeResult: '디코드 결과',
    plainKey: '평문 키',
    encryptedAkb: '암호화된 AKB',
    kcv: 'KCV',
    header: '헤더',
    decodedKey: '복호화된 키',
    parityDetected: '패리티',
  },

  safenetKeys: {
    title: 'SafeNet 키 암호화/복호화',
    description: 'SafeNet HSM 키 변형 방식으로 키 암호화/복호화',
    infoTitle: 'SafeNet 키 정보',
    infoContent1: 'SafeNet HSM 방식으로 키 암호화/복호화.',
    infoContent2: '키 형식으로 암호화 유형(ECB/CBC) 정의.',
    infoContent3: '변형으로 키 용도(DPK, PPK, MPK 등) 결정.',
    tabEncrypt: '키 암호화/복호화',
    tabLookup: '키 조회',
    key: '키',
    keyFormat: '키 형식',
    variant: '변형',
    kmKey: 'KM 키',
    kmKeyPlaceholder: 'KM 키 입력(32자 16진수)',
    keyPlaceholder: '16진수 키 입력',
    lookupKeyPlaceholder: '조회할 암호화된 키 입력',
    encrypt: '암호화',
    decrypt: '복호화',
    lookup: '조회',
    encryptSuccess: '키 암호화 성공',
    decryptSuccess: '키 복호화 성공',
    decryptFailed: '복호화 실패',
    errorInvalidKey: '잘못된 키 형식',
    errorInvalidKmKey: 'KM 키는 16바이트 이상이어야 합니다',
    errorInvalidKcv: '잘못된 KCV 형식',
    errorEncrypt: '암호화 실패',
    errorDecrypt: '복호화 실패',
    errorLookup: '조회 실패',
    noResults: '일치하는 키를 찾을 수 없습니다',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    plainKey: '평문 키',
    encryptedKeyLabel: '암호화된 키',
    decodedKey: '복호화된 키',
    kcvLabel: 'KCV',
    parityDetected: '패리티',
    checkKcv: 'KCV 확인?',
    kcv: 'KCV',
    kcvPlaceholder: '예상 KCV 입력',
    parity: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
  },

  thalesKeys: {
    title: 'Thales 키 암호화/복호화',
    description: 'Thales HSM LMK 키 변형 방식으로 키 암호화/복호화',
    infoTitle: 'Thales 키 정보',
    infoContent1: 'Thales HSM LMK 방식으로 키 암호화/복호화.',
    infoContent2: '키 스킴으로 키 길이와 암호화 유형 정의.',
    infoContent3: '변형으로 LMK에 적용할 XOR 마스크 결정.',
    tabEncrypt: '키 암호화/복호화',
    tabLookup: '키 조회',
    key: '키',
    keyScheme: '키 스킴',
    lmkSize: 'LMK 크기',
    double: '더블',
    triple: '트리플',
    lmkPair: 'LMK 쌍',
    lmkKey: 'LMK 키',
    variant: '변형',
    keyPlaceholder: '16진수 키 입력',
    lookupKeyPlaceholder: '조회할 암호화된 키 입력(스킴 접두사 유무)',
    encrypt: '암호화',
    decrypt: '복호화',
    lookup: '조회',
    encryptSuccess: '키 암호화 성공',
    decryptSuccess: '키 복호화 성공',
    decryptFailed: '복호화 실패',
    errorInvalidKey: '잘못된 키 형식',
    errorInvalidLmkKey: '잘못된 LMK 키',
    errorInvalidKcv: '잘못된 KCV 형식',
    errorEncrypt: '암호화 실패',
    errorDecrypt: '복호화 실패',
    errorLookup: '조회 실패',
    noResults: '일치하는 키를 찾을 수 없습니다',
    encryptResult: '암호화 결과',
    decryptResult: '복호화 결과',
    plainKey: '평문 키',
    encryptedKeyLabel: '암호화된 키',
    decodedKey: '복호화된 키',
    kcvLabel: 'KCV',
    parityDetected: '패리티',
    checkKcv: 'KCV 확인?',
    kcv: 'KCV',
    kcvPlaceholder: '예상 KCV 입력',
    parity: '패리티',
    parityAny: '모두',
    parityOdd: '홀수',
    parityEven: '짝수',
  },

  thalesKeyBlock: {
    title: 'Thales 키 블록',
    description: 'Thales 전용 키 블록 인코딩/디코딩',
    infoTitle: 'Thales 키 블록 정보',
    infoContent1: 'Thales 전용 키 블록 인코딩/디코딩.',
    infoContent2: 'TR-31과 유사하지만 Thales 특정 형식.',
    infoContent3: 'KBPK(키 블록 보호 키)로 암호화.',
    tabEncode: '인코드',
    tabDecode: '디코드',
    plainKey: '평문 키',
    versionId: '버전 ID',
    keyUsage: '키 용도',
    algorithm: '알고리즘',
    modeOfUse: '사용 모드',
    keyVersionNum: '키 버전#',
    exportability: '내보내기 가능성',
    optKeyBlocks: '선택적 키 블록 수',
    lmkId: 'LMK ID',
    optionalHeaders: '선택적 헤더',
    encode: '인코드',
    decode: '디코드',
    keyBlock: '키 블록',
    encodeResult: '인코드 결과',
    decodeResult: '디코드 결과',
  },

  fpe: {
    title: '형식 보존 암호화',
    description: '형식과 길이를 유지하면서 데이터 암호화 (NIST SP 800-38G)',
    radix: '기수',
    encryptionType: '암호화 유형',
    keyInput: '키 입력',
    useTweak: 'Tweak 사용?',
    fpeInfo: 'FPE 정보',
    formatPreserving: '형식 보존: 출력이 입력과 동일한 형식과 길이를 가짐',
    radixInfo: '현재 기수가 데이터의 유효한 문자 집합을 정의합니다',
    tweakInfo: 'Tweak은 암호화에 추가 입력을 제공합니다 (IV와 유사)',
    minLength: '최소 데이터 길이: 2자',
    dataPlaceholder: '유효한 기수 문자로 데이터 입력',
    tweakPlaceholderFF1: 'Tweak을 16진수로 입력 (임의의 길이)',
    tweakPlaceholderFF3: '16자리 16진수 문자 (8바이트)',
    resultLength: '길이',
    characters: '문자',
    algorithm: '알고리즘',
    errorInvalidKeyHex: '키는 유효한 16진수여야 합니다',
    errorKeyLength: '{algorithm}의 키 길이는 {length}바이트여야 합니다',
    errorDataRequired: '데이터를 입력하세요',
    errorDataTooShort: '데이터는 최소 2자여야 합니다',
    errorInvalidDataForRadix: '데이터에 기수 {radix}의 유효하지 않은 문자가 포함되어 있습니다',
    errorInvalidTweakHex: 'Tweak은 유효한 16진수여야 합니다',
    errorTweakLength: '{algorithm}의 Tweak 길이는 {length}바이트여야 합니다',
    errorEncryption: '암호화 실패',
    errorDecryption: '복호화 실패',
    algorithmNotImplemented: '이 알고리즘은 아직 완전히 구현되지 않았습니다',
  },

  // SEO Content
  seo: {
    home: {
      title: 'HSM Kit - 무료 온라인 암호화 및 키 관리 도구',
      description: '무료 온라인 암호화 도구. Thales, Futurex, Atalla, SafeNet HSM 키 작업 지원. KCV 계산, TR-31 키 블록 인코딩, 안전한 키 생성, AES/DES/RSA 암호화. 모든 계산은 브라우저에서 실행. 100% 무료, 등록 불필요.',
      keywords: 'HSM 도구, Thales HSM, Futurex HSM, Atalla AKB, SafeNet 키, 암호화 도구키트, 키 관리, KCV 계산기, TR-31 키 블록, AES 암호화, DES 암호화, RSA 암호화, PIN 블록, 키 생성기, 암호화 도구, 결제 보안, LMK 암호화, 온라인 암호화 도구, 무료 암호화 도구',
      faqTitle: '자주 묻는 질문',
      usageTitle: 'HSM Kit 소개',
      faqs: [
        { question: 'HSM Kit은 무료인가요?', answer: '네, HSM Kit은 25개 이상의 암호화 도구를 100% 무료로 제공합니다. 등록, 로그인, 결제 불필요. 모든 기능을 즉시 사용할 수 있습니다.' },
        { question: '데이터는 안전한가요?', answer: '물론입니다. 모든 작업은 JavaScript를 사용하여 브라우저에서 완전히 실행됩니다. 키, PIN, 민감한 데이터가 장치를 벗어나지 않습니다. 서버 통신 제로.' },
        { question: '어떤 HSM 벤더가 지원되나요?', answer: 'HSM Kit은 Thales(LMK 암호화, 키 블록), Futurex(MFK 변형), Atalla(AKB 형식), SafeNet(KM 키 변형) HSM 키 작업을 지원합니다.' },
        { question: '어떤 암호화 알고리즘이 지원되나요?', answer: 'AES(128/192/256비트), DES, 3DES, RSA, ECC/ECDSA, 형식 보존 암호화(FPE FF1/FF3-1)를 지원합니다. 다양한 모드와 패딩 옵션 제공.' },
        { question: '결제 보안에 사용할 수 있나요?', answer: '물론입니다! PIN 블록 생성(ISO 9564), TR-31/Thales 키 블록, KCV 계산, 키 쉐어 생성, HSM 키 암호화/복호화 도구를 포함한 전문 도구를 제공합니다.' },
        { question: '어떤 인코딩 도구가 있나요?', answer: 'Base64, Base94, BCD, 문자 인코딩(ASCII/EBCDIC/Hex), ASN.1/DER 파싱, UUID 생성, 해시 계산(MD5/SHA/BLAKE2), 체크 디지트 검증.' },
      ],
      usage: [
        'HSM Kit은 보안 전문가, 개발자, 암호화 및 결제 시스템 작업자를 위해 설계된 25개 이상의 암호화 도구 모음입니다.',
        '모든 도구는 브라우저에서 완전히 작동합니다. 서버 통신 제로로 민감한 데이터, 키, PIN이 장치를 벗어나지 않습니다.',
        'Thales, Futurex, Atalla, SafeNet 키 작업, TR-31 키 블록, KCV 계산을 지원하는 전문 HSM 도구.',
        '암호화, 결제 보안 및 HSM 키 관리 분야의 테스트, 개발 및 교육 목적에 완벽합니다.',
      ],
    },
    as2805: {
      title: 'AS2805 결제 도구: 터미널 키 세트, PIN 블록, MAC, OWF | HSM Kit',
      description: '종합 AS2805 유틸리티: 터미널 키 세트 생성, PIN 블록 변환, ISO9797-1 M2 TDES-CBC MAC, OWF(HMAC-SHA256). 100% 클라이언트 측, 데이터가 장치를 떠나지 않습니다.',
      keywords: 'AS2805, AS2805.4.1, 터미널 키 세트, PIN 블록 변환, MAC, OWF, ISO9797-1 M2, TDES CBC-MAC, HMAC-SHA256, ZPK, TPK, KEK 플래그 1,2,3, KEK 키 스킴 B,C,H,F,G, LMK 키 스킴 0,T,U,X,Y,Z, KCV 타입 0,1,2, 결제 보안',
      faqTitle: 'AS2805 FAQ',
      usageTitle: '사용 방법',
      faqs: [
        { question: 'AS2805란 무엇인가요?', answer: 'AS2805는 호주에서 널리 사용되는 금융 메시지 및 보안 작업 표준입니다.' },
        { question: '계산은 클라이언트 측인가요?', answer: '네. 모든 작업은 브라우저에서 완전히 실행되며 서버로 전송되지 않습니다.' },
        { question: '지원하는 KEK 플래그 값은?', answer: '1, 2, 3.' },
        { question: '지원하는 KEK 키 스킴은?', answer: 'B, C, H, F, G.' },
        { question: '지원하는 LMK 키 스킴은?', answer: '0, T, U, X, Y, Z.' },
        { question: '지원하는 KCV 타입은?', answer: '0, 1, 2.' },
        { question: 'MAC 알고리즘은?', answer: 'ISO9797-1 패딩 방식 2 + TDES CBC-MAC(마지막 블록).' },
        { question: 'OWF 알고리즘은?', answer: 'HMAC-SHA256(32바이트 16진 출력).' },
      ],
      usage: [
        '터미널 키 세트: KEK 플래그(1/2/3) 선택.',
        'KEKr 키를 16진수로 입력; 길이 표시는 입력 상단에 표시.',
        'KEK 키 스킴(B/C/H/F/G)과 LMK 키 스킴(0/T/U/X/Y/Z) 선택.',
        'KCV 타입(0/1/2) 선택 후 "생성"을 클릭하여 KCV, ZPK, TPK 생성.',
        'PIN 블록 변환: 시스템 ZPK와 터미널 TPK(16진수)를 입력하고 실시간 길이 표시 확인.',
        'STAN과 거래 금액을 입력하고 입/출력 포맷 선택(예: 46 → 01).',
        '입력 PIN 블록(16개의 16진수)과 계좌번호(12–19자리)를 제공한 후 "변환" 클릭.',
        'MAC: 키(16/32/48 16진수)와 데이터(16진수)를 입력. ISO9797-1 M2 패딩 후 TDES CBC-MAC 계산.',
        'OWF: 키(16/32/48/64 16진수)와 데이터(16진수)를 입력. HMAC-SHA256 계산.',
        '결과 카드의 복사 버튼으로 빠르게 복사.',
      ],
    },
    asn1: {
      title: 'ASN.1 파서 온라인 - 무료 DER/BER 구조 디코더 | HSM Kit',
      description: '무료 온라인 ASN.1 파서 및 디코더. ASN.1 DER/BER 구조 파싱, X.509 인증서 디코딩, PKCS 형식 분석. 16진수, Base64, PEM 입력 지원 및 RFC 정의 매칭. 100% 클라이언트 측 처리.',
      keywords: 'ASN.1 파서, DER 디코더, BER 디코더, X.509 인증서 파서, PKCS 디코더, ASN1 온라인 도구, 인증서 분석기, PEM 파서, ASN.1 디코더, 인증서 파서, PKCS 파서',
      faqTitle: 'ASN.1 파서 FAQ',
      usageTitle: 'ASN.1 파서 사용 방법',
      faqs: [
        { question: 'ASN.1이란 무엇인가요?', answer: 'ASN.1(Abstract Syntax Notation One)은 직렬화 및 역직렬화 가능한 데이터 구조를 정의하기 위한 표준 인터페이스 설명 언어입니다. 암호화, 통신, 네트워크 프로토콜에서 널리 사용됩니다.' },
        { question: '이 파서는 어떤 형식을 지원하나요?', answer: '이 파서는 DER(Distinguished Encoding Rules) 및 BER(Basic Encoding Rules)로 인코딩된 ASN.1 구조를 지원합니다. 16진수, Base64 또는 PEM 형식으로 데이터를 입력할 수 있습니다.' },
        { question: 'X.509 인증서를 파싱할 수 있나요?', answer: '네, 이 도구는 X.509 인증서, CSR, PKCS#7/8/12 구조 및 ASN.1 인코딩을 사용하는 기타 인증서 형식을 파싱할 수 있습니다.' },
        { question: '16진수 덤프 기능이란 무엇인가요?', answer: '16진수 덤프 기능은 파싱된 트리 뷰 옆에 ASN.1 구조의 원시 바이트를 표시하여 바이너리 인코딩의 이해를 돕습니다.' },
      ],
      usage: [
        'ASN.1 인코딩 데이터를 16진수, Base64 또는 PEM 형식으로 입력 필드에 붙여넣습니다.',
        '"파싱"을 클릭하여 구조를 디코딩하고 계층적 트리 표현을 봅니다.',
        '"16진수 덤프 포함"을 활성화하면 파싱된 구조 옆에 원시 바이트를 볼 수 있습니다.',
        '"정의 포함"을 사용하여 X.509, PKCS 등 알려진 RFC 정의와 구조를 매칭합니다.',
      ],
    },
    aes: {
      title: 'AES 암호화/복호화 온라인 - 무료 AES 계산기 | HSM Kit',
      description: '무료 온라인 AES 암호화 및 복호화 도구. ECB, CBC, CFB, OFB, CTR 모드로 AES-128, AES-192, AES-256 지원. KCV 계산, 브라우저에서 안전하게 16진수 또는 텍스트 데이터 암호화/복호화. 100% 클라이언트 측 처리, 데이터는 서버로 전송되지 않습니다.',
      keywords: 'AES 암호화, AES 복호화, AES-128, AES-192, AES-256, AES 계산기, AES 온라인 도구, AES ECB, AES CBC, AES KCV, 고급 암호화 표준, 대칭 암호',
      faqTitle: 'AES 암호화 FAQ',
      usageTitle: 'AES 암호화 도구 사용 방법',
      faqs: [
        { question: 'AES 암호화란 무엇인가요?', answer: 'AES(Advanced Encryption Standard)는 전 세계 표준이 된 대칭 블록 암호입니다. 128, 192 또는 256비트 키를 사용하여 128비트 블록 단위로 데이터를 암호화합니다.' },
        { question: '어떤 AES 모드를 사용해야 하나요?', answer: 'CBC 모드는 대부분의 응용 프로그램에서 일반적으로 권장됩니다. ECB 모드는 한 블록보다 큰 데이터 암호화에는 패턴이 드러나므로 피해야 합니다. CTR 모드는 스트리밍 데이터에 적합합니다.' },
        { question: 'AES가 지원하는 키 크기는?', answer: 'AES는 세 가지 키 크기를 지원합니다: AES-128(16바이트), AES-192(24바이트), AES-256(32바이트). 키가 길수록 보안이 강화됩니다.' },
        { question: 'AES 암호화에서 IV란 무엇인가요?', answer: 'IV(초기화 벡터)는 CBC, CFB, OFB, CTR 등의 모드에서 사용되는 랜덤 값으로, 동일한 평문이 다른 암호문을 생성하도록 보장합니다. IV는 고유해야 하지만 비밀일 필요는 없습니다.' },
      ],
      usage: [
        'AES 키 크기(128, 192 또는 256비트)와 암호화 모드(ECB, CBC 등)를 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'ECB 이외의 모드에서는 IV(16바이트 16진수)를 제공합니다.',
        '암호화 또는 복호화할 데이터를 입력하고 해당 버튼을 클릭합니다.',
      ],
    },
    des: {
      title: 'DES/3DES 암호화 온라인 - 무료 트리플 DES 계산기 | HSM Kit',
      description: '무료 온라인 DES 및 트리플 DES(3DES) 암호화 및 복호화 도구. DES, 2키 3DES, 3키 3DES를 ECB/CBC 모드로 지원. PKCS5, ISO 7816 등 다양한 패딩 옵션. 100% 클라이언트 측 처리, 안전한 암호화.',
      keywords: 'DES 암호화, 3DES 암호화, 트리플 DES, DES 복호화, DES 계산기, 3DES 온라인 도구, TDES, DES ECB, DES CBC, 데이터 암호화 표준, 결제 암호화',
      faqTitle: 'DES/3DES 암호화 FAQ',
      usageTitle: 'DES/3DES 도구 사용 방법',
      faqs: [
        { question: 'DES와 3DES의 차이점은?', answer: 'DES는 단일 56비트 키(패리티 포함 8바이트)를 사용하고, 3DES는 2개 또는 3개의 다른 키(16 또는 24바이트)로 DES 알고리즘을 3번 적용하여 훨씬 강력한 보안을 제공합니다.' },
        { question: 'DES는 아직 안전한가요?', answer: '단일 DES는 안전하지 않고 더 이상 사용되지 않습니다. 3DES는 레거시 시스템, 특히 결제 산업에서 여전히 사용되지만, 새 응용 프로그램에는 AES가 권장됩니다.' },
        { question: 'DES 키의 패리티 비트란?', answer: 'DES에서 키의 각 바이트에는 하나의 패리티 비트(최하위 비트)가 있어 유효 키 길이가 64비트에서 56비트가 됩니다. 이 도구는 패리티 비트를 자동으로 조정할 수 있습니다.' },
        { question: '어떤 패딩을 사용해야 하나요?', answer: 'PKCS5/PKCS7이 가장 일반적인 선택입니다. ISO 9797은 은행 응용 프로그램에서 자주 사용됩니다. 선택은 상대방이 기대하는 것과 일치해야 합니다.' },
      ],
      usage: [
        'DES(8바이트 키) 또는 3DES(16 또는 24바이트 키)를 선택합니다.',
        '암호화 모드(ECB 또는 CBC)와 패딩 방법을 선택합니다.',
        '키를 16진수 형식으로 입력합니다.',
        'CBC 모드의 경우 IV(8바이트 16진수)를 제공합니다.',
        '데이터를 입력하고 암호화 또는 복호화를 클릭합니다.',
      ],
    },
    rsa: {
      title: 'RSA 암호화 온라인 - 무료 RSA 계산기 및 키 생성기 | HSM Kit',
      description: '무료 온라인 RSA 암호화, 복호화, 서명, 검증 도구. RSA 키 쌍(1024-4096비트) 생성, 공개 키로 암호화, 개인 키로 서명. PKCS#1 및 OAEP 패딩 지원. 모든 작업은 클라이언트 측에서 처리.',
      keywords: 'RSA 암호화, RSA 복호화, RSA 키 생성기, RSA 계산기, RSA 온라인 도구, RSA 서명, RSA 검증, 공개 키 암호화, PKCS1, OAEP, 비대칭 암호화, 디지털 서명',
      faqTitle: 'RSA 암호화 FAQ',
      usageTitle: 'RSA 도구 사용 방법',
      faqs: [
        { question: 'RSA 암호화란 무엇인가요?', answer: 'RSA는 공개 키로 암호화하고 개인 키로 복호화하는 키 쌍을 사용하는 비대칭 암호화 알고리즘입니다. 안전한 데이터 전송과 디지털 서명에 널리 사용됩니다.' },
        { question: '어떤 키 크기를 사용해야 하나요?', answer: '현재 보안 표준에서 2048비트 키가 최소로 간주됩니다. 장기 보안을 위해 4096비트 키가 권장됩니다. 1024비트 키는 더 이상 권장되지 않습니다.' },
        { question: 'PKCS#1과 OAEP의 차이점은?', answer: 'PKCS#1 v1.5는 오래된 패딩 체계입니다. OAEP(최적 비대칭 암호화 패딩)는 더 안전하며 특정 공격을 방지하므로 새 응용 프로그램에 권장됩니다.' },
        { question: 'RSA 암호화의 최대 데이터 크기는?', answer: 'RSA는 키 크기에서 패딩 오버헤드를 뺀 크기보다 작은 데이터만 암호화할 수 있습니다. OAEP-SHA256이 있는 2048비트 키의 경우 최대 약 190바이트입니다. 더 큰 데이터에는 하이브리드 암호화를 사용하세요.' },
      ],
      usage: [
        '새 RSA 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '암호화: 평문을 입력하고 암호화 클릭(공개 키 사용).',
        '복호화: 암호문을 입력하고 복호화 클릭(개인 키 필요).',
        '서명: 데이터 해시를 입력하고 서명 클릭(개인 키 필요).',
        '검증: 데이터, 서명을 입력하고 검증 클릭(공개 키 사용).',
      ],
    },
    ecc: {
      title: 'ECC/ECDSA 온라인 도구 - 타원 곡선 암호화 | HSM Kit',
      description: '무료 온라인 ECC(타원 곡선 암호화) 도구. ECDSA 키 쌍 생성, secp256k1, P-256, P-384 곡선으로 데이터 서명 및 검증. 컴팩트한 키로 강력한 보안. 100% 브라우저 처리.',
      keywords: 'ECC 암호화, ECDSA, 타원 곡선, secp256k1, P-256, P-384, ECC 키 생성기, ECDSA 서명, ECDSA 검증, 비트코인 암호화, 이더리움 암호화, 디지털 서명',
      faqTitle: 'ECC/ECDSA FAQ',
      usageTitle: 'ECC/ECDSA 도구 사용 방법',
      faqs: [
        { question: 'ECC란 무엇인가요?', answer: '타원 곡선 암호화(ECC)는 타원 곡선의 대수적 구조에 기반한 공개 키 암호화 접근 방식입니다. RSA와 동등한 보안을 훨씬 작은 키 크기로 제공합니다.' },
        { question: 'secp256k1이란 무엇인가요?', answer: 'secp256k1은 비트코인과 이더리움이 디지털 서명에 사용하는 타원 곡선입니다. 보안과 성능의 좋은 균형을 제공합니다.' },
        { question: 'RSA 대신 ECC를 사용하는 이유는?', answer: 'ECC는 RSA와 동일한 보안 수준을 훨씬 작은 키로 제공합니다(256비트 ECC ≈ 3072비트 RSA). 이로 인해 더 빠른 작업과 저장/대역폭 요구 사항 감소가 가능합니다.' },
        { question: 'ECDSA란 무엇인가요?', answer: 'ECDSA(타원 곡선 디지털 서명 알고리즘)는 ECC에 기반한 서명 알고리즘입니다. 데이터의 진위를 검증할 수 있는 디지털 서명을 만드는 데 사용됩니다.' },
      ],
      usage: [
        '타원 곡선(secp256k1, P-256 또는 P-384)을 선택합니다.',
        '새 키 쌍을 생성하거나 기존 키를 가져옵니다.',
        '서명: 데이터(또는 해시)를 입력하고 서명 클릭.',
        '검증: 원본 데이터, 서명을 입력하고 검증 클릭.',
      ],
    },
    fpe: {
      title: '형식 보존 암호화(FPE) 온라인 - FF1/FF3-1 도구 | HSM Kit',
      description: 'NIST SP 800-38G를 구현한 무료 온라인 형식 보존 암호화 도구. 형식과 길이를 보존하면서 데이터 암호화. 신용카드 번호, 주민등록번호 등 구조화된 데이터의 토큰화에 이상적. PCI DSS 준수.',
      keywords: 'FPE, 형식 보존 암호화, FF1, FF3, FF3-1, NIST 800-38G, 토큰화, 신용카드 암호화, 데이터 마스킹, PCI DSS, 데이터 토큰화, 구조화된 데이터 암호화',
      faqTitle: '형식 보존 암호화 FAQ',
      usageTitle: 'FPE 도구 사용 방법',
      faqs: [
        { question: '형식 보존 암호화란 무엇인가요?', answer: 'FPE는 평문과 동일한 형식과 길이의 암호문을 생성하는 암호화 방법입니다. 예를 들어, 16자리 신용카드 번호는 다른 16자리 숫자로 암호화됩니다.' },
        { question: 'FF1과 FF3-1의 차이점은?', answer: '둘 다 NIST 승인 FPE 알고리즘입니다. FF1은 가변 길이 트윅을 지원하고, FF3-1은 고정 56비트 트윅을 사용합니다. FF3-1은 일반적으로 더 빠르지만 제약이 더 많습니다.' },
        { question: '토큰화란 무엇인가요?', answer: '토큰화는 민감한 데이터를 비민감 플레이스홀더(토큰)로 대체합니다. FPE는 토큰이 원래 데이터 형식을 유지하기 때문에 토큰화에 자주 사용됩니다.' },
        { question: 'FPE는 PCI DSS를 준수하나요?', answer: '네, NIST SP 800-38G 승인 알고리즘(FF1, FF3-1)을 사용한 FPE는 올바르게 구현된 경우 PCI DSS 준수에 허용됩니다.' },
      ],
      usage: [
        'FPE 알고리즘(FF1 또는 FF3-1)과 기수(숫자 기반)를 선택합니다.',
        'AES 키(16, 24 또는 32바이트 16진수)를 입력합니다.',
        '추가 보안을 위해 선택적으로 트윅 값을 제공합니다.',
        '평문 데이터를 입력하고 암호화를 클릭하여 형식 보존 암호문을 생성합니다.',
      ],
    },
    keyGenerator: {
      title: '보안 키 생성기 온라인 - 랜덤 AES/DES 키 생성기 | HSM Kit',
      description: '무료 온라인 암호화 키 생성기. AES, DES, 3DES 암호화를 위한 안전한 랜덤 키 생성. 키 결합(XOR), 패리티 조정, 키 검증 도구 포함. 암호학적으로 안전한 난수 생성.',
      keywords: '키 생성기, 랜덤 키, AES 키 생성기, DES 키 생성기, 3DES 키 생성기, 암호화 키, 보안 랜덤, 키 결합, XOR 키, 안전 키 생성, 랜덤 키 생성기',
      faqTitle: '키 생성기 FAQ',
      usageTitle: '키 생성기 사용 방법',
      faqs: [
        { question: '랜덤 키는 어떻게 생성되나요?', answer: '키는 Web Crypto API(crypto.getRandomValues)를 사용하여 생성됩니다. 이는 암호화 키에 적합한 암호학적으로 안전한 난수를 제공합니다.' },
        { question: '키 결합(XOR)이란 무엇인가요?', answer: '키 결합은 여러 키 구성 요소를 XOR하여 완전한 키를 형성할 수 있게 합니다. 이는 여러 관리인이 각각 구성 요소를 보유하는 의식에서 일반적으로 사용됩니다.' },
        { question: '패리티 비트란 무엇인가요?', answer: 'DES/3DES 키에서 각 바이트에는 오류 감지를 위한 패리티 비트가 있습니다. 이 도구는 DES 표준에서 요구하는 홀수 패리티로 패리티 비트를 자동 조정할 수 있습니다.' },
        { question: '지원되는 키 길이는?', answer: '생성기는 DES(8바이트/64비트), 2키 3DES(16바이트/128비트), 3키 3DES(24바이트/192비트) 및 AES-128/192/256을 지원합니다.' },
      ],
      usage: [
        '드롭다운에서 원하는 키 길이를 선택합니다.',
        '"생성"을 클릭하여 새 랜덤 키를 만듭니다.',
        '키 결합 탭을 사용하여 여러 구성 요소를 XOR합니다.',
        '패리티 탭을 사용하여 DES/3DES 키의 패리티 비트를 조정합니다.',
        '검증 탭을 사용하여 키가 올바른 형식과 패리티를 가지고 있는지 확인합니다.',
      ],
    },
    keyshare: {
      title: '키쉐어 생성기 온라인 - 키를 여러 컴포넌트로 분할 | HSM Kit',
      description: '무료 온라인 키쉐어 생성기. 암호화 키를 여러 컴포넌트로 분할. 키를 입력하면 2파트 또는 3파트 쉐어를 자동 생성, KCV 검증 지원. 키 세리머니 및 관리자 배포에 필수. 보안 모드에서 PIN 보호 지원.',
      keywords: '키쉐어 생성기, 키 분할, 키 컴포넌트, XOR 키, 키 세리머니, 키 관리자, KCV 검증, DES 키 쉐어, AES 키 쉐어, 키 배포, 키 분할, 키 보관',
      faqTitle: '키쉐어 생성기 FAQ',
      usageTitle: '키쉐어 생성기 사용 방법',
      faqs: [
        { question: '키 공유란 무엇인가요?', answer: '키 공유는 XOR 연산을 사용하여 암호화 키를 여러 컴포넌트(쉐어)로 분할합니다. 모든 컴포넌트를 XOR하면 원래 키가 재구성됩니다. 키 관리를 분산하여 보안을 강화합니다.' },
        { question: 'Insecure 모드와 Secure 모드의 차이점은?', answer: 'Insecure 모드에서는 생성된 키 쉐어가 직접 표시됩니다. Secure 모드에서는 쉐어가 숨겨지고 4자리 PIN으로 보호됩니다. 각 쉐어를 보려면 올바른 PIN을 입력해야 합니다.' },
        { question: '키 쉐어는 어떻게 생성되나요?', answer: '결합된 키를 입력하면 시스템이 랜덤 쉐어를 생성합니다: Part1 ⊕ Part2 ⊕ Part3 = 결합된 키(3파트), 또는 Part1 ⊕ Part2 = 결합된 키(2파트).' },
        { question: 'KCV(키 체크 값)란 무엇인가요?', answer: 'KCV는 키로 0을 암호화하여 계산되는 체크섬입니다. 각 쉐어와 결합된 키에는 실제 키 값을 공개하지 않고 검증하기 위한 자체 KCV가 있습니다.' },
        { question: 'Force Odd 패리티는 무엇을 하나요?', answer: 'Force Odd는 DES/3DES 키의 각 바이트를 홀수 패리티(홀수 개의 1비트)로 조정합니다. 이는 DES 표준의 정상 작동에 필요합니다.' },
      ],
      usage: [
        '결합된 키 필드에 암호화 키를 입력합니다.',
        '시스템이 자동으로 KCV를 계산하고 키 쉐어를 생성합니다.',
        '3파트 키: XOR하면 결합된 키와 같은 3개의 쉐어.',
        '2파트 키: XOR하면 결합된 키와 같은 2개의 쉐어.',
        'Secure 모드: 각 쉐어에 4자리 PIN을 설정한 후 잠금 해제를 클릭하여 확인.',
      ],
    },
    tr31: {
      title: 'TR-31 키 블록 인코더/디코더 온라인 - ANSI X9.143 | HSM Kit',
      description: '무료 온라인 TR-31 키 블록 인코더 및 디코더. KBPK 보호로 ANSI X9.143(TR-31) 표준에 따라 암호화 키를 래핑/언래핑. 버전 A-E(TDES/AES), 모든 키 용도, 알고리즘, 내보내기 가능성 옵션 지원. 결제 보안에 최적.',
      keywords: 'TR-31, 키 블록, ANSI X9.143, TR31 인코더, TR31 디코더, 키 블록 래퍼, KBPK, 결제 HSM, 키 용도, 키 내보내기 가능성, DUKPT, 키 관리, TDES 키 래핑, AES 키 래핑, 결제 보안, HSM 키 교환',
      faqTitle: 'TR-31 키 블록 FAQ',
      usageTitle: 'TR-31 키 블록 도구 사용 방법',
      faqs: [
        { question: 'TR-31이란 무엇인가요?', answer: 'TR-31(ANSI X9.143)은 결제 시스템에서 안전한 암호화 키 교환을 위한 업계 표준입니다. 암호화 키를 메타데이터(키 용도, 알고리즘, 사용 모드, 내보내기 가능성)와 함께 키 블록 보호 키(KBPK)로 래핑합니다.' },
        { question: 'TR-31의 버전은?', answer: '버전 A는 TDES 변형 바인딩, 버전 B는 TDES 키 유도, 버전 C는 TDES 변형 바인딩(대체), 버전 D는 AES 키 유도(가장 안전, 권장), 버전 E는 CMAC 바인딩이 있는 AES를 사용합니다.' },
        { question: 'KBPK란 무엇인가요?', answer: 'KBPK(키 블록 보호 키)는 TR-31 키 블록을 암호화/복호화하는 데 사용되는 마스터 키입니다. TDES 버전(A/B/C)에는 16 또는 24바이트 키를, AES 버전(D/E)에는 16, 24 또는 32바이트 AES 키를 사용합니다.' },
        { question: '키 용도란 무엇인가요?', answer: '키 용도(2자)는 래핑된 키의 목적을 정의합니다: B0/B1=BDK/DUKPT, C0=CVK, D0=데이터 암호화, E0-E6=EMV 마스터 키, K0/K1=키 래핑, M0-M8=MAC 키, P0/P1=PIN 키, V0-V4=PIN 검증.' },
        { question: '사용 모드란 무엇인가요?', answer: '사용 모드는 허용되는 작업을 정의합니다: B=암호화/복호화, C=생성/검증, D=복호화만, E=암호화만, G=생성만, N=제한 없음, X=키 유도.' },
        { question: '내보내기 가능성이란?', answer: '내보내기 가능성은 키 내보내기를 제어합니다: E=신뢰할 수 있는 키 블록에서 내보내기 가능, N=내보내기 불가, S=민감(제한적 내보내기).' },
      ],
      usage: [
        '인코딩: KBPK(3DES 또는 AES), 평문 키를 입력하고 버전, 키 용도, 알고리즘, 사용 모드, 내보내기 가능성을 선택한 후 인코드를 클릭합니다.',
        '인코딩된 키 블록에는 헤더 메타데이터 + 암호화된 키 + 무결성용 MAC가 포함됩니다.',
        '디코딩: KBPK를 입력하고 키 블록 데이터를 붙여넣은 후 디코드를 클릭합니다.',
        '디코드 결과에는 모든 헤더 필드(버전, 길이, 키 용도, 알고리즘, 사용 모드, 키 버전, 내보내기 가능성, 선택적 블록 수), 암호화된 데이터, MAC, 복호화된 키, KCV가 표시됩니다.',
      ],
    },
    kcv: {
      title: 'KCV 계산기 온라인 - 키 체크 값 생성기 | HSM Kit',
      description: 'AES 및 DES/3DES 키용 무료 온라인 KCV(키 체크 값) 계산기. 체크 값을 계산하여 암호화 키의 정확성을 검증합니다. DES 키의 자동 패리티 조정 지원. 결제 보안 및 키 검증에 필수.',
      keywords: 'KCV 계산기, 키 체크 값, KCV 생성기, AES KCV, DES KCV, 3DES KCV, CMAC, 키 검증, 결제 키, 키 체크 값 계산기, HSM 키 검증',
      faqTitle: 'KCV 계산기 FAQ',
      usageTitle: 'KCV 계산기 사용 방법',
      faqs: [
        { question: 'KCV(키 체크 값)란 무엇인가요?', answer: 'KCV는 암호화 키가 올바르게 입력되거나 전송되었는지 확인하는 데 사용되는 체크섬입니다. 0의 블록을 암호화하고 결과의 처음 3바이트를 취하여 계산됩니다.' },
        { question: 'DES/3DES의 KCV는 어떻게 계산되나요?', answer: 'DES/3DES의 경우: ECB 모드로 8바이트 0(0x0000000000000000)을 암호화한 다음 암호문의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: 'AES의 KCV는 어떻게 계산되나요?', answer: 'AES의 경우: 키를 사용하여 16바이트 0에 대해 CMAC를 계산한 다음 MAC 값의 처음 6개 16진수 문자(3바이트)를 취합니다.' },
        { question: '자동 패리티 조정이란?', answer: 'DES 키는 각 바이트에 홀수 패리티가 필요합니다. 키에 올바른 패리티가 없으면 자동 조정을 활성화하여 KCV 계산 전에 수정할 수 있습니다.' },
      ],
      usage: [
        '알고리즘(AES 또는 DES/3DES)을 선택합니다.',
        '암호화 키를 16진수 형식으로 입력합니다.',
        'DES 키의 경우 선택적으로 자동 패리티 조정을 활성화합니다.',
        '"KCV 계산"을 클릭하여 키 체크 값을 생성합니다.',
        'KCV를 예상 값과 비교하여 키의 정확성을 검증합니다.',
      ],
    },
    pinBlock: {
      title: 'PIN 블록 생성기 온라인 - ISO 9564 형식 0/1/3/4 | HSM Kit',
      description: 'ISO 9564 형식(형식 0, 1, 3, 4)을 지원하는 무료 온라인 PIN 블록 생성기. 결제 거래, ATM, POS 시스템용 PIN 블록 생성. 결제 보안 테스트에 필수적인 도구. 100% 클라이언트 측 처리.',
      keywords: 'PIN 블록, ISO 9564, PIN 블록 형식 0, PIN 블록 형식 4, 결제 보안, ATM PIN, POS PIN, PIN 암호화, 카드 PIN, PIN 블록 생성기, 결제 카드 보안',
      faqTitle: 'PIN 블록 FAQ',
      usageTitle: 'PIN 블록 생성기 사용 방법',
      faqs: [
        { question: 'PIN 블록이란 무엇인가요?', answer: 'PIN 블록은 암호화 전에 PIN(개인 식별 번호)을 인코딩하기 위한 표준화된 형식입니다. PIN을 채우기 패턴 또는 PAN 데이터와 결합하여 암호화용 고정 길이 블록을 만듭니다.' },
        { question: '형식 0(ISO 9564-1)이란?', answer: '형식 0은 PIN 블록을 PAN의 오른쪽 12자리(체크 디지트 제외)와 XOR합니다. 결제 시스템에서 가장 널리 사용되는 형식입니다.' },
        { question: '형식 4(ISO 9564-1:2017)란?', answer: '형식 4는 AES 암호화를 위해 설계된 최신 형식입니다. 랜덤 패딩을 포함하며 이전 형식보다 더 나은 보안을 제공합니다.' },
        { question: 'PIN 블록에 PAN이 필요한 이유는?', answer: '형식 0 및 일부 형식에서 PAN은 PIN 데이터와 XOR되어 PIN을 특정 카드에 바인딩하고 특정 공격을 방지합니다.' },
      ],
      usage: [
        'PIN 블록 형식(0, 1, 3 또는 4)을 선택합니다.',
        'PIN(4-12자리)을 입력합니다.',
        'PAN이 필요한 형식의 경우 카드 번호를 입력합니다.',
        '"생성"을 클릭하여 PIN 블록을 만듭니다.',
        '생성된 16진수 문자열을 암호화 프로세스의 입력으로 사용합니다.',
      ],
    },
    hash: {
      title: '해시 계산기 온라인 - MD5, SHA-256, SHA-512, BLAKE2 | HSM Kit',
      description: 'MD5, SHA-1, SHA-256, SHA-512, RIPEMD-160, WHIRLPOOL, BLAKE2, CRC32 등을 지원하는 무료 온라인 해시 계산기. 텍스트 또는 16진수 입력에서 해시 값 계산. 20개 이상의 해시 알고리즘 지원. 모든 처리는 브라우저에서 실행.',
      keywords: '해시 계산기, MD5 해시, SHA-256 해시, SHA-512 해시, BLAKE2, RIPEMD-160, WHIRLPOOL, CRC32, 해시 생성기, 체크섬 계산기, 메시지 다이제스트, 암호학적 해시',
      faqTitle: '해시 계산기 FAQ',
      usageTitle: '해시 계산기 사용 방법',
      faqs: [
        { question: '해시 함수란?', answer: '해시 함수는 임의 크기의 입력 데이터를 고정 크기 출력(해시 값)으로 변환하는 수학적 알고리즘입니다.' },
        { question: '어떤 해시 알고리즘을 사용해야 하나요?', answer: '보안 목적으로 SHA-256 또는 SHA-512를 사용하세요. MD5와 SHA-1은 암호화 용도로 안전하지 않습니다.' },
        { question: 'MD5와 SHA-256의 차이점은?', answer: 'MD5는 128비트 해시를 생성하며 빠르지만 암호학적으로 깨졌습니다. SHA-256은 256비트 해시를 생성하며 현재 암호학적으로 안전합니다. 보안 중심 애플리케이션에는 SHA-256을 사용하세요.' },
        { question: '해시를 복호화할 수 있나요?', answer: '아니요, 해시 함수는 설계상 단방향 함수입니다. 해시에서 원래 입력을 복구할 수 없습니다. 이 특성 때문에 비밀번호 저장 및 데이터 무결성 검증에 유용합니다.' },
      ],
      usage: ['입력 유형 선택', '알고리즘 선택', '데이터 입력', '"계산" 클릭'],
    },
    encoding: {
      title: '문자 인코딩 변환기 온라인 - ASCII, EBCDIC, Hex | HSM Kit',
      description: '무료 온라인 문자 인코딩 변환기. ASCII, EBCDIC, 16진수, 바이너리, ATM 10진수 형식 간 변환. 결제 시스템 개발 및 메인프레임 통합에 필수. 100% 클라이언트 측 변환.',
      keywords: '문자 인코딩, ASCII EBCDIC 변환, 16진수 변환기, 바이너리 변환기, EBCDIC 변환기, ATM 10진수, 인코딩 변환, 결제 시스템 인코딩, 은행 인코딩',
      faqTitle: '문자 인코딩 FAQ',
      usageTitle: '인코딩 변환기 사용 방법',
      faqs: [
        { question: '문자 인코딩이란?', answer: '문자 인코딩은 각 문자를 고유한 숫자나 바이트 시퀀스와 연결하는 시스템입니다.' },
        { question: 'EBCDIC란?', answer: 'EBCDIC는 주로 IBM 메인프레임에서 사용되는 8비트 문자 인코딩입니다.' },
        { question: 'ASCII와 EBCDIC 변환이 필요한 이유는?', answer: '많은 레거시 은행 및 금융 시스템이 EBCDIC를 사용하는 IBM 메인프레임에서 실행됩니다. 모던 시스템(ASCII/UTF-8 사용)과 이러한 메인프레임 통합 시 문자 변환이 필수적입니다.' },
        { question: 'ATM 10진 인코딩이란?', answer: 'ATM 10진은 ATM 통신에서 사용되는 특정 인코딩으로, 각 숫자(0-9)가 ASCII 코드로 표현됩니다. 금융 메시징 프로토콜에서 일반적으로 사용됩니다.' },
      ],
      usage: ['변환 유형 선택', '데이터 입력', '"변환" 클릭'],
    },
    bcd: {
      title: 'BCD 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 BCD 인코더 및 디코더. 10진수를 BCD로 변환하거나 BCD를 10진수로 변환. 금융 및 임베디드 시스템에서 사용. 결제 터미널 통합에 최적.',
      keywords: 'BCD 인코더, BCD 디코더, 이진화 10진수, 10진수 BCD 변환, 금융 인코딩, 결제 시스템 인코딩',
      faqTitle: 'BCD FAQ',
      usageTitle: 'BCD 도구 사용 방법',
      faqs: [
        { question: 'BCD란?', answer: '이진화 10진수(BCD)는 각 10진수를 4비트로 표현하는 인코딩입니다.' },
        { question: 'BCD를 사용하는 이유는?', answer: 'BCD는 정확한 10진 표현이 중요한 금융 애플리케이션에서 사용됩니다.' },
        { question: '팩드 BCD와 언팩드 BCD의 차이점은?', answer: '팩드 BCD는 1바이트에 2개의 10진수를 저장합니다(각 4비트). 언팩드 BCD는 각 10진수가 1바이트 전체를 차지합니다. 팩드 BCD가 공간 효율이 더 높습니다.' },
        { question: 'BCD는 어디서 일반적으로 사용되나요?', answer: 'BCD는 금융 시스템, 계산기, 디지털 시계 및 10진 정밀도가 중요한 애플리케이션에서 널리 사용됩니다. 결제 단말기와 ATM은 금액 표시에 BCD를 자주 사용합니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    checkDigits: {
      title: '체크 디지트 계산기 온라인 - Luhn MOD 10, MOD 9 | HSM Kit',
      description: '무료 온라인 체크 디지트 계산기 및 검증기. Luhn(MOD 10) 및 MOD 9로 체크 디지트 생성 또는 검증. 신용카드 번호, IMEI, 기타 식별자 검증. 결제 검증에 필수.',
      keywords: '체크 디지트 계산기, Luhn 알고리즘, MOD 10, MOD 9, 신용카드 검증, IMEI 체크, 체크섬 계산기, Luhn 체크, 카드 번호 검증, 식별자 검증',
      faqTitle: '체크 디지트 FAQ',
      usageTitle: '체크 디지트 계산기 사용 방법',
      faqs: [
        { question: '체크 디지트란?', answer: '체크 디지트는 오류 검출을 위해 숫자에 추가되는 숫자입니다.' },
        { question: 'Luhn 알고리즘이란?', answer: 'Luhn 알고리즘(MOD 10)은 신용카드 번호 등을 검증하는 체크섬 공식입니다.' },
        { question: '어떤 번호가 Luhn 알고리즘을 사용하나요?', answer: '신용카드 번호(Visa, MasterCard, Amex), IMEI 번호, NPI(의료 제공자 식별자), 캐나다 사회보험번호 등 많은 식별 번호가 Luhn 검증을 사용합니다.' },
        { question: 'Amex SE MOD 9 알고리즘이란?', answer: 'Amex SE(서비스 시설) MOD 9 알고리즘은 American Express가 가맹점/서비스 시설 번호를 검증하는 데 사용합니다. Luhn과 다른 계산 방법을 사용합니다.' },
      ],
      usage: ['알고리즘 선택', '검증 또는 생성 선택', '숫자 입력'],
    },
    base64: {
      title: 'Base64 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 Base64 인코더 및 디코더. 텍스트를 Base64로 변환하거나 Base64를 텍스트로 변환. 웹 애플리케이션 데이터 인코딩에 필수. 빠르고 안전한 브라우저 처리.',
      keywords: 'Base64 인코더, Base64 디코더, Base64 변환, 바이너리 텍스트 변환, Base64 변환기, MIME 인코딩',
      faqTitle: 'Base64 FAQ',
      usageTitle: 'Base64 도구 사용 방법',
      faqs: [
        { question: 'Base64란?', answer: 'Base64는 64문자를 사용하여 바이너리 데이터를 ASCII 문자열로 변환하는 인코딩입니다.' },
        { question: 'Base64를 사용하는 이유는?', answer: 'Base64는 텍스트 기반 프로토콜에서 바이너리 데이터를 전송하는 데 사용됩니다.' },
        { question: 'Base64는 암호화를 제공하나요?', answer: '아니요, Base64는 인코딩 체계이지 암호화가 아닙니다. 누구나 Base64 데이터를 디코딩할 수 있습니다. 데이터 표현용이며 보안용이 아닙니다.' },
        { question: 'Base64가 데이터 크기를 증가시키는 이유는?', answer: 'Base64는 3바이트의 바이너리 데이터를 4개의 ASCII 문자로 인코딩하여 약 33% 크기 증가가 발생합니다. 입력 길이가 3으로 나누어지지 않으면 패딩 문자 "="가 사용됩니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    base94: {
      title: 'Base94 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 Base94 인코더 및 디코더. 94개의 출력 가능한 ASCII 문자를 사용한 컴팩트 인코딩. Base64보다 약 20% 더 컴팩트. 효율적인 데이터 저장 및 전송에 유용.',
      keywords: 'Base94 인코더, Base94 디코더, 컴팩트 인코딩, 효율적인 인코딩, URL 안전 인코딩',
      faqTitle: 'Base94 FAQ',
      usageTitle: 'Base94 도구 사용 방법',
      faqs: [
        { question: 'Base94란?', answer: 'Base94는 94개의 출력 가능한 ASCII 문자를 사용하는 인코딩으로 Base64보다 효율적입니다.' },
        { question: 'Base94를 사용하는 이유는?', answer: 'Base94는 Base64보다 약 20% 더 컴팩트한 인코딩을 제공합니다.' },
        { question: 'Base94는 어떤 문자를 사용하나요?', answer: 'Base94는 !(0x21)부터 ~(0x7E)까지의 94개 출력 가능 ASCII 문자를 사용하며, 공백은 제외됩니다. 문자, 숫자, 모든 표준 구두점이 포함됩니다.' },
        { question: '언제 Base94를 사용해야 하나요?', answer: '바이너리 데이터의 컴팩트한 텍스트 표현이 필요하고, 전송/저장 시스템이 모든 출력 가능 ASCII 문자를 지원하는 경우 Base94를 사용합니다. URL, QR 코드, 저장 최적화에 적합합니다.' },
      ],
      usage: ['인코드 또는 디코드 선택', '데이터 입력', '버튼 클릭'],
    },
    messageParser: {
      title: '메시지 파서 온라인 - ATM NDC, Wincor, ISO 8583 | HSM Kit',
      description: '무료 온라인 ATM 및 금융 메시지 파서. ATM NDC, Wincor, ISO 8583 메시지 형식 구문 분석. 결제 시스템 개발 및 디버깅에 필수. 모든 파싱은 브라우저에서 실행.',
      keywords: '메시지 파서, ATM NDC, ATM Wincor, ISO 8583, 금융 메시지, 거래 파서, 16진수 파서, ATM 메시지 디코더, 결제 메시지 파서, 금융 거래 파서',
      faqTitle: '메시지 파서 FAQ',
      usageTitle: '메시지 파서 사용 방법',
      faqs: [
        { question: 'ATM NDC란?', answer: 'NDC(NCR Direct Connect)는 NCR ATM이 호스트 시스템과 통신하는 프로토콜입니다.' },
        { question: 'ISO 8583이란?', answer: 'ISO 8583은 금융 거래 메시지의 국제 표준입니다.' },
        { question: 'Wincor/Nixdorf 프로토콜이란?', answer: 'Wincor Nixdorf(현 Diebold Nixdorf) 프로토콜은 NDC와 유사하지만 벤더 고유 변형이 있는 독점 ATM 통신 프로토콜입니다. 유럽과 아시아 시장에서 널리 사용됩니다.' },
        { question: '메시지 형식을 어떻게 식별하나요?', answer: 'NDC 메시지는 일반적으로 특정 메시지 클래스 식별자로 시작합니다. ISO 8583 메시지는 4자리 MTI(메시지 유형 식별자)로 시작합니다. 16진 덤프 구조가 사용 중인 프로토콜을 식별하는 데 도움이 됩니다.' },
      ],
      usage: ['메시지 형식 선택', '16진수 데이터 입력', '"구문 분석" 클릭'],
    },
    rsaDer: {
      title: 'RSA DER 공개키 인코더/디코더 온라인 | HSM Kit',
      description: '무료 온라인 RSA DER 공개키 인코더 및 디코더. 모듈러스/지수와 DER ASN.1 형식 간 변환. PEM 출력 및 다양한 입력 인코딩(ASCII Hex, Base64, EBCDIC) 지원. 100% 브라우저 처리.',
      keywords: 'RSA DER, RSA 공개키, DER 인코딩, ASN.1, PEM 형식, 모듈러스, 지수, RSA 키 변환기, 공개키 인코더, RSA 키 파서, 인증서 키 추출기',
      faqTitle: 'RSA DER 공개키 FAQ',
      usageTitle: 'RSA DER 도구 사용 방법',
      faqs: [
        { question: 'DER 인코딩이란?', answer: 'DER(Distinguished Encoding Rules)은 ASN.1 데이터 구조를 인코딩하는 바이너리 형식입니다.' },
        { question: 'PEM 형식이란?', answer: 'PEM은 헤더/푸터 줄이 있는 DER의 Base64 인코딩 버전입니다.' },
        { question: 'RSA의 모듈러스와 지수란?', answer: '모듈러스(n)는 두 큰 소수의 곱으로 키 크기를 결정합니다. 공개 지수(e)는 일반적으로 65537(0x10001)입니다. 이 둘이 함께 공개키를 구성합니다.' },
        { question: '인증서에서 모듈러스를 어떻게 추출하나요?', answer: '이 도구를 사용하여 DER/PEM 인코딩된 공개키를 디코딩하세요. 파서가 모듈러스와 지수를 다양한 형식(16진수, 10진수, Base64)으로 추출하여 표시합니다.' },
      ],
      usage: ['인코드: 모듈러스와 지수 입력', '디코드: DER 또는 PEM 데이터 붙여넣기'],
    },
    futurexKeys: {
      title: 'Futurex 키 암호화/복호화 온라인 - HSM 키 변형 도구 | HSM Kit',
      description: '무료 온라인 Futurex HSM 키 암호화/복호화 도구. MFK(마스터 파일 키)와 수정자 변형(0-F, 1A-1F)을 사용하여 키를 암호화/복호화. Futurex, IBM, Atalla, VISA 키 변형 방식 지원. 키 조회 기능으로 KCV 매칭을 통해 올바른 수정자를 찾습니다. 100% 클라이언트 측 처리.',
      keywords: 'Futurex HSM, 키 암호화, 키 복호화, MFK, 마스터 파일 키, 키 변형, 수정자, HSM 도구, 결제 보안, 키 관리, IBM HSM, Atalla HSM, VISA PVK, KCV 검증, 3DES 암호화, 키 조회, HSM 키 관리',
      faqTitle: 'Futurex 키 FAQ',
      usageTitle: 'Futurex 키 도구 사용 방법',
      faqs: [
        { question: 'Futurex 키 암호화란?', answer: 'Futurex HSM은 특정 키 암호화 방법을 사용하며, 키는 마스터 파일 키(MFK)의 변형과 수정자(0-F, 1A-1F)를 조합하여 암호화됩니다. 변형 키는 MFK를 수정자 바이트와 XOR하여 생성됩니다.' },
        { question: '수정자란?', answer: '수정자(0-F, 1A-1F)는 MFK에서 다른 키 변형을 생성하는 데 사용됩니다. 각 수정자는 PIN 키, MAC 키, 데이터 암호화 키 등 다른 용도를 위한 고유한 암호화 키를 생성합니다.' },
        { question: 'MFK(마스터 파일 키)란?', answer: 'MFK는 Futurex HSM에서 사용되는 기본 마스터 키입니다. 일반적으로 트리플 길이 3DES 키(48자 16진수)입니다. MFK는 수정자와 결합하여 다른 키를 암호화/복호화하기 위한 변형 키를 생성합니다.' },
        { question: '키 조회란?', answer: '키 조회는 암호화된 키를 복호화하기 위해 모든 수정자(0-F, 1A-1F)를 시도합니다. KCV(키 체크 값)와 패리티 유형(홀수/짝수)으로 결과를 필터링하여 암호화에 사용된 정확한 수정자를 찾을 수 있습니다.' },
        { question: '다른 HSM 유형의 차이점은?', answer: '다른 HSM 벤더는 다른 키 변형 방식을 사용합니다: Futurex는 전체 바이트 XOR, IBM은 위치별 XOR, Atalla는 AKB 방식, VISA는 처음 8바이트만 PVK 방식을 사용합니다.' },
        { question: 'KCV란 무엇이며 어떻게 사용하나요?', answer: 'KCV(키 체크 값)는 키로 0을 암호화하여 계산됩니다. 키 조회에서 예상 KCV를 입력하여 결과를 필터링하고 해당 특정 KCV를 생성하는 수정자를 찾을 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 16진수 평문 키를 입력하고 수정자와 MFK를 선택한 후 암호화 클릭.',
        '키 복호화: 16진수 암호화 키를 입력하고 수정자와 MFK를 선택한 후 복호화 클릭.',
        '결과 표시: 입력 키, 감지된 패리티, 사용된 MFK, 수정자, 출력 키, KCV.',
        '키 조회: 암호화 키를 입력하고 선택적으로 KCV 필터와 패리티 필터를 설정.',
        'HSM 유형(임의/Futurex/IBM/Atalla/VISA)을 선택하고 조회를 클릭하여 모든 수정자 시도.',
        '결과는 수정자, 복호화 키, KCV, 패리티를 포함한 모든 일치하는 복호화를 표시.',
      ],
    },
    atallaKeys: {
      title: 'Atalla 키 (AKB) 온라인 - HSM 키 암호화/복호화 도구 | HSM Kit',
      description: '무료 온라인 Atalla HSM 키 암호화/복호화 도구. AKB(Atalla Key Block) 형식을 사용하여 키를 암호화/복호화. MFK와 AKB 헤더를 사용한 안전한 키 관리. KCV 검증 및 패리티 체크 지원. 모든 처리는 브라우저에서 실행.',
      keywords: 'Atalla HSM, AKB, Atalla Key Block, 키 암호화, 키 복호화, MFK, HSM 도구, 결제 보안, 키 관리, KCV 검증, 3DES 암호화, Atalla 키 관리',
      faqTitle: 'Atalla 키 FAQ',
      usageTitle: 'Atalla 키 도구 사용 방법',
      faqs: [
        { question: 'AKB(Atalla Key Block)란?', answer: 'AKB는 Atalla HSM에서 사용되는 키 블록 형식입니다. 8자 헤더(예: 1PUNE000)와 암호화된 키 데이터로 구성됩니다. 헤더는 키 변형을 정의합니다.' },
        { question: 'AKB 헤더란?', answer: 'AKB 헤더는 8자 접두사로, 암호화에 사용되는 키 변형을 정의합니다. 일반적인 예로 1PUNE000이 있으며, 다른 헤더는 다른 키 유형이나 용도를 나타냅니다.' },
        { question: 'MFK(마스터 파일 키)란?', answer: 'MFK는 Atalla HSM에서 사용되는 기본 마스터 키입니다. 트리플 길이 3DES 키(48자 16진수)이며, AKB 헤더와 결합하여 키 암호화/복호화를 위한 변형 키를 생성합니다.' },
        { question: 'AKB 암호화는 어떻게 작동하나요?', answer: 'AKB 헤더가 ASCII 값으로 변환되고 MFK와 XOR되어 변형 키를 생성합니다. 이 변형 키로 3DES ECB 모드를 사용하여 대상 키를 암호화하고, 헤더와 암호문으로 AKB를 형성합니다.' },
        { question: 'KCV 체크란?', answer: 'KCV(Key Check Value)는 복호화된 키의 검증에 사용됩니다. 복호화 시 KCV를 입력하면 계산된 KCV와 비교하여 올바른 MFK와 AKB 형식을 확인할 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 16진수 키를 입력하고, AKB 헤더(기본값: 1PUNE000)를 설정, MFK를 입력한 후 암호화 클릭.',
        '결과 표시: 평문 키, AKB 헤더, 생성된 AKB, KCV.',
        'AKB 복호화: AKB(예: 1PUNE000,암호화데이터)를 입력, MFK를 입력한 후 복호화 클릭.',
        '선택적으로 KCV 체크를 활성화하여 예상 KCV 입력, 패리티 필터 설정.',
        '결과 표시: AKB, 헤더, 복호화 키, KCV, 패리티.',
      ],
    },
    safenetKeys: {
      title: 'SafeNet 키 암호화/복호화 온라인 - HSM 키 변형 도구 | HSM Kit',
      description: '무료 온라인 SafeNet HSM 키 암호화/복호화 도구. KM 키와 키 형식 및 변형 옵션을 사용하여 키를 암호화/복호화. DPK, PPK, MPK, KPK 변형 지원. 키 조회로 KCV 매칭을 통해 올바른 변형을 찾습니다. 안전한 브라우저 처리.',
      keywords: 'SafeNet HSM, 키 암호화, 키 복호화, KM 키, 키 변형, DPK, PPK, MPK, KPK, HSM 도구, 결제 보안, 키 관리, KCV 검증, 3DES 암호화, 키 조회, SafeNet 키 관리',
      faqTitle: 'SafeNet 키 FAQ',
      usageTitle: 'SafeNet 키 도구 사용 방법',
      faqs: [
        { question: 'SafeNet 키 암호화란?', answer: 'SafeNet HSM은 특정 키 암호화 방법을 사용하며, 키는 키 관리 키(KM Key)의 변형을 사용하여 암호화됩니다. 변형은 키 용도 유형(DPK, PPK, MPK 등)에 의해 결정됩니다.' },
        { question: '키 형식이란?', answer: '키 형식은 암호화 방법과 키 길이를 정의: 00=평문, 10/20=싱글 DES, 11/21=더블 DES3, 12/22=트리플 DES3. 형식 1x는 ECB 모드, 2x는 CBC 모드 사용.' },
        { question: '변형이란?', answer: '변형은 키 용도를 결정: 00=DPK(데이터 보호), 01=PPK(PIN 보호), 02=MPK(MAC 보호), 03=KPK(키 보호), 04=KTK(키 전송), 05=KEK(키 암호화). 각 변형은 KM 키와 특정 마스크를 XOR합니다.' },
        { question: 'KM 키란?', answer: 'KM 키(키 관리 키)는 SafeNet HSM에서 사용되는 마스터 키입니다. 일반적으로 더블 길이 3DES 키(32자 16진수)입니다. KM 키는 변형 마스크와 XOR되어 암호화 키를 생성합니다.' },
        { question: '키 조회란?', answer: '키 조회는 모든 변형(DPK, PPK, MPK 등)을 시도하여 암호화 키를 복호화합니다. KCV와 패리티로 결과를 필터링하여 암호화에 사용된 정확한 변형을 찾을 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 평문 키를 입력하고 키 형식과 변형을 선택, KM 키를 입력하고 암호화 클릭.',
        '키 복호화: 암호화 키를 입력하고 키 형식과 변형을 선택, KM 키를 입력하고 복호화 클릭.',
        '결과 표시: 평문/암호화 키, KCV, 패리티, 키 형식, 변형, 변형 키, 출력.',
        '키 조회: 암호화 키를 입력하고 선택적으로 KCV 필터와 패리티 필터를 설정.',
        'KM 키를 입력하고 조회를 클릭하여 모든 변형을 시도하고 일치하는 복호화를 검색.',
        '결과는 복호화 키, KCV, 패리티와 함께 모든 일치하는 변형을 표시.',
      ],
    },
    thalesKeys: {
      title: 'Thales 키 (LMK) 온라인 - HSM 키 암호화/복호화 도구 | HSM Kit',
      description: '무료 온라인 Thales HSM 키 암호화/복호화 도구. LMK(로컬 마스터 키)와 키 스킴 및 변형 옵션을 사용하여 키를 암호화/복호화. 다양한 LMK 쌍과 변형 마스크 지원. 키 조회로 일치하는 복호화를 검색. 100% 클라이언트 측 처리.',
      keywords: 'Thales HSM, LMK, 로컬 마스터 키, 키 암호화, 키 복호화, 키 스킴, 키 변형, LMK 쌍, HSM 도구, 결제 보안, 키 관리, KCV 검증, 3DES 암호화, 키 조회, Thales 키 관리',
      faqTitle: 'Thales 키 (LMK) FAQ',
      usageTitle: 'Thales 키 도구 사용 방법',
      faqs: [
        { question: 'Thales 키 암호화란?', answer: 'Thales HSM은 LMK(로컬 마스터 키) 기반 암호화를 사용하며, 키는 LMK 쌍의 변형을 사용하여 암호화됩니다. 변형은 LMK에 적용되는 XOR 마스크에 의해 결정됩니다.' },
        { question: '키 스킴이란?', answer: '키 스킴은 키 길이와 형식을 정의: 0=평문, U=싱글 길이 ECB, T=더블 길이 ECB, X=트리플 길이 ECB, Y=더블 길이 변형, Z=트리플 길이 변형. 스킴 접두사가 암호화 키에 추가됩니다.' },
        { question: 'LMK 쌍이란?', answer: 'LMK 쌍은 다른 목적으로 사용되는 마스터 키 쌍: 00-01은 ZMK/ZPK/TMK/TPK용, 02-03은 PVK/CVK/BDK용, 04-05는 TAK용, 14-15는 ZEK/DEK용 등. 각 쌍은 특정 유형의 키를 암호화합니다.' },
        { question: '변형이란?', answer: '변형(0-8)은 LMK에 적용되는 XOR 마스크를 결정: 0=변형 없음, 1=A6, 2=5A, 3=6A, 4=DE, 5=2B, 6=50, 7=74, 8=9C. 마스크는 LMK의 각 8바이트 블록과 XOR됩니다.' },
        { question: 'LMK 크기란?', answer: 'LMK 크기는 LMK의 길이를 결정: 더블(16바이트/32자 16진수) 또는 트리플(24바이트/48자 16진수). 대부분의 Thales HSM은 3DES 암호화를 위해 트리플 길이로 확장된 더블 길이 LMK를 사용합니다.' },
        { question: '키 조회란?', answer: '키 조회는 모든 변형을 시도하여 암호화 키를 복호화합니다. KCV(키 체크 값)와 패리티 유형(홀수/짝수)으로 결과를 필터링하여 암호화에 사용된 정확한 변형을 찾을 수 있습니다.' },
      ],
      usage: [
        '키 암호화: 평문 키를 입력하고 키 스킴, LMK 크기, LMK 쌍을 선택, LMK 키를 입력, 변형을 선택하고 암호화 클릭.',
        '키 복호화: 암호화 키(스킴 접두사 유무)를 입력, LMK 설정을 구성하고 복호화 클릭.',
        '결과 표시: 평문/암호화 키, KCV, 패리티, 키 스킴, LMK 쌍, 변형, 출력.',
        '키 조회: 암호화 키를 입력하고 선택적으로 KCV 필터와 패리티 필터를 설정.',
        '조회를 클릭하여 모든 변형을 시도하고 일치하는 복호화를 검색.',
        '결과는 복호화 키, KCV, 패리티와 함께 모든 일치하는 변형을 표시.',
      ],
    },
    thalesKeyBlock: {
      title: 'Thales 키 블록 온라인 - 전용 키 블록 인코딩/디코딩 | HSM Kit',
      description: '무료 온라인 Thales 키 블록 인코더 및 디코더. KBPK(키 블록 보호 키)를 사용하여 Thales 전용 키 블록을 인코딩/디코딩. 3DES/AES KBPK, 다양한 키 용도, 알고리즘, 내보내기 가능성 옵션 지원. 모든 처리는 브라우저에서 실행.',
      keywords: 'Thales 키 블록, KBPK, 키 블록 보호 키, 키 블록 인코더, 키 블록 디코더, HSM 도구, 결제 보안, 키 관리, 3DES, AES, 키 용도, 내보내기 가능성, Thales 키 블록 형식',
      faqTitle: 'Thales 키 블록 FAQ',
      usageTitle: 'Thales 키 블록 도구 사용 방법',
      faqs: [
        { question: 'Thales 키 블록이란?', answer: 'Thales 키 블록은 Thales HSM이 사용하는 전용 키 블록 형식으로, 암호화 키를 안전하게 래핑하고 전송합니다. 용도, 알고리즘, 내보내기 가능성과 같은 메타데이터를 포함합니다.' },
        { question: 'KBPK란?', answer: 'KBPK(키 블록 보호 키)는 키 블록을 암호화/복호화하는 마스터 키입니다. 3DES KBPK는 24바이트(48자 16진수), AES KBPK는 32바이트(64자 16진수)입니다.' },
        { question: '키 용도란?', answer: '키 용도(2자)는 래핑된 키의 사용 방법을 정의: B0=BDK, C0=CVK, D0=데이터 암호화, K0=키 암호화, M0-M8=MAC 키, P0=PIN 암호화 등.' },
        { question: '알고리즘이란?', answer: '알고리즘(1자)은 암호화 알고리즘을 지정: A=AES, D=DES, T=트리플 DES, R=RSA, E=타원 곡선, H=HMAC.' },
        { question: '사용 모드란?', answer: '사용 모드는 허용되는 작업을 정의: B=암호화/복호화, C=생성/검증, D=복호화만, E=암호화만, G=생성만, N=제한 없음, X=키 파생.' },
        { question: '내보내기 가능성이란?', answer: '내보내기 가능성은 키 내보내기를 제어: E=신뢰할 수 있는 키 블록에서 내보내기 가능, N=내보내기 불가, S=민감(제한된 내보내기).' },
      ],
      usage: [
        '인코딩: KBPK(3DES 또는 AES), 평문 키를 입력하고 버전, 키 용도, 알고리즘, 사용 모드, 내보내기 가능성을 선택하고 인코딩 클릭.',
        '인코딩된 키 블록에는 헤더 메타데이터 + 암호화 키 + 무결성을 위한 MAC이 포함됩니다.',
        '디코딩: KBPK를 입력하고 키 블록 데이터를 붙여넣기, ASCII 또는 16진수 형식을 선택하고 디코딩 클릭.',
        '디코딩 결과는 모든 헤더 필드, 복호화 키, KCV, MAC을 표시.',
      ],
    },
    uuid: {
      title: 'UUID 생성기 온라인 - 버전 1, 3, 4, 5 | HSM Kit',
      description: '무료 온라인 UUID 생성기. 버전 1(시간 기반), 3(MD5), 4(랜덤), 5(SHA-1) 지원. 애플리케이션용 단일 또는 배치 UUID 생성. 암호학적으로 안전한 난수 생성.',
      keywords: 'UUID 생성기, GUID 생성기, UUID v4, UUID v1, 랜덤 UUID, 고유 식별자, UUID 온라인, 배치 UUID 생성기, 고유 ID 생성기, GUID 생성기 온라인',
      faqTitle: 'UUID 생성기 FAQ',
      usageTitle: 'UUID 생성기 사용 방법',
      faqs: [
        { question: 'UUID란?', answer: 'UUID(범용 고유 식별자)는 시간과 공간에서 고유한 128비트 식별자입니다.' },
        { question: '어떤 UUID 버전을 사용해야 하나요?', answer: '버전 4(랜덤)가 가장 일반적이고 권장됩니다.' },
        { question: 'UUID와 GUID의 차이점은?', answer: 'UUID와 GUID(전역 고유 식별자)는 동일합니다. GUID는 Microsoft의 용어이고, UUID는 표준(RFC 4122)의 용어입니다. 동일한 형식, 동일한 목적입니다.' },
        { question: 'UUID는 정말 고유한가요?', answer: 'UUID v4의 충돌 확률은 약 2^122분의 1로, 10억 개를 생성해도 중복 확률이 극히 낮습니다. 실용적으로 고유하다고 봐도 안전합니다.' },
      ],
      usage: ['UUID 버전 선택', '생성 개수 입력', '"생성" 클릭'],
    },
    sslCert: {
      title: 'SSL 인증서 (X509) - 키 생성, CSR, 자체 서명 인증서 | HSM Kit',
      description: '무료 온라인 SSL 인증서 도구. 암호화된 개인 키로 RSA 키 쌍 생성, 인증서 서명 요청(CSR) 생성, 자체 서명 X.509 인증서 생성, 인증서 분석. 모든 처리는 브라우저에서 클라이언트 측으로 수행. 100% 안전.',
      keywords: 'SSL 인증서, X509, CSR 생성기, 자체 서명 인증서, RSA 키 생성기, 인증서 파서, PEM, PKI 도구, 인증서 서명 요청, X.509 인증서, SSL 도구, 인증서 생성기, TLS 인증서, HTTPS 인증서',
      faqTitle: 'SSL 인증서 FAQ',
      usageTitle: 'SSL 인증서 도구 사용 방법',
      faqs: [
        { question: 'X.509 인증서란?', answer: 'X.509는 공개 키 인증서의 표준 형식으로, 보안 웹 연결을 위한 TLS/SSL, 이메일 서명(S/MIME), 코드 서명 및 기타 PKI 응용 프로그램에 사용됩니다.' },
        { question: 'CSR(인증서 서명 요청)이란?', answer: 'CSR은 인증서를 요청하기 위해 인증 기관(CA)에 보내는 메시지입니다. 인증서에 포함될 공개 키와 주체 정보(조직, 도메인 이름 등)를 포함합니다.' },
        { question: '자체 서명 인증서란?', answer: '자체 서명 인증서는 CA가 아닌 자체 개인 키로 서명된 인증서입니다. 테스트, 개발 또는 내부 사용에 유용하지만 신뢰할 수 있는 CA에서 확인되지 않았기 때문에 브라우저에서 경고를 표시합니다.' },
        { question: '왜 개인 키에 암호 문구가 필요한가요?', answer: '암호 문구는 3DES를 사용하여 개인 키를 암호화합니다. 파일이 손상된 경우에도 키를 보호합니다. 올바른 암호 문구 없이는 개인 키를 사용할 수 없습니다.' },
        { question: '어떤 키 길이를 사용해야 하나요?', answer: 'RSA 키의 경우 2048비트가 보안의 최소 권장 사항입니다. 4096비트는 더 강력한 보안을 제공하지만 더 느립니다. 3072비트는 보안과 성능 사이의 좋은 균형입니다.' },
      ],
      usage: [
        '키 탭: 암호화된 개인 키로 RSA 키 쌍 생성. 키 길이와 암호 문구 설정.',
        'CSR 탭: 인증서 서명 요청 생성. 개인 키를 붙여넣고 주체 세부 정보를 입력하여 CSR 생성.',
        'CSR 읽기 탭: 기존 CSR을 분석하여 주체 정보와 공개 키 표시.',
        '자체 서명 인증서 탭: 테스트용 자체 서명 인증서 생성. 유효 기간, 일련 번호, 주체 세부 정보 설정.',
        '인증서 읽기 탭: X.509 인증서를 분석하여 발급자, 주체, 유효 기간, 확장, 공개 키 표시.',
      ],
    },
  },
};
