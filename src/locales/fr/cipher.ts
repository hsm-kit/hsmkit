// French translations - Cipher tools
export default {
  cipher: {
    title: 'Chiffrement/Déchiffrement AES',
    description: 'Chiffrer et déchiffrer des données en utilisant l\'algorithme AES avec différents modes',
    algorithm: 'Algorithme',
    mode: 'Mode',
    dataInput: 'Entrée des Données',
    hexadecimal: 'Hexadécimal',
    key: 'Clé',
    data: 'Données',
    hexChars: 'caractères hex',
    dataPlaceholderHex: 'Entrez des données hexadécimales',
    dataPlaceholderAscii: 'Entrez du texte ASCII',
    encrypt: 'Chiffrer',
    decrypt: 'Déchiffrer',
    encryptResult: 'Résultat Chiffré',
    decryptResult: 'Résultat Déchiffré',
    aesInfo: 'Informations AES',
    keyLengthInfo: 'La longueur de la clé doit correspondre à l\'algorithme sélectionné',
    ivInfo: 'L\'IV (Vecteur d\'Initialisation) doit être de 16 octets',
    paddingInfo: 'Utilisation du remplissage PKCS7',
    errorInvalidKeyHex: 'La clé doit être un hexadécimal valide',
    errorKeyLength: 'La longueur de la clé doit être de {length} octets pour {algorithm}',
    errorDataRequired: 'Les données sont requises',
    errorInvalidDataHex: 'Les données doivent être un hexadécimal valide',
    errorInvalidIvHex: 'L\'IV doit être un hexadécimal valide',
    errorIvLength: 'La longueur de l\'IV doit être de {length} octets',
    errorEncryption: 'Le chiffrement a échoué',
    errorDecryption: 'Le déchiffrement a échoué',
    errorInvalidCiphertext: 'Le texte chiffré doit être un hexadécimal valide',
    ivNotRequired: 'L\'IV n\'est pas requis pour le mode ECB/KCV',
    kcvInfo: 'KCV : Chiffrer des zéros et prendre les 6 premiers caractères hex',
    calculateKcv: 'Calculer le KCV',
    noPaddingInfo: 'Pas de remplissage - la longueur des données doit être un multiple de 16 octets',
    errorDataLength: 'La longueur des données doit être un multiple de 16 octets',
    kcvNoDataNeeded: 'Aucune donnée nécessaire pour le calcul du KCV',
    kcvDataHint: 'Le KCV est calculé en utilisant des zéros, aucune entrée de données requise',
    errorKcvCalculation: 'Le calcul du KCV a échoué',
    kcvResult: 'Résultat KCV',
  },

  des: {
    title: 'Chiffrement/Déchiffrement DES / 3DES',
    description: 'Chiffrer et déchiffrer des données en utilisant l\'algorithme DES ou 3DES avec différents modes et remplissages',
    algorithm: 'Algorithme',
    mode: 'Mode',
    dataInput: 'Entrée des Données',
    hexadecimal: 'Hexadécimal',
    padding: 'Remplissage (Padding)',
    key: 'Clé',
    data: 'Données',
    hexChars: 'caractères hex',
    dataPlaceholderHex: 'Entrez des données hexadécimales',
    dataPlaceholderAscii: 'Entrez du texte ASCII',
    encrypt: 'Chiffrer',
    decrypt: 'Déchiffrer',
    encryptResult: 'Résultat Chiffré',
    decryptResult: 'Résultat Déchiffré',
    desInfo: 'Informations DES/3DES',
    keyLengthInfoDes: 'Le DES requiert une clé de 8 octets (64 bits)',
    keyLengthInfo3Des: 'Le 3DES requiert une clé de 16 ou 24 octets',
    ivInfo: 'L\'IV (Vecteur d\'Initialisation) doit être de 8 octets',
    blockSizeInfo: 'La taille du bloc est de 8 octets',
    errorInvalidKeyHex: 'La clé doit être un hexadécimal valide',
    errorKeyLengthDes: 'La longueur de la clé DES doit être de 8 octets',
    errorKeyLength3Des: 'La longueur de la clé 3DES doit être de 16 ou 24 octets',
    errorDataRequired: 'Les données sont requises',
    errorInvalidDataHex: 'Les données doivent être un hexadécimal valide',
    errorDataLength: 'La longueur des données doit être un multiple de 8 octets lors de l\'utilisation sans remplissage',
    errorInvalidIvHex: 'L\'IV doit être un hexadécimal valide',
    errorIvLength: 'La longueur de l\'IV doit être de {length} octets',
    errorEncryption: 'Le chiffrement a échoué',
    errorDecryption: 'Le déchiffrement a échoué',
    errorInvalidCiphertext: 'Le texte chiffré doit être un hexadécimal valide',
    ivNotRequired: 'L\'IV n\'est pas requis pour le mode ECB',
    paddingNone: 'Pas de remplissage',
    paddingZeros: 'Remplir avec 0x00',
    paddingSpaces: 'Remplir avec espace 0x20',
    paddingANSIX923: 'Le dernier octet est la longueur du remplissage, le reste rempli avec 0x00',
    paddingISO10126: 'Le dernier octet est la longueur du remplissage, le reste rempli avec des octets aléatoires',
    paddingPKCS5: 'La valeur de chaque octet de remplissage est égale à la longueur du remplissage',
    paddingPKCS7: 'Identique à PKCS#5',
    paddingISO7816: 'Ajouter 0x80, puis remplir avec 0x00',
    paddingRijndael: 'Identique au remplissage Zéro',
    paddingISO9797M1: 'Remplir avec 0x00 jusqu\'à la taille du bloc',
    paddingISO9797M2: 'Identique à ISO 7816-4',
    mode8BitNote: 'Note : Le mode 8 bits traite 1 octet à la fois',
    mode64BitNote: 'Le mode 64 bits traite un bloc complet (8 octets) à la fois',
  },

  rsa: {
    title: 'Chiffrement/Déchiffrement RSA',
    description: 'Chiffrement, déchiffrement, signature et vérification asymétriques RSA',
    rsaInfo: 'Informations RSA',
    rsaInfo1: 'RSA est un algorithme cryptographique asymétrique',
    rsaInfo2: 'Tailles de clé : 1024, 2048, 4096 bits (2048+ recommandé)',
    rsaInfo3: 'Remplissage PKCS#1 v1.5 et OAEP supportés',
    tabKeys: 'Clés',
    tabEncrypt: 'Chiffrer',
    tabDecrypt: 'Déchiffrer',
    tabSign: 'Signer',
    tabVerify: 'Vérifier',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'Module RSA en hexadécimal',
    privateExpPlaceholder: 'Exposant privé RSA en hexadécimal',
    keyLength: 'Longueur de Clé',
    generateKeys: 'Générer Clés',
    importKeys: 'Importer Clés',
    clearKeys: 'Effacer',
    keyGenerated: 'Paire de clés générée avec succès',
    keysCleared: 'Clés effacées',
    keyImported: 'Clé publique importée avec succès',
    privateKeyImportNote: 'L\'importation de clé privée nécessite tous les paramètres CRT. Utilisez "Générer Clés" pour une fonctionnalité complète.',
    padding: 'Remplissage',
    hashAlgorithm: 'Algorithme de Hachage',
    data: 'Données',
    dataToEncrypt: 'Données à Chiffrer',
    dataPlaceholderAscii: 'Entrez des données texte',
    encodingMethod: 'Méthode d\'encodage',
    private: 'Privée',
    public: 'Publique',
    inputDataFormat: 'Format des données d\'entrée',
    hexadecimal: 'Hexadécimal',
    paddingMethod: 'Méthode de remplissage',
    noPadding: 'Pas de Remplissage',
    errorDataRequired: 'Les données sont requises',
    privateEncryptNote: 'Note : Utilisation de la clé publique pour la démo de chiffrement',
    dataToSign: 'Données à Signer',
    dataToVerify: 'Données à Vérifier',
    ciphertextToDecrypt: 'Texte chiffré à Déchiffrer',
    signatureToVerify: 'Signature',
    dataPlaceholder: 'Entrez des données hexadécimales',
    ciphertextPlaceholder: 'Entrez des données chiffrées hexadécimales',
    signaturePlaceholder: 'Entrez la signature en hexadécimal',
    encrypt: 'Chiffrer',
    decrypt: 'Déchiffrer',
    sign: 'Signer',
    verify: 'Vérifier',
    encryptedResult: 'Résultat Chiffré',
    encryptionFinished: 'Opération de chiffrement des données terminée',
    decryptionFinished: 'Opération de déchiffrement des données terminée',
    decodingMethod: 'Méthode de décodage',
    copyResult: 'Copier Résultat',
    result: 'RÉSULTAT',
    decryptedResult: 'Résultat Déchiffré',
    signatureResult: 'Signature',
    signatureValid: '✓ La signature est valide',
    signatureInvalid: '✗ La signature est invalide',
    encryptInfo: 'Chiffrement RSA',
    encryptDesc: 'Chiffrer les données en utilisant la clé publique. La taille des données est limitée par la taille de la clé.',
    decryptInfo: 'Déchiffrement RSA',
    decryptDesc: 'Déchiffrer les données en utilisant la clé privée.',
    signInfo: 'Signature RSA',
    signDesc: 'Signer les données en utilisant la clé privée (RSA-PSS).',
    verifyInfo: 'Vérification de Signature RSA',
    verifyDesc: 'Vérifier la signature en utilisant la clé publique (RSA-PSS).',
    oaepDesc1: 'OAEP est un schéma de remplissage utilisé avec le chiffrement RSA',
    oaepDesc2: 'Plus sécurisé que le remplissage PKCS#1 v1.5',
    oaepDesc3: 'Empêche les attaques par texte chiffré choisi',
    oaepDesc4: 'Recommandé pour les nouvelles applications',
    oaepStructure: 'Structure OAEP',
    maxDataSize: 'Taille Maximale des Données',
    errorKeyGen: 'La génération de clé a échoué',
    errorKeyImport: 'L\'importation de clé a échoué',
    errorInvalidModulus: 'Module invalide',
    errorInvalidPublicExp: 'Exposant public invalide',
    errorNoPublicKey: 'Veuillez d\'abord générer ou importer une clé publique',
    errorNoPrivateKey: 'Veuillez d\'abord générer une paire de clés (clé privée requise)',
    errorInvalidData: 'Données invalides (doit être hexadécimal)',
    errorInvalidCiphertext: 'Texte chiffré invalide (doit être hexadécimal)',
    errorInvalidSignature: 'Signature invalide (doit être hexadécimal)',
    errorEncryption: 'Le chiffrement a échoué',
    errorDecryption: 'Le déchiffrement a échoué',
    errorSign: 'La signature a échoué',
    errorVerify: 'La vérification a échoué',
  },

  ecc: {
    title: 'ECC (ECDSA)',
    description: 'Cryptographie sur Courbes Elliptiques - Algorithme de Signature Numérique',
    infoTitle: 'À propos de ECC/ECDSA',
    infoContent1: 'La Cryptographie sur Courbes Elliptiques offre une sécurité forte avec des tailles de clés plus petites',
    infoContent2: 'Supporte les courbes P-256, P-384, P-521 pour les signatures numériques',
    infoContent3: 'Les signatures ECDSA peuvent vérifier l\'authenticité et l\'intégrité des données',
    // Tabs
    tabKeys: 'Clés',
    tabSign: 'Signer',
    tabVerify: 'Vérifier',
    // Keys tab
    curveName: 'Nom de la courbe ECC :',
    privateKey: 'Clé Privée :',
    publicKey: 'Clé Publique :',
    publicKeyForm: 'Forme clé publique :',
    privateKeyPlaceholder: 'Clé privée (hexadécimal)',
    publicKeyPlaceholder: 'Clé publique (hexadécimal, format non compressé : 04 || X || Y)',
    generateKeys: 'Générer Clés',
    importKeys: 'Importer Clés',
    clear: 'Effacer',
    keyGenerated: 'Paire de clés ECC générée avec succès',
    keysImported: 'Clés importées avec succès',
    keysCleared: 'Clés effacées',
    privateKeyImportFailed: 'Échec de l\'importation de la clé privée, seule la clé publique a été importée',
    // Sign tab
    data: 'Données :',
    dataToSign: 'Données à Signer :',
    inputDataFormat: 'Format données entrée :',
    hashAlgorithm: 'Algorithme de Hachage :',
    sign: 'Signer',
    signatureResult: '✓ Résultat Signature ECDSA',
    copyDER: 'Copier DER',
    dataLabel: 'Données :',
    dataSize: 'Taille données :',
    hashAlgorithmLabel: 'Algorithme hachage :',
    ecName: 'Nom EC :',
    keyConversionForm: 'Forme Conversion Clé :',
    messageDigest: 'Condensé message :',
    messageDigestSize: 'Taille condensé :',
    signatureR: 'Signature->r :',
    signatureS: 'Signature->s :',
    signatureDER: 'Signature (DER) :',
    // Verify tab
    dataToVerify: 'Données à Vérifier :',
    signatureHex: 'Signature (Hex) :',
    signaturePlaceholder: 'Entrez la signature en hexadécimal (format r || s)',
    verify: 'Vérifier',
    signatureValid: '✓ La signature est valide',
    signatureInvalid: '✗ La signature est invalide',
    // Placeholders
    dataPlaceholderAscii: 'Entrez du texte',
    dataPlaceholderHex: 'Entrez des données hexadécimales',
    // Errors
    errorKeyGen: 'La génération de clé a échoué',
    errorKeyImport: 'L\'importation de clé a échoué',
    errorInvalidPublicKey: 'Clé publique invalide (doit être hexadécimal)',
    errorInvalidPublicKeyFormat: 'Format de clé publique invalide. Attendu {size} octets commençant par 04',
    errorNoPrivateKey: 'Veuillez d\'abord générer ou importer une clé privée',
    errorNoPublicKey: 'Veuillez d\'abord générer ou importer une clé publique',
    errorDataRequired: 'Les données sont requises',
    errorInvalidData: 'Données invalides (doit être hexadécimal)',
    errorInvalidSignature: 'Signature invalide (doit être hexadécimal)',
    errorSign: 'La signature a échoué',
    errorVerify: 'La vérification a échoué',
  },

  fpe: {
    title: 'Chiffrement avec Préservation du Format',
    description: 'Chiffrer des données en préservant leur format et leur longueur (NIST SP 800-38G)',
    radix: 'Base (Radix)',
    encryptionType: 'Type de Chiffrement',
    keyInput: 'Entrée Clé',
    useTweak: 'Utiliser Tweak ?',
    fpeInfo: 'Informations FPE',
    formatPreserving: 'Préservation du Format : La sortie a le même format et la même longueur que l\'entrée',
    radixInfo: 'La base actuelle définit le jeu de caractères valide pour les données',
    tweakInfo: 'Le tweak fournit une entrée supplémentaire pour le chiffrement (comme un IV)',
    minLength: 'Longueur minimale des données : 2 caractères',
    dataPlaceholder: 'Entrez des données avec des caractères valides pour la base',
    tweakPlaceholderFF1: 'Entrez le tweak en hexadécimal (toute longueur)',
    tweakPlaceholderFF3: '16 caractères hex (8 octets)',
    resultLength: 'Longueur',
    characters: 'caractères',
    algorithm: 'Algorithme',
    errorInvalidKeyHex: 'La clé doit être un hexadécimal valide',
    errorKeyLength: 'La longueur de la clé doit être de {length} octets pour {algorithm}',
    errorDataRequired: 'Les données sont requises',
    errorDataTooShort: 'Les données doivent comporter au moins 2 caractères',
    errorInvalidDataForRadix: 'Les données contiennent des caractères invalides pour la base {radix}',
    errorInvalidTweakHex: 'Le tweak doit être un hexadécimal valide',
    errorTweakLength: 'La longueur du tweak doit être de {length} octets pour {algorithm}',
    errorEncryption: 'Le chiffrement a échoué',
    errorDecryption: 'Le déchiffrement a échoué',
    algorithmNotImplemented: 'Cet algorithme n\'est pas encore entièrement implémenté',
  },
};