// French translations
export default {
  common: {
    copy: 'Copier',
    generate: 'Générer',
    calculate: 'Calculer',
    parse: 'Analyser',
    copied: 'Copié dans le presse-papiers !',
    error: 'Erreur',
    result: 'Résultat',
    loading: 'Chargement...',
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: 'Gén. Clé',
    tr31: 'TR-31',
    kcv: 'Calc. KCV',
    pinBlock: 'Bloc PIN',
    asn1: 'ASN.1',
    cipher: 'Chiffrement',
  },
  
  footer: {
    copyright: 'HSMKit.com ©2025 | Calcul sécurisé côté client',
  },
  
  asn1: {
    title: 'Analyseur ASN.1',
    description: 'Analysez les structures ASN.1 DER/BER avec correspondance de définition RFC',
    inputLabel: 'Entrée (Hex, Base64 ou PEM):',
    inputPlaceholder: 'Collez des structures ASN.1 BER/DER encodées en hex, base64 ou PEM, ou téléchargez un fichier',
    withHexDump: 'Afficher Hex Dump',
    trimBigChunks: 'Réduire les grandes données',
    withDefinitions: 'Activer la correspondance de définition',
    uploadFile: 'Télécharger un fichier',
    parse: 'Analyser',
    clear: 'Effacer',
    structureDefinition: 'Définition de structure:',
    selectDefinition: 'Sélectionner une définition de structure...',
    parsedResult: 'Résultat de l\'analyse:',
    hexDump: 'Hex Dump:',
    offset: 'Décalage',
    length: 'Longueur',
    value: 'Valeur',
    constructed: 'Construit',
    loadError: 'Échec du chargement de la bibliothèque d\'analyse ASN.1',
    inputRequired: 'Veuillez entrer des données ASN.1',
    parseError: 'Échec de l\'analyse',
    copied: 'Copié',
    copyHex: 'Copier Hex',
    copyHexDump: 'Copier Hex Dump',
    copyBase64: 'Copier Base64',
    copySubtree: 'Copier le sous-arbre',
    copyValue: 'Copier la valeur',
  },
  
  keyGenerator: {
    title: 'Générateur de Clés Aléatoires',
    description: 'Générez des clés aléatoires cryptographiquement fortes pour DES, 3DES ou AES.',
    keyLength: 'Longueur de Clé',
    bytes: 'Octets',
    bits: 'Bits',
    generateNow: 'Générer maintenant',
    generatedKey: 'Clé Générée (Hexadécimal)',
    kcv: 'KCV',
    length: 'Longueur',
    tabKeyGen: 'Générateur',
    tabCombination: 'Combinaison',
    tabParity: 'Parité',
    tabValidation: 'Validation',
    combinationTitle: 'Combinaison de Composants',
    combinationDesc: 'Combinez plusieurs composants de clé par XOR',
    component: 'Composant',
    components: 'composants',
    combinedKey: 'Clé Combinée',
    addComponent: 'Ajouter',
    removeComponent: 'Supprimer',
    combineKeys: 'Combiner',
    errorInvalidComponent: 'Composant {index} invalide',
    errorComponentLength: 'Tous les composants doivent avoir la même longueur',
    errorComponentLength2: 'La longueur doit être',
    errorMinComponents: 'Au moins 2 composants requis',
    errorMaxComponents: 'Maximum 9 composants autorisés',
    clearAll: 'Effacer tout',
    parityTitle: 'Ajustement de Parité',
    parityDesc: 'Ajuster les bits de parité pour les clés DES/3DES',
    keyInput: 'Entrée de Clé',
    keyInputPlaceholder: 'Entrez la clé hexadécimale',
    parityType: 'Type de Parité',
    odd: 'Impair',
    even: 'Pair',
    adjustParity: 'Ajuster',
    adjustedKey: 'Clé Ajustée',
    validationTitle: 'Validation de Clé',
    validationDesc: 'Vérifier le format, la longueur et la parité',
    validateKey: 'Valider',
    validKey: 'Clé Valide',
    invalidKey: 'Clé Invalide',
    keyType: 'Type de Clé',
    parityStatus: 'État de Parité',
    parityValid: 'Valide',
    parityInvalid: 'Invalide',
  },
  
  kcvCalculator: {
    title: 'Calculateur KCV',
    description: 'Calculez la valeur de vérification de clé pour vérifier l\'exactitude de la clé.',
    algorithm: 'Algorithme',
    keyInput: 'Clé (Hexadécimal)',
    keyPlaceholder: 'ex : 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'Calculer KCV',
    keyCheckValue: 'Valeur de Vérification de Clé',
    errorInvalidHex: 'La clé doit contenir des caractères hexadécimaux valides',
    errorDesLength: 'La longueur de clé DES/3DES doit être de 8, 16 ou 24 octets',
    errorAesLength: 'La longueur de clé AES doit être de 16, 24 ou 32 octets',
    errorCalculation: 'Échec du calcul, veuillez vérifier le format de la clé',
    format: 'Format',
    autoAdjustParity: 'Ajuster automatiquement les bits de parité',
    parityAdjustmentHint: 'Certaines clés peuvent ne pas avoir de bits de parité corrects, cochez cette option pour corriger automatiquement',
    kcvCalcTitle: 'Calcul de la Valeur de Vérification de Clé',
    desCalcDesc: 'Utilisez le texte clair de la clé pour chiffrer 16 caractères longs \'0\' avec l\'algorithme 3DES-ECB, puis interceptez les six premiers caractères de la valeur chiffrée comme valeur de vérification de clé',
    aesCalcDesc: 'Utilisez le texte clair de la clé pour chiffrer 32 caractères longs \'0\' avec l\'algorithme CMAC-AES, puis interceptez les six premiers caractères de la valeur chiffrée comme valeur de vérification de clé',
  },
  
  pinBlock: {
    title: 'Générateur de Bloc PIN',
    description: 'Générez des blocs PIN au format ISO pour les transactions de paiement.',
    format: 'Format de Bloc PIN',
    pinLabel: 'PIN (4-12 chiffres)',
    pinPlaceholder: 'ex : 1234',
    panLabel: 'PAN (Numéro de Compte Principal)',
    panPlaceholder: 'ex : 4111111111111111',
    generatePinBlock: 'Générer le Bloc PIN',
    pinBlockHex: 'Bloc PIN (Hexadécimal)',
    errorInvalidPin: 'Le PIN doit comporter 4 à 12 chiffres',
    errorInvalidPan: 'Le PAN doit comporter 13 à 19 chiffres',
    errorGeneration: 'Échec de la génération, veuillez vérifier la saisie',
    errorFormat1: 'ISO Format 1 à venir...',
    pinLengthHint: 'Prend en charge les PIN de 4 à 12 chiffres',
    panHint: 'Entrez le numéro de carte complet (13-19 chiffres), le système extraira automatiquement les 12 chiffres les plus à droite (hors chiffre de contrôle)',
  },
  
  tr31: {
    title: 'Analyseur de Bloc de Clé TR-31',
    description: 'Analysez et examinez les blocs de clé au format TR-31 (norme ANSI X9.143).',
    keyBlock: 'Bloc de Clé TR-31',
    keyBlockPlaceholder: 'ex : B0112P0TE00N0000...',
    parseKeyBlock: 'Analyser le Bloc de Clé',
    header: 'En-tête du Bloc de Clé',
    version: 'Version',
    keyLength: 'Longueur',
    keyUsage: 'Usage de la Clé',
    mode: 'Mode',
    keyVersion: 'Version de la Clé',
    exportability: 'Exportabilité',
    characters: 'caractères',
    errorTooShort: 'Longueur du bloc de clé TR-31 insuffisante',
    errorParsing: 'Échec de l\'analyse, veuillez vérifier le format TR-31',
    exportable: 'Exportable',
    nonExportable: 'Non exportable',
    sensitive: 'Sensible',
    keyBlockFormatHint: 'Format de bloc de clé TR-31 (ex : B0112P0TE00N...), le système validera automatiquement le format',
  },
  
  placeholder: {
    title: 'Bientôt disponible',
    description: 'Cet outil est en cours de développement. Restez à l\'écoute !',
  },

  cipher: {
    title: 'Chiffrement/Déchiffrement AES',
    description: 'Chiffrer et déchiffrer des données avec l\'algorithme AES',
    algorithm: 'Algorithme',
    mode: 'Mode',
    dataInput: 'Entrée de données',
    hexadecimal: 'Hexadécimal',
    key: 'Clé',
    data: 'Données',
    hexChars: 'caractères hex',
    dataPlaceholderHex: 'Entrez des données hexadécimales',
    dataPlaceholderAscii: 'Entrez du texte ASCII',
    encrypt: 'Chiffrer',
    decrypt: 'Déchiffrer',
    encryptResult: 'Résultat du chiffrement',
    decryptResult: 'Résultat du déchiffrement',
    aesInfo: 'Informations AES',
    keyLengthInfo: 'La longueur de clé doit correspondre à l\'algorithme sélectionné',
    ivInfo: 'L\'IV (Vecteur d\'initialisation) doit faire 16 octets',
    paddingInfo: 'Utilise le rembourrage PKCS7',
    errorInvalidKeyHex: 'La clé doit être un hexadécimal valide',
    errorKeyLength: 'La longueur de clé doit être {length} octets pour {algorithm}',
    errorDataRequired: 'Les données sont requises',
    errorInvalidDataHex: 'Les données doivent être un hexadécimal valide',
    errorInvalidIvHex: 'L\'IV doit être un hexadécimal valide',
    errorIvLength: 'La longueur de l\'IV doit être {length} octets',
    errorEncryption: 'Échec du chiffrement',
    errorDecryption: 'Échec du déchiffrement',
    errorInvalidCiphertext: 'Le texte chiffré doit être un hexadécimal valide',
    ivNotRequired: 'L\'IV n\'est pas requis pour le mode ECB/KCV',
    kcvInfo: 'KCV : Chiffrer des zéros et prendre les 6 premiers caractères hex',
    calculateKcv: 'Calculer KCV',
    noPaddingInfo: 'Sans rembourrage - la longueur des données doit être un multiple de 16 octets',
    errorDataLength: 'La longueur des données doit être un multiple de 16 octets',
    kcvNoDataNeeded: 'Aucune donnée requise pour le calcul KCV',
    kcvDataHint: 'Le KCV est calculé avec des zéros, aucune entrée de données nécessaire',
    errorKcvCalculation: 'Échec du calcul KCV',
    kcvResult: 'Résultat KCV',
  },

  des: {
    title: 'Chiffrement/Déchiffrement DES / 3DES',
    description: 'Chiffrer et déchiffrer des données avec l\'algorithme DES ou 3DES',
    algorithm: 'Algorithme',
    mode: 'Mode',
    dataInput: 'Entrée de données',
    hexadecimal: 'Hexadécimal',
    padding: 'Rembourrage',
    key: 'Clé',
    data: 'Données',
    hexChars: 'caractères hex',
    dataPlaceholderHex: 'Entrez des données hexadécimales',
    dataPlaceholderAscii: 'Entrez du texte ASCII',
    encrypt: 'Chiffrer',
    decrypt: 'Déchiffrer',
    encryptResult: 'Résultat du chiffrement',
    decryptResult: 'Résultat du déchiffrement',
    desInfo: 'Informations DES/3DES',
    keyLengthInfoDes: 'DES nécessite une clé de 8 octets (64 bits)',
    keyLengthInfo3Des: '3DES nécessite une clé de 16 ou 24 octets',
    ivInfo: 'L\'IV (Vecteur d\'initialisation) doit faire 8 octets',
    blockSizeInfo: 'La taille du bloc est de 8 octets',
    errorInvalidKeyHex: 'La clé doit être un hexadécimal valide',
    errorKeyLengthDes: 'La longueur de clé DES doit être de 8 octets',
    errorKeyLength3Des: 'La longueur de clé 3DES doit être de 16 ou 24 octets',
    errorDataRequired: 'Les données sont requises',
    errorInvalidDataHex: 'Les données doivent être un hexadécimal valide',
    errorDataLength: 'La longueur des données doit être un multiple de 8 octets sans rembourrage',
    errorInvalidIvHex: 'L\'IV doit être un hexadécimal valide',
    errorIvLength: 'La longueur de l\'IV doit être {length} octets',
    errorEncryption: 'Échec du chiffrement',
    errorDecryption: 'Échec du déchiffrement',
    errorInvalidCiphertext: 'Le texte chiffré doit être un hexadécimal valide',
    ivNotRequired: 'L\'IV n\'est pas requis pour le mode ECB',
    paddingNone: 'Pas de rembourrage',
    paddingZeros: 'Remplir avec 0x00',
    paddingSpaces: 'Remplir avec espace 0x20',
    paddingANSIX923: 'Dernier octet = longueur du rembourrage, reste rempli de 0x00',
    paddingISO10126: 'Dernier octet = longueur du rembourrage, reste rempli d\'octets aléatoires',
    paddingPKCS5: 'Chaque octet de rembourrage égale la longueur du rembourrage',
    paddingPKCS7: 'Identique à PKCS#5',
    paddingISO7816: 'Ajouter 0x80, puis remplir avec 0x00',
    paddingRijndael: 'Identique au Zero padding',
    paddingISO9797M1: 'Remplir avec 0x00 jusqu\'à la taille du bloc',
    paddingISO9797M2: 'Identique à ISO 7816-4',
    mode8BitNote: 'Note : le mode 8 bits traite 1 octet à la fois',
    mode64BitNote: 'Le mode 64 bits traite un bloc complet (8 octets) à la fois',
  },

  rsa: {
    title: 'Chiffrement/Déchiffrement RSA',
    description: 'Chiffrement asymétrique RSA, déchiffrement, signature et vérification',
    tabKeys: 'Clés',
    tabEncrypt: 'Chiffrer',
    tabDecrypt: 'Déchiffrer',
    tabSign: 'Signer',
    tabVerify: 'Vérifier',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'Module RSA en hexadécimal',
    privateExpPlaceholder: 'Exposant privé RSA en hexadécimal',
    keyLength: 'Longueur de clé',
    generateKeys: 'Générer les clés',
    importKeys: 'Importer les clés',
    clearKeys: 'Effacer',
    keyGenerated: 'Paire de clés générée avec succès',
    keysCleared: 'Clés effacées',
    keyImported: 'Clé publique importée avec succès',
    privateKeyImportNote: 'L\'importation de clé privée nécessite les paramètres CRT complets. Utilisez "Générer les clés" pour une fonctionnalité complète.',
    padding: 'Rembourrage',
    hashAlgorithm: 'Algorithme de hachage',
    data: 'Données',
    dataToEncrypt: 'Données à chiffrer',
    dataPlaceholderAscii: 'Entrez des données texte',
    encodingMethod: 'Méthode d\'encodage',
    private: 'Privé',
    public: 'Public',
    inputDataFormat: 'Format des données d\'entrée',
    hexadecimal: 'Hexadécimal',
    paddingMethod: 'Méthode de rembourrage',
    noPadding: 'Sans rembourrage',
    errorDataRequired: 'Données requises',
    privateEncryptNote: 'Note: Utilisation de la clé publique pour le chiffrement',
    dataToSign: 'Données à signer',
    dataToVerify: 'Données à vérifier',
    ciphertextToDecrypt: 'Texte chiffré à déchiffrer',
    signatureToVerify: 'Signature',
    dataPlaceholder: 'Entrez des données hexadécimales',
    ciphertextPlaceholder: 'Entrez des données hexadécimales chiffrées',
    signaturePlaceholder: 'Entrez la signature en hexadécimal',
    encrypt: 'Chiffrer',
    decrypt: 'Déchiffrer',
    sign: 'Signer',
    verify: 'Vérifier',
    encryptedResult: 'Résultat chiffré',
    encryptionFinished: 'Opération de chiffrement terminée',
    decryptionFinished: 'Opération de déchiffrement terminée',
    decodingMethod: 'Méthode de décodage',
    copyResult: 'Copier le résultat',
    result: 'RÉSULTAT',
    decryptedResult: 'Résultat déchiffré',
    signatureResult: 'Signature',
    signatureValid: '✓ Signature valide',
    signatureInvalid: '✗ Signature invalide',
    encryptInfo: 'Chiffrement RSA',
    encryptDesc: 'Chiffrer les données avec la clé publique',
    decryptInfo: 'Déchiffrement RSA',
    decryptDesc: 'Déchiffrer les données avec la clé privée',
    signInfo: 'Signature RSA',
    signDesc: 'Signer les données avec la clé privée (RSA-PSS)',
    verifyInfo: 'Vérification de signature RSA',
    verifyDesc: 'Vérifier la signature avec la clé publique (RSA-PSS)',
    oaepDesc1: 'OAEP est un schéma de rembourrage pour le chiffrement RSA',
    oaepDesc2: 'Plus sécurisé que le rembourrage PKCS#1 v1.5',
    oaepDesc3: 'Empêche les attaques par texte chiffré choisi',
    oaepDesc4: 'Recommandé pour les nouvelles applications',
    oaepStructure: 'Structure OAEP',
    maxDataSize: 'Taille maximale des données',
    errorKeyGen: 'Échec de la génération de clé',
    errorKeyImport: 'Échec de l\'importation de clé',
    errorInvalidModulus: 'Module invalide',
    errorInvalidPublicExp: 'Exposant public invalide',
    errorNoPublicKey: 'Veuillez d\'abord générer ou importer une clé publique',
    errorNoPrivateKey: 'Veuillez d\'abord générer une paire de clés (clé privée requise)',
    errorInvalidData: 'Données invalides (doit être hexadécimal)',
    errorInvalidCiphertext: 'Texte chiffré invalide (doit être hexadécimal)',
    errorInvalidSignature: 'Signature invalide (doit être hexadécimal)',
    errorEncryption: 'Échec du chiffrement',
    errorDecryption: 'Échec du déchiffrement',
    errorSign: 'Échec de la signature',
    errorVerify: 'Échec de la vérification',
  },

  fpe: {
    title: 'Chiffrement Préservant le Format',
    description: 'Chiffrer les données tout en préservant leur format et leur longueur (NIST SP 800-38G)',
    radix: 'Base',
    encryptionType: 'Type de chiffrement',
    keyInput: 'Entrée de clé',
    useTweak: 'Utiliser Tweak ?',
    fpeInfo: 'Informations FPE',
    formatPreserving: 'Préservation du format : la sortie a le même format et la même longueur que l\'entrée',
    radixInfo: 'La base actuelle définit l\'ensemble de caractères valides pour les données',
    tweakInfo: 'Le Tweak fournit une entrée supplémentaire pour le chiffrement (comme un IV)',
    minLength: 'Longueur minimale des données : 2 caractères',
    dataPlaceholder: 'Entrez des données avec des caractères de base valides',
    tweakPlaceholderFF1: 'Entrez le Tweak en hexadécimal (longueur quelconque)',
    tweakPlaceholderFF3: '16 caractères hex (8 octets)',
    resultLength: 'Longueur',
    characters: 'caractères',
    algorithm: 'Algorithme',
    errorInvalidKeyHex: 'La clé doit être un hexadécimal valide',
    errorKeyLength: 'La longueur de clé doit être {length} octets pour {algorithm}',
    errorDataRequired: 'Données requises',
    errorDataTooShort: 'Les données doivent comporter au moins 2 caractères',
    errorInvalidDataForRadix: 'Les données contiennent des caractères invalides pour la base {radix}',
    errorInvalidTweakHex: 'Le Tweak doit être un hexadécimal valide',
    errorTweakLength: 'La longueur du Tweak doit être {length} octets pour {algorithm}',
    errorEncryption: 'Échec du chiffrement',
    errorDecryption: 'Échec du déchiffrement',
    algorithmNotImplemented: 'Cet algorithme n\'est pas encore entièrement implémenté',
  },
};

