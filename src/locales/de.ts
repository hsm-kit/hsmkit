// German translations
export default {
  common: {
    copy: 'Kopieren',
    generate: 'Generieren',
    calculate: 'Berechnen',
    parse: 'Analysieren',
    copied: 'In die Zwischenablage kopiert!',
    error: 'Fehler',
    result: 'Ergebnis',
    loading: 'Wird geladen...',
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: 'Schlüssel Gen.',
    tr31: 'TR-31',
    kcv: 'KCV Rechner',
    pinBlock: 'PIN-Block',
    asn1: 'ASN.1',
    cipher: 'Verschlüsselung',
  },
  
  footer: {
    copyright: 'HSMKit.com ©2025 | Sichere clientseitige Berechnung',
  },
  
  asn1: {
    title: 'ASN.1 Parser',
    description: 'Analysieren Sie ASN.1 DER/BER-Strukturen mit RFC-Definitionsabgleich',
    inputLabel: 'Eingabe (Hex, Base64 oder PEM):',
    inputPlaceholder: 'Hex-, Base64- oder PEM-kodierte ASN.1 BER/DER-Strukturen einfügen oder Datei hochladen',
    withHexDump: 'Hex Dump anzeigen',
    trimBigChunks: 'Große Daten kürzen',
    withDefinitions: 'Definitionsabgleich aktivieren',
    uploadFile: 'Datei hochladen',
    parse: 'Analysieren',
    clear: 'Löschen',
    structureDefinition: 'Strukturdefinition:',
    selectDefinition: 'Strukturdefinition auswählen...',
    parsedResult: 'Analyseergebnis:',
    hexDump: 'Hex Dump:',
    offset: 'Offset',
    length: 'Länge',
    value: 'Wert',
    constructed: 'Konstruiert',
    loadError: 'ASN.1-Parsing-Bibliothek konnte nicht geladen werden',
    inputRequired: 'Bitte ASN.1-Daten eingeben',
    parseError: 'Analyse fehlgeschlagen',
    copied: 'Kopiert',
    copyHex: 'Hex kopieren',
    copyHexDump: 'Hex Dump kopieren',
    copyBase64: 'Base64 kopieren',
    copySubtree: 'Teilbaum kopieren',
    copyValue: 'Wert kopieren',
  },
  
  keyGenerator: {
    title: 'Zufälliger Schlüsselgenerator',
    description: 'Generieren Sie kryptografisch starke Zufallsschlüssel für DES, 3DES oder AES.',
    keyLength: 'Schlüssellänge',
    bytes: 'Bytes',
    bits: 'Bits',
    generateNow: 'Jetzt generieren',
    generatedKey: 'Generierter Schlüssel (Hexadezimal)',
    kcv: 'KCV',
    length: 'Länge',
    tabKeyGen: 'Generator',
    tabCombination: 'Kombination',
    tabParity: 'Parität',
    tabValidation: 'Validierung',
    combinationTitle: 'Schlüsselkombination',
    combinationDesc: 'Kombinieren Sie mehrere Schlüsselkomponenten per XOR',
    component: 'Komponente',
    components: 'Komponenten',
    combinedKey: 'Kombinierter Schlüssel',
    addComponent: 'Hinzufügen',
    removeComponent: 'Entfernen',
    combineKeys: 'Kombinieren',
    errorInvalidComponent: 'Komponente {index} ungültig',
    errorComponentLength: 'Alle Komponenten müssen die gleiche Länge haben',
    errorComponentLength2: 'Länge muss sein',
    errorMinComponents: 'Mindestens 2 Komponenten erforderlich',
    errorMaxComponents: 'Maximal 9 Komponenten erlaubt',
    clearAll: 'Alles löschen',
    parityTitle: 'Paritätsanpassung',
    parityDesc: 'Paritätsbits für DES/3DES-Schlüssel anpassen',
    keyInput: 'Schlüsseleingabe',
    keyInputPlaceholder: 'Hexadezimalen Schlüssel eingeben',
    parityType: 'Paritätstyp',
    odd: 'Ungerade',
    even: 'Gerade',
    adjustParity: 'Anpassen',
    adjustedKey: 'Angepasster Schlüssel',
    validationTitle: 'Schlüsselvalidierung',
    validationDesc: 'Format, Länge und Parität prüfen',
    validateKey: 'Validieren',
    validKey: 'Gültiger Schlüssel',
    invalidKey: 'Ungültiger Schlüssel',
    keyType: 'Schlüsseltyp',
    parityStatus: 'Paritätsstatus',
    parityValid: 'Gültig',
    parityInvalid: 'Ungültig',
  },
  
  kcvCalculator: {
    title: 'KCV-Rechner',
    description: 'Berechnen Sie den Schlüsselprüfwert zur Überprüfung der Schlüsselkorrektheit.',
    algorithm: 'Algorithmus',
    keyInput: 'Schlüssel (Hexadezimal)',
    keyPlaceholder: 'z.B.: 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'KCV berechnen',
    keyCheckValue: 'Schlüsselprüfwert',
    errorInvalidHex: 'Der Schlüssel muss aus gültigen Hexadezimalzeichen bestehen',
    errorDesLength: 'DES/3DES-Schlüssellänge muss 8, 16 oder 24 Bytes betragen',
    errorAesLength: 'AES-Schlüssellänge muss 16, 24 oder 32 Bytes betragen',
    errorCalculation: 'Berechnung fehlgeschlagen, bitte Schlüsselformat überprüfen',
    format: 'Format',
    autoAdjustParity: 'Paritätsbits automatisch anpassen',
    parityAdjustmentHint: 'Einige Schlüssel haben möglicherweise keine korrekten Paritätsbits, aktivieren Sie diese Option zur automatischen Korrektur',
    kcvCalcTitle: 'Berechnung des Schlüsselprüfwerts',
    desCalcDesc: 'Verwenden Sie den Klartext des Schlüssels, um 16 Zeichen lange \'0\' mit dem 3DES-ECB-Algorithmus zu verschlüsseln, und extrahieren Sie dann die ersten sechs Zeichen des verschlüsselten Werts als Schlüsselprüfwert',
    aesCalcDesc: 'Verwenden Sie den Klartext des Schlüssels, um 32 Zeichen lange \'0\' mit dem CMAC-AES-Algorithmus zu verschlüsseln, und extrahieren Sie dann die ersten sechs Zeichen des verschlüsselten Werts als Schlüsselprüfwert',
  },
  
  pinBlock: {
    title: 'PIN-Block-Generator',
    description: 'Generieren Sie ISO-Format-PIN-Blöcke für Zahlungstransaktionen.',
    format: 'PIN-Block-Format',
    pinLabel: 'PIN (4-12 Ziffern)',
    pinPlaceholder: 'z.B.: 1234',
    panLabel: 'PAN (Primäre Kontonummer)',
    panPlaceholder: 'z.B.: 4111111111111111',
    generatePinBlock: 'PIN-Block generieren',
    pinBlockHex: 'PIN-Block (Hexadezimal)',
    errorInvalidPin: 'PIN muss 4-12 Ziffern lang sein',
    errorInvalidPan: 'PAN muss 13-19 Ziffern lang sein',
    errorGeneration: 'Generierung fehlgeschlagen, bitte Eingabe überprüfen',
    errorFormat1: 'ISO Format 1 in Kürze verfügbar...',
    pinLengthHint: 'Unterstützt 4-12 stellige PIN',
    panHint: 'Geben Sie die vollständige Kartennummer ein (13-19 Ziffern), das System extrahiert automatisch die rechtesten 12 Ziffern (ohne Prüfziffer)',
  },
  
  tr31: {
    title: 'TR-31-Schlüsselblock-Analysator',
    description: 'Analysieren und untersuchen Sie TR-31-Format-Schlüsselblöcke (ANSI X9.143-Standard).',
    keyBlock: 'TR-31-Schlüsselblock',
    keyBlockPlaceholder: 'z.B.: B0112P0TE00N0000...',
    parseKeyBlock: 'Schlüsselblock analysieren',
    header: 'Schlüsselblock-Header',
    version: 'Version',
    keyLength: 'Länge',
    keyUsage: 'Schlüsselverwendung',
    mode: 'Modus',
    keyVersion: 'Schlüsselversion',
    exportability: 'Exportierbarkeit',
    characters: 'Zeichen',
    errorTooShort: 'TR-31-Schlüsselblocklänge unzureichend',
    errorParsing: 'Analyse fehlgeschlagen, bitte TR-31-Format überprüfen',
    exportable: 'Exportierbar',
    nonExportable: 'Nicht exportierbar',
    sensitive: 'Sensibel',
    keyBlockFormatHint: 'TR-31 Key Block Format (z.B. B0112P0TE00N...), das System validiert das Format automatisch',
  },
  
  placeholder: {
    title: 'Demnächst verfügbar',
    description: 'Dieses Tool befindet sich in der Entwicklung. Bleiben Sie dran!',
  },

  cipher: {
    title: 'AES Verschlüsselung/Entschlüsselung',
    description: 'Daten mit AES-Algorithmus verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    aesInfo: 'AES-Informationen',
    keyLengthInfo: 'Schlüssellänge muss dem gewählten Algorithmus entsprechen',
    ivInfo: 'IV (Initialisierungsvektor) muss 16 Bytes betragen',
    paddingInfo: 'Verwendet PKCS7-Padding',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} sein',
    errorDataRequired: 'Daten erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für ECB/KCV-Modus nicht erforderlich',
    kcvInfo: 'KCV: Nullen verschlüsseln und erste 6 Hex-Zeichen nehmen',
    calculateKcv: 'KCV berechnen',
    noPaddingInfo: 'Kein Padding - Datenlänge muss ein Vielfaches von 16 Bytes sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 16 Bytes sein',
    kcvNoDataNeeded: 'Für KCV-Berechnung keine Daten erforderlich',
    kcvDataHint: 'KCV wird mit Nullen berechnet, keine Dateneingabe erforderlich',
    errorKcvCalculation: 'KCV-Berechnung fehlgeschlagen',
    kcvResult: 'KCV-Ergebnis',
  },

  des: {
    title: 'DES / 3DES Verschlüsselung/Entschlüsselung',
    description: 'Daten mit DES oder 3DES Algorithmus verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    padding: 'Padding',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    desInfo: 'DES/3DES Informationen',
    keyLengthInfoDes: 'DES benötigt einen 8-Byte (64-Bit) Schlüssel',
    keyLengthInfo3Des: '3DES benötigt einen 16 oder 24-Byte Schlüssel',
    ivInfo: 'IV (Initialisierungsvektor) muss 8 Bytes betragen',
    blockSizeInfo: 'Blockgröße ist 8 Bytes',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLengthDes: 'DES Schlüssellänge muss 8 Bytes sein',
    errorKeyLength3Des: '3DES Schlüssellänge muss 16 oder 24 Bytes sein',
    errorDataRequired: 'Daten erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 8 Bytes sein bei keinem Padding',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für ECB-Modus nicht erforderlich',
    paddingNone: 'Kein Padding',
    paddingZeros: 'Mit 0x00 auffüllen',
    paddingSpaces: 'Mit Leerzeichen 0x20 auffüllen',
    paddingANSIX923: 'Letztes Byte ist Padding-Länge, Rest mit 0x00 gefüllt',
    paddingISO10126: 'Letztes Byte ist Padding-Länge, Rest mit Zufallsbytes gefüllt',
    paddingPKCS5: 'Jeder Padding-Byte-Wert entspricht der Padding-Länge',
    paddingPKCS7: 'Wie PKCS#5',
    paddingISO7816: '0x80 hinzufügen, dann mit 0x00 auffüllen',
    paddingRijndael: 'Wie Zero Padding',
    paddingISO9797M1: 'Mit 0x00 auf Blockgröße auffüllen',
    paddingISO9797M2: 'Wie ISO 7816-4',
    mode8BitNote: 'Hinweis: 8-Bit-Modus verarbeitet 1 Byte pro Durchgang',
    mode64BitNote: '64-Bit-Modus verarbeitet vollständigen Block (8 Bytes) pro Durchgang',
  },

  rsa: {
    title: 'RSA Verschlüsselung/Entschlüsselung',
    description: 'RSA asymmetrische Verschlüsselung, Entschlüsselung, Signierung und Verifizierung',
    tabKeys: 'Schlüssel',
    tabEncrypt: 'Verschlüsseln',
    tabDecrypt: 'Entschlüsseln',
    tabSign: 'Signieren',
    tabVerify: 'Verifizieren',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA-Modul in Hexadezimal',
    privateExpPlaceholder: 'RSA privater Exponent in Hexadezimal',
    keyLength: 'Schlüssellänge',
    generateKeys: 'Schlüssel generieren',
    importKeys: 'Schlüssel importieren',
    clearKeys: 'Löschen',
    keyGenerated: 'Schlüsselpaar erfolgreich generiert',
    keysCleared: 'Schlüssel gelöscht',
    keyImported: 'Öffentlicher Schlüssel erfolgreich importiert',
    privateKeyImportNote: 'Privater Schlüsselimport erfordert vollständige CRT-Parameter. Verwenden Sie "Schlüssel generieren" für volle Funktionalität.',
    padding: 'Padding',
    hashAlgorithm: 'Hash-Algorithmus',
    data: 'Daten',
    dataToEncrypt: 'Zu verschlüsselnde Daten',
    dataPlaceholderAscii: 'Textdaten eingeben',
    encodingMethod: 'Kodierungsmethode',
    private: 'Privat',
    public: 'Öffentlich',
    inputDataFormat: 'Eingabedatenformat',
    hexadecimal: 'Hexadezimal',
    paddingMethod: 'Padding-Methode',
    noPadding: 'Kein Padding',
    errorDataRequired: 'Daten erforderlich',
    privateEncryptNote: 'Hinweis: Verwendung des öffentlichen Schlüssels zur Verschlüsselung',
    dataToSign: 'Zu signierende Daten',
    dataToVerify: 'Zu verifizierende Daten',
    ciphertextToDecrypt: 'Zu entschlüsselnder Chiffretext',
    signatureToVerify: 'Signatur',
    dataPlaceholder: 'Hexadezimale Daten eingeben',
    ciphertextPlaceholder: 'Verschlüsselte Hexadezimaldaten eingeben',
    signaturePlaceholder: 'Signatur in Hexadezimal eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    sign: 'Signieren',
    verify: 'Verifizieren',
    encryptedResult: 'Verschlüsseltes Ergebnis',
    encryptionFinished: 'Datenverschlüsselung abgeschlossen',
    decryptionFinished: 'Datenentschlüsselung abgeschlossen',
    decodingMethod: 'Dekodierungsmethode',
    copyResult: 'Ergebnis kopieren',
    result: 'ERGEBNIS',
    decryptedResult: 'Entschlüsseltes Ergebnis',
    signatureResult: 'Signatur',
    signatureValid: '✓ Signatur ist gültig',
    signatureInvalid: '✗ Signatur ist ungültig',
    encryptInfo: 'RSA Verschlüsselung',
    encryptDesc: 'Daten mit dem öffentlichen Schlüssel verschlüsseln',
    decryptInfo: 'RSA Entschlüsselung',
    decryptDesc: 'Daten mit dem privaten Schlüssel entschlüsseln',
    signInfo: 'RSA Signatur',
    signDesc: 'Daten mit dem privaten Schlüssel signieren (RSA-PSS)',
    verifyInfo: 'RSA Signaturverifizierung',
    verifyDesc: 'Signatur mit dem öffentlichen Schlüssel verifizieren (RSA-PSS)',
    oaepDesc1: 'OAEP ist ein Padding-Schema für RSA-Verschlüsselung',
    oaepDesc2: 'Sicherer als PKCS#1 v1.5 Padding',
    oaepDesc3: 'Verhindert Chosen-Ciphertext-Angriffe',
    oaepDesc4: 'Empfohlen für neue Anwendungen',
    oaepStructure: 'OAEP Struktur',
    maxDataSize: 'Maximale Datengröße',
    errorKeyGen: 'Schlüsselgenerierung fehlgeschlagen',
    errorKeyImport: 'Schlüsselimport fehlgeschlagen',
    errorInvalidModulus: 'Ungültiges Modul',
    errorInvalidPublicExp: 'Ungültiger öffentlicher Exponent',
    errorNoPublicKey: 'Bitte generieren oder importieren Sie zuerst einen öffentlichen Schlüssel',
    errorNoPrivateKey: 'Bitte generieren Sie zuerst ein Schlüsselpaar (privater Schlüssel erforderlich)',
    errorInvalidData: 'Ungültige Daten (muss hexadezimal sein)',
    errorInvalidCiphertext: 'Ungültiger Chiffretext (muss hexadezimal sein)',
    errorInvalidSignature: 'Ungültige Signatur (muss hexadezimal sein)',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorSign: 'Signierung fehlgeschlagen',
    errorVerify: 'Verifizierung fehlgeschlagen',
  },

  fpe: {
    title: 'Format-erhaltende Verschlüsselung',
    description: 'Daten verschlüsseln unter Beibehaltung von Format und Länge (NIST SP 800-38G)',
    radix: 'Basis',
    encryptionType: 'Verschlüsselungstyp',
    keyInput: 'Schlüsseleingabe',
    useTweak: 'Tweak verwenden?',
    fpeInfo: 'FPE-Informationen',
    formatPreserving: 'Format-erhaltend: Ausgabe hat das gleiche Format und die gleiche Länge wie die Eingabe',
    radixInfo: 'Die aktuelle Basis definiert den gültigen Zeichensatz für Daten',
    tweakInfo: 'Tweak bietet zusätzliche Eingabe für die Verschlüsselung (wie ein IV)',
    minLength: 'Minimale Datenlänge: 2 Zeichen',
    dataPlaceholder: 'Daten mit gültigen Basis-Zeichen eingeben',
    tweakPlaceholderFF1: 'Tweak in Hexadezimal eingeben (beliebige Länge)',
    tweakPlaceholderFF3: '16 Hex-Zeichen (8 Bytes)',
    resultLength: 'Länge',
    characters: 'Zeichen',
    algorithm: 'Algorithmus',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} sein',
    errorDataRequired: 'Daten erforderlich',
    errorDataTooShort: 'Daten müssen mindestens 2 Zeichen lang sein',
    errorInvalidDataForRadix: 'Daten enthalten ungültige Zeichen für Basis {radix}',
    errorInvalidTweakHex: 'Tweak muss gültiges Hexadezimal sein',
    errorTweakLength: 'Tweak-Länge muss {length} Bytes für {algorithm} sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    algorithmNotImplemented: 'Dieser Algorithmus ist noch nicht vollständig implementiert',
  },
};

