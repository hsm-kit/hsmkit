// German translations
export default {
  common: {
    copy: 'Kopieren',
    generate: 'Generieren',
    calculate: 'Berechnen',
    parse: 'Analysieren',
    clear: 'Löschen',
    copied: 'In die Zwischenablage kopiert!',
    error: 'Fehler',
    result: 'Ergebnis',
    loading: 'Wird geladen...',
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: 'Schlüssel Gen.',
    tr31: 'TR-31',
    kcv: 'KCV Rechner',
    pinBlock: 'PIN-Block',
    asn1: 'ASN.1',
    cipher: 'Verschlüsselung',
    generic: 'Allgemein',
    hashes: 'Hashes',
    characterEncoding: 'Zeichenkodierung',
    bcd: 'BCD',
    checkDigits: 'Prüfziffern',
    base64: 'Base64',
    base94: 'Base94',
    messageParser: 'Nachrichtenparser',
    rsaDerPublicKey: 'RSA DER Öffentlicher Schlüssel',
    uuid: 'UUID',
  },
  
  footer: {
    copyright: 'HSMKit.com ©2025 | Sichere clientseitige Berechnung',
  },

  home: {
    heroTitle: 'Kostenlose Online-Verschlüsselung & Schlüsselverwaltung',
    heroDescription: 'Eine umfassende Suite von Kryptografie-Tools für Sicherheitsexperten. Alle Berechnungen werden clientseitig in Ihrem Browser durchgeführt — Ihre Daten verlassen niemals Ihr Gerät.',
    searchPlaceholder: 'Tools suchen... (z.B. MD5, AES, PIN Block)',
    availableTools: 'Verfügbare Tools',
    whyChoose: 'Warum HSM Kit wählen?',
    categories: {
      all: 'Alle',
      symmetric: 'Symmetrisch',
      asymmetric: 'Asymmetrisch',
      payment: 'Zahlung/Finanzen',
      encoding: 'Codierung',
      hashing: 'Hashing',
    },
    tools: {
      asn1: {
        title: 'ASN.1 Parser',
        description: 'ASN.1 DER/BER-Strukturen analysieren, X.509-Zertifikate und PKCS-Formate dekodieren.',
      },
      aes: {
        title: 'AES-Verschlüsselung',
        description: 'Daten mit AES-128/192/256 verschlüsseln/entschlüsseln. ECB, CBC, CFB, OFB, CTR Modi.',
      },
      des: {
        title: 'DES/3DES-Verschlüsselung',
        description: 'DES und Triple DES Verschlüsselung mit mehreren Padding-Optionen für Legacy-Systeme.',
      },
      rsa: {
        title: 'RSA-Verschlüsselung',
        description: 'RSA asymmetrische Verschlüsselung, Entschlüsselung, digitale Signatur und Verifizierung.',
      },
      ecc: {
        title: 'ECC/ECDSA',
        description: 'Elliptische-Kurven-Kryptografie für kompakte Schlüssel und effiziente digitale Signaturen.',
      },
      fpe: {
        title: 'Format-erhaltende Verschlüsselung',
        description: 'FPE (FF1/FF3-1) zur Verschlüsselung unter Beibehaltung von Format und Länge.',
      },
      keyGenerator: {
        title: 'Schlüsselgenerator',
        description: 'Sichere Zufallsschlüssel für AES, DES, 3DES generieren. Schlüsselkombination und Parität-Tools.',
      },
      tr31: {
        title: 'TR-31 Schlüsselblock',
        description: 'TR-31/ANSI X9.143 Schlüsselblöcke für die Zahlungsindustrie analysieren.',
      },
      kcv: {
        title: 'KCV-Rechner',
        description: 'Key Check Value (KCV) für AES und DES/3DES Schlüssel berechnen.',
      },
      pinBlock: {
        title: 'PIN-Block Generator',
        description: 'ISO 9564 PIN-Blöcke (Format 0, 1, 3, 4) für Zahlungstransaktionen generieren.',
      },
      hash: {
        title: 'Hash-Rechner',
        description: 'Hash-Werte mit MD5, SHA-1, SHA-256, SHA-512, BLAKE2 und mehr berechnen.',
      },
      encoding: {
        title: 'Zeichencodierung',
        description: 'Konvertierung zwischen ASCII, EBCDIC, Hexadezimal, Binär und ATM-Dezimal.',
      },
      bcd: {
        title: 'BCD Encoder/Decoder',
        description: 'Dezimalzahlen zu BCD kodieren oder BCD zurück zu Dezimal dekodieren.',
      },
      checkDigits: {
        title: 'Prüfziffern',
        description: 'Prüfziffern mit Luhn (MOD 10) und MOD 9 Algorithmen berechnen und verifizieren.',
      },
      base64: {
        title: 'Base64',
        description: 'Daten mit Base64 Binär-zu-Text-Codierung kodieren und dekodieren.',
      },
      base94: {
        title: 'Base94',
        description: 'Kompakte Codierung mit allen 94 druckbaren ASCII-Zeichen.',
      },
      messageParser: {
        title: 'Nachrichtenparser',
        description: 'ATM NDC, Wincor und ISO 8583 Finanznachrichtenformate analysieren.',
      },
      rsaDer: {
        title: 'RSA DER Öffentlicher Schlüssel',
        description: 'RSA öffentliche Schlüssel zwischen Modulus/Exponent und DER-Format kodieren/dekodieren.',
      },
      uuid: {
        title: 'UUID Generator',
        description: 'Universell eindeutige Kennungen (UUID v1, v3, v4, v5) generieren.',
      },
    },
    features: {
      clientSide: {
        title: '100% Clientseitig',
        description: 'Alle kryptografischen Operationen laufen vollständig in Ihrem Browser. Keine Daten werden an Server übertragen.',
      },
      free: {
        title: 'Vollständig kostenlos',
        description: 'Alle Tools sind ohne Registrierung, Login oder Bezahlung kostenlos nutzbar. Keine versteckten Kosten.',
      },
      paymentReady: {
        title: 'Zahlungsindustrie-ready',
        description: 'Spezialisierte Tools für TR-31, KCV, PIN-Block und andere Zahlungssicherheitsoperationen.',
      },
    },
  },
  
  asn1: {
    title: 'ASN.1 Parser',
    description: 'Analysieren Sie ASN.1 DER/BER-Strukturen mit RFC-Definitionsabgleich',
    inputLabel: 'Eingabe (Hex, Base64 oder PEM):',
    inputPlaceholder: 'Hex-, Base64- oder PEM-kodierte ASN.1 BER/DER-Strukturen einfügen oder Datei hochladen',
    withHexDump: 'Hex Dump anzeigen',
    trimBigChunks: 'Große Daten kürzen',
    withDefinitions: 'Definitionsabgleich aktivieren',
    uploadFile: 'Datei hochladen',
    parse: 'Analysieren',
    clear: 'Löschen',
    structureDefinition: 'Strukturdefinition:',
    selectDefinition: 'Strukturdefinition auswählen...',
    parsedResult: 'Analyseergebnis:',
    hexDump: 'Hex Dump:',
    offset: 'Offset',
    length: 'Länge',
    value: 'Wert',
    constructed: 'Konstruiert',
    loadError: 'ASN.1-Parsing-Bibliothek konnte nicht geladen werden',
    inputRequired: 'Bitte ASN.1-Daten eingeben',
    parseError: 'Analyse fehlgeschlagen',
    copied: 'Kopiert',
    copyHex: 'Hex kopieren',
    copyHexDump: 'Hex Dump kopieren',
    copyBase64: 'Base64 kopieren',
    copySubtree: 'Teilbaum kopieren',
    copyValue: 'Wert kopieren',
  },
  
  keyGenerator: {
    title: 'Zufälliger Schlüsselgenerator',
    description: 'Generieren Sie kryptografisch starke Zufallsschlüssel für DES, 3DES oder AES.',
    keyLength: 'Schlüssellänge',
    bytes: 'Bytes',
    bits: 'Bits',
    generateNow: 'Jetzt generieren',
    generatedKey: 'Generierter Schlüssel (Hexadezimal)',
    kcv: 'KCV',
    length: 'Länge',
    tabKeyGen: 'Generator',
    tabCombination: 'Kombination',
    tabParity: 'Parität',
    tabValidation: 'Validierung',
    combinationTitle: 'Schlüsselkombination',
    combinationDesc: 'Kombinieren Sie mehrere Schlüsselkomponenten per XOR',
    component: 'Komponente',
    components: 'Komponenten',
    combinedKey: 'Kombinierter Schlüssel',
    addComponent: 'Hinzufügen',
    removeComponent: 'Entfernen',
    combineKeys: 'Kombinieren',
    errorInvalidComponent: 'Komponente {index} ungültig',
    errorComponentLength: 'Alle Komponenten müssen die gleiche Länge haben',
    errorComponentLength2: 'Länge muss sein',
    errorMinComponents: 'Mindestens 2 Komponenten erforderlich',
    errorMaxComponents: 'Maximal 9 Komponenten erlaubt',
    clearAll: 'Alles löschen',
    parityTitle: 'Paritätsanpassung',
    parityDesc: 'Paritätsbits für DES/3DES-Schlüssel anpassen',
    keyInput: 'Schlüsseleingabe',
    keyInputPlaceholder: 'Hexadezimalen Schlüssel eingeben',
    parityType: 'Paritätstyp',
    odd: 'Ungerade',
    even: 'Gerade',
    adjustParity: 'Anpassen',
    adjustedKey: 'Angepasster Schlüssel',
    validationTitle: 'Schlüsselvalidierung',
    validationDesc: 'Format, Länge und Parität prüfen',
    validateKey: 'Validieren',
    validKey: 'Gültiger Schlüssel',
    invalidKey: 'Ungültiger Schlüssel',
    keyType: 'Schlüsseltyp',
    parityStatus: 'Paritätsstatus',
    parityValid: 'Gültig',
    parityInvalid: 'Ungültig',
  },
  
  kcvCalculator: {
    title: 'KCV-Rechner',
    description: 'Berechnen Sie den Schlüsselprüfwert zur Überprüfung der Schlüsselkorrektheit.',
    algorithm: 'Algorithmus',
    keyInput: 'Schlüssel (Hexadezimal)',
    keyPlaceholder: 'z.B.: 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'KCV berechnen',
    keyCheckValue: 'Schlüsselprüfwert',
    errorInvalidHex: 'Der Schlüssel muss aus gültigen Hexadezimalzeichen bestehen',
    errorDesLength: 'DES/3DES-Schlüssellänge muss 8, 16 oder 24 Bytes betragen',
    errorAesLength: 'AES-Schlüssellänge muss 16, 24 oder 32 Bytes betragen',
    errorCalculation: 'Berechnung fehlgeschlagen, bitte Schlüsselformat überprüfen',
    format: 'Format',
    autoAdjustParity: 'Paritätsbits automatisch anpassen',
    parityAdjustmentHint: 'Einige Schlüssel haben möglicherweise keine korrekten Paritätsbits, aktivieren Sie diese Option zur automatischen Korrektur',
    kcvCalcTitle: 'Berechnung des Schlüsselprüfwerts',
    desCalcDesc: 'Verwenden Sie den Klartext des Schlüssels, um 16 Zeichen lange \'0\' mit dem 3DES-ECB-Algorithmus zu verschlüsseln, und extrahieren Sie dann die ersten sechs Zeichen des verschlüsselten Werts als Schlüsselprüfwert',
    aesCalcDesc: 'Verwenden Sie den Klartext des Schlüssels, um 32 Zeichen lange \'0\' mit dem CMAC-AES-Algorithmus zu verschlüsseln, und extrahieren Sie dann die ersten sechs Zeichen des verschlüsselten Werts als Schlüsselprüfwert',
  },
  
  pinBlock: {
    title: 'PIN-Block-Generator',
    description: 'Generieren Sie ISO-Format-PIN-Blöcke für Zahlungstransaktionen.',
    format: 'PIN-Block-Format',
    pinLabel: 'PIN (4-12 Ziffern)',
    pinPlaceholder: 'z.B.: 1234',
    panLabel: 'PAN (Primäre Kontonummer)',
    panPlaceholder: 'z.B.: 4111111111111111',
    generatePinBlock: 'PIN-Block generieren',
    pinBlockHex: 'PIN-Block (Hexadezimal)',
    errorInvalidPin: 'PIN muss 4-12 Ziffern lang sein',
    errorInvalidPan: 'PAN muss 13-19 Ziffern lang sein',
    errorGeneration: 'Generierung fehlgeschlagen, bitte Eingabe überprüfen',
    errorFormat1: 'ISO Format 1 in Kürze verfügbar...',
    pinLengthHint: 'Unterstützt 4-12 stellige PIN',
    panHint: 'Geben Sie die vollständige Kartennummer ein (13-19 Ziffern), das System extrahiert automatisch die rechtesten 12 Ziffern (ohne Prüfziffer)',
  },
  
  tr31: {
    title: 'TR-31-Schlüsselblock-Analysator',
    description: 'Analysieren und untersuchen Sie TR-31-Format-Schlüsselblöcke (ANSI X9.143-Standard).',
    keyBlock: 'TR-31-Schlüsselblock',
    keyBlockPlaceholder: 'z.B.: B0112P0TE00N0000...',
    parseKeyBlock: 'Schlüsselblock analysieren',
    header: 'Schlüsselblock-Header',
    version: 'Version',
    keyLength: 'Länge',
    keyUsage: 'Schlüsselverwendung',
    mode: 'Modus',
    keyVersion: 'Schlüsselversion',
    exportability: 'Exportierbarkeit',
    characters: 'Zeichen',
    errorTooShort: 'TR-31-Schlüsselblocklänge unzureichend',
    errorParsing: 'Analyse fehlgeschlagen, bitte TR-31-Format überprüfen',
    exportable: 'Exportierbar',
    nonExportable: 'Nicht exportierbar',
    sensitive: 'Sensibel',
    keyBlockFormatHint: 'TR-31 Key Block Format (z.B. B0112P0TE00N...), das System validiert das Format automatisch',
  },
  
  placeholder: {
    title: 'Demnächst verfügbar',
    description: 'Dieses Tool befindet sich in der Entwicklung. Bleiben Sie dran!',
  },

  hash: {
    title: 'Hash-Rechner',
    description: 'Hash-Werte mit verschiedenen Algorithmen wie MD5, SHA-1, SHA-256, SHA-512 berechnen',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    hashType: 'Hash-Typ',
    inputData: 'Eingabedaten',
    hashResult: 'Hash-Ergebnis',
    asciiPlaceholder: 'Textdaten eingeben...',
    hexPlaceholder: 'Hexadezimaldaten eingeben...',
    byteLength: 'Bytes',
    calculate: 'Hash berechnen',
    algorithmInfo: 'Algorithmusinformation',
    outputLength: 'Ausgabelänge',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorOddHex: 'Hexadezimaleingabe muss eine gerade Anzahl von Zeichen haben',
    errorCalculation: 'Hash-Berechnung fehlgeschlagen',
    faqTitle: 'Hash-Rechner FAQ',
    faq1Question: 'Was ist eine Hash-Funktion?',
    faq1Answer: 'Eine Hash-Funktion ist ein mathematischer Algorithmus, der Eingabedaten beliebiger Größe in eine Ausgabe fester Größe (Hash-Wert) umwandelt. Sie ist deterministisch und einseitig.',
    faq2Question: 'Welchen Hash-Algorithmus sollte ich verwenden?',
    faq2Answer: 'Für Sicherheitszwecke verwenden Sie SHA-256 oder SHA-512. MD5 und SHA-1 gelten für kryptografische Zwecke als unsicher, können aber für Prüfsummen verwendet werden.',
    usageTitle: 'Verwendung',
    usage1: 'Eingabetyp auswählen (ASCII-Text oder Hexadezimal)',
    usage2: 'Hash-Algorithmus aus dem Dropdown auswählen',
    usage3: 'Daten in das Eingabefeld eingeben',
    usage4: '"Hash berechnen" klicken, um den Hash-Wert zu generieren',
    hashInfo: 'Hash-Funktionen sind einweg - nicht umkehrbar',
    inputLength: 'Eingabe',
  },

  encoding: {
    title: 'Zeichenkodierung',
    description: 'Zwischen verschiedenen Zeichenkodierungen und Formaten konvertieren',
    encodingType: 'Kodierung',
    data: 'Daten',
    convert: 'Konvertieren',
    result: 'Konvertierungsergebnis',
    conversionInfo: 'Konvertierungsinformation',
    ebcdicInfo: 'EBCDIC wird auf IBM-Großrechnern verwendet',
    atmInfo: 'ATM-Format verwendet durch Leerzeichen getrennte Dezimalwerte (0-255)',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorConversion: 'Konvertierung fehlgeschlagen',
    placeholderBinary: 'Daten eingeben (z.B. 57652C206174...)',
    placeholderHex: 'Hexadezimaldaten eingeben',
    placeholderText: 'ASCII-Text eingeben',
    placeholderAtm: 'Durch Leerzeichen getrennte Dezimalwerte eingeben (z.B. 065 066 067)',
    faqTitle: 'Zeichenkodierung FAQ',
    faq1Question: 'Was ist Zeichenkodierung?',
    faq1Answer: 'Zeichenkodierung ist ein System, das jedes Zeichen mit einer eindeutigen Nummer oder Bytefolge verknüpft, sodass Computer Text speichern und übertragen können.',
    faq2Question: 'Was ist EBCDIC?',
    faq2Answer: 'EBCDIC (Extended Binary Coded Decimal Interchange Code) ist eine 8-Bit-Zeichenkodierung, die hauptsächlich auf IBM-Großrechnern und Midrange-Systemen verwendet wird.',
    usageTitle: 'Verwendung',
    usage1: 'Konvertierungstyp aus dem Dropdown auswählen',
    usage2: 'Daten im entsprechenden Format eingeben',
    usage3: '"Konvertieren" klicken, um das Ergebnis zu sehen',
  },

  bcd: {
    title: 'Binär codierte Dezimalzahl (BCD)',
    description: 'Dezimalzahlen zu BCD kodieren oder BCD zurück zu Dezimal dekodieren',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    inputFormat: 'Eingabeformat',
    binary: 'Binär',
    hexadecimal: 'Hexadezimal',
    data: 'Daten',
    info: 'BCD-Information',
    encodeInfo1: 'Jede Dezimalziffer (0-9) wird als 4 Bits kodiert',
    encodeInfo2: 'Beispiel: 25 → 0010 0101 (binär) / 25 (hex)',
    decodeInfo1: 'Jedes 4-Bit-Nibble muss 0-9 sein (nicht A-F)',
    decodeInfo2: 'Beispiel: 0010 0101 → 25',
    encodeResult: 'BCD-kodiertes Ergebnis',
    decodeResult: 'Dekodierte Dezimalzahl',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidDecimal: 'Ungültige Eingabe: nur Ziffern 0-9 erlaubt',
    errorInvalidBinary: 'Ungültige Binäreingabe (nur 0 und 1, Länge ein Vielfaches von 4)',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorConversion: 'Konvertierung fehlgeschlagen',
    placeholderEncode: 'Dezimalzahl eingeben (z.B. 12345)',
    placeholderBinary: 'BCD-Binär eingeben (z.B. 0010 0101)',
    placeholderHex: 'BCD-Hexadezimal eingeben (z.B. 25)',
    faqTitle: 'BCD FAQ',
    faq1Question: 'Was ist BCD?',
    faq1Answer: 'Binär codierte Dezimalzahl (BCD) ist eine Klasse von Binärkodierungen für Dezimalzahlen, bei der jede Dezimalziffer durch eine feste Anzahl von Bits (normalerweise vier) dargestellt wird.',
    faq2Question: 'Warum wird BCD verwendet?',
    faq2Answer: 'BCD wird in Finanz- und Geschäftsanwendungen verwendet, wo Dezimalpräzision wichtig ist, und in Systemen, die Dezimalziffern direkt anzeigen müssen.',
    usageTitle: 'Verwendung',
    usage1: '"Kodieren" wählen, um Dezimal zu BCD zu konvertieren',
    usage2: '"Dekodieren" wählen, um BCD zurück zu Dezimal zu konvertieren',
    usage3: 'Beim Dekodieren Binär- oder Hexadezimal-Eingabeformat wählen',
  },

  checkDigits: {
    title: 'Prüfziffern',
    description: 'Prüfziffern mit verschiedenen Algorithmen verifizieren oder generieren',
    operation: 'Operation',
    check: 'Prüfen',
    generate: 'Generieren',
    hashType: 'Algorithmus',
    input: 'Eingabe',
    info: 'Algorithmus-Information',
    luhnInfo: 'Luhn-Algorithmus (MOD 10) - Für Kreditkarten, IMEI, etc.',
    amexInfo: 'Amex SE Number (MOD 9) - Ziffernsumme modulo 9',
    checkInfo: 'Vollständige Nummer mit Prüfziffer eingeben',
    generateInfo: 'Nummer ohne Prüfziffer eingeben',
    checkResult: 'Prüfergebnis',
    generateResult: 'Generierte Prüfziffer',
    validResult: 'Gültig - Prüfziffer ist korrekt',
    invalidResult: 'Ungültig - Prüfziffer ist falsch',
    fullNumber: 'Vollständige Nummer',
    errorNoInput: 'Bitte Nummer eingeben',
    errorCalculation: 'Berechnung fehlgeschlagen',
    placeholderCheck: 'Nummer mit Prüfziffer eingeben (z.B. 79927398713)',
    placeholderGenerate: 'Nummer ohne Prüfziffer eingeben (z.B. 7992739871)',
    faqTitle: 'Prüfziffern FAQ',
    faq1Question: 'Was ist eine Prüfziffer?',
    faq1Answer: 'Eine Prüfziffer ist eine Ziffer zur Fehlererkennung, die mit einem bestimmten Algorithmus berechnet wird.',
    faq2Question: 'Was ist der Luhn-Algorithmus?',
    faq2Answer: 'Der Luhn-Algorithmus (MOD 10) ist eine Prüfsummenformel zur Validierung von Kreditkartennummern, IMEI-Nummern und anderen Identifikationsnummern.',
    usageTitle: 'Verwendung',
    usage1: '"Prüfen" wählen, um Nummer mit Prüfziffer zu verifizieren',
    usage2: '"Generieren" wählen, um Prüfziffer zu berechnen',
    usage3: 'Geeigneten Algorithmus für den Anwendungsfall wählen',
  },

  base64: {
    title: 'Base64',
    description: 'Daten zu Base64 kodieren oder Base64 zurück zum Originalformat dekodieren',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    inputEncoding: 'Eingabe-Kodierung',
    outputEncoding: 'Ausgabe-Kodierung',
    hexadecimal: 'HEXADEZIMAL',
    data: 'Daten',
    info: 'Base64-Information',
    encodeInfo1: 'Base64 kodiert Binärdaten in ASCII-Zeichen',
    encodeInfo2: 'Ausgabe ist ~33% größer als Eingabe',
    decodeInfo1: 'Dekodiert Base64 zurück zu Originaldaten',
    decodeInfo2: 'Ausgabeformat wählen: ASCII-Text oder Hexadezimal',
    encodeResult: 'Base64-kodiertes Ergebnis',
    decodeResult: 'Dekodiertes Ergebnis',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorInvalidBase64: 'Ungültige Base64-Eingabe',
    errorEncode: 'Kodierung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
    placeholderAscii: 'Text zum Kodieren eingeben',
    placeholderHex: 'Hexadezimaldaten zum Kodieren eingeben',
    placeholderBase64: 'Base64-String zum Dekodieren eingeben',
    faqTitle: 'Base64 FAQ',
    faq1Question: 'Was ist Base64?',
    faq1Answer: 'Base64 ist ein Binär-zu-Text-Kodierungsschema, das Binärdaten im ASCII-String-Format mit 64 Zeichen darstellt.',
    faq2Question: 'Warum Base64 verwenden?',
    faq2Answer: 'Base64 wird häufig verwendet, um Binärdaten in textbasierte Formate wie JSON, XML oder E-Mail-Anhänge einzubetten.',
    usageTitle: 'Verwendung',
    usage1: '"Kodieren" wählen, um Daten in Base64 zu konvertieren',
    usage2: '"Dekodieren" wählen, um Base64 zurück zu Originaldaten zu konvertieren',
    usage3: 'Eingabe-/Ausgabe-Kodierung wählen: ASCII oder Hexadezimal',
  },

  base94: {
    title: 'Base94',
    description: 'Daten zu Base94 kodieren oder Base94 zurück zum Originalformat dekodieren',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    inputEncoding: 'Eingabe-Kodierung',
    outputEncoding: 'Ausgabe-Kodierung',
    hexadecimal: 'HEXADEZIMAL',
    data: 'Daten',
    info: 'Base94-Information',
    encodeInfo1: 'Verwendet druckbare ASCII-Zeichen (0x20 Leerzeichen bis 0x7E Tilde)',
    encodeInfo2: '5:4 Verhältnis - 4 Bytes zu 5 Zeichen kodiert (25% Overhead)',
    decodeInfo1: 'Dekodiert Base94 zurück zu Originaldaten',
    decodeInfo2: 'Gültige Zeichen: Leerzeichen bis ~ (ASCII 32-126)',
    encodeResult: 'Base94-kodiertes Ergebnis',
    decodeResult: 'Dekodiertes Ergebnis',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorInvalidBase94: 'Ungültige Base94-Eingabe',
    errorEncode: 'Kodierung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
    placeholderAscii: 'Text zum Kodieren eingeben',
    placeholderHex: 'Hexadezimaldaten zum Kodieren eingeben',
    placeholderBase94: 'Base94-String zum Dekodieren eingeben',
    faqTitle: 'Base94 FAQ',
    faq1Question: 'Was ist Base94?',
    faq1Answer: 'Base94 ist eine Binär-zu-Text-Kodierung, die alle 94 druckbaren ASCII-Zeichen (! bis ~) verwendet und effizientere Kodierung als Base64 bietet.',
    faq2Question: 'Warum Base94 statt Base64 verwenden?',
    faq2Answer: 'Base94 hat weniger Overhead (~22%) im Vergleich zu Base64 (~33%), was zu kleinerer kodierter Ausgabe für dieselben Daten führt.',
    usageTitle: 'Verwendung',
    usage1: '"Kodieren" wählen, um Daten in Base94 zu konvertieren',
    usage2: '"Dekodieren" wählen, um Base94 zurück zu Originaldaten zu konvertieren',
    usage3: 'Eingabe-/Ausgabe-Kodierung wählen: ASCII oder Hexadezimal',
  },

  messageParser: {
    title: 'Nachrichten-Parser',
    description: 'ATM- und Finanztransaktionsnachrichten parsen',
    parseMode: 'Parse-Modus',
    hexData: 'Hex-Daten',
    info: 'Parse-Modus-Information',
    ndcDesc: 'NCR NDC/DDC-Protokoll für ATM-Kommunikation',
    wincorDesc: 'Wincor Nixdorf-Protokoll für ATM-Kommunikation',
    iso8583Desc: 'ISO 8583:1987 Finanztransaktions-Nachrichtenformat',
    hexInputInfo: 'Eingabe muss gültige Hexadezimaldaten sein',
    placeholder: 'Hexadezimale Nachrichtendaten zum Parsen eingeben...',
    parsedResult: 'Geparste Ergebnisse',
    fields: 'Felder',
    fieldName: 'Feld',
    length: 'Länge',
    value: 'Wert',
    errorNoInput: 'Bitte Hex-Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorParseFailed: 'Nachricht konnte nicht geparst werden',
    faqTitle: 'Nachrichten-Parser FAQ',
    faq1Question: 'Was ist ATM NDC?',
    faq1Answer: 'NDC (NCR Direct Connect) ist ein Kommunikationsprotokoll, das von NCR-Geldautomaten zur Kommunikation mit Host-Systemen verwendet wird.',
    faq2Question: 'Was ist ISO 8583?',
    faq2Answer: 'ISO 8583 ist ein internationaler Standard für Finanztransaktionskarten-Nachrichten, der für Kartenzahlungstransaktionen verwendet wird.',
    usageTitle: 'Verwendung',
    usage1: 'Geeigneten Parse-Modus auswählen (ATM_NDC, ATM_WINCOR oder ISO_8583_1987)',
    usage2: 'Hexadezimale Nachrichtendaten in das Eingabefeld eingeben',
    usage3: 'Auf Parsen klicken, um geparste Felder und Werte anzuzeigen',
  },

  rsaDer: {
    title: 'RSA DER Öffentlicher Schlüssel',
    description: 'RSA öffentlichen Schlüssel im DER ASN.1 Format kodieren/dekodieren',
    info: 'RSA DER Information',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    modulus: 'Modulus',
    modulusEncoding: 'Modulus-Kodierung',
    exponent: 'Exponent',
    exponentEncoding: 'Exponent-Kodierung',
    modulusNegative: 'Modulus Negativ (vorzeichenlose Kodierung)',
    outputEncoding: 'Ausgabe-Kodierung',
    inputEncoding: 'Eingabe-Kodierung',
    derInput: 'DER/PEM-Eingabe',
    modulusPlaceholder: 'Modulus eingeben (Hex oder Base64)',
    exponentPlaceholder: 'Exponent eingeben (z.B. 010001 für 65537)',
    derInputPlaceholder: 'DER (Hex/Base64) oder PEM-Format öffentlichen Schlüssel eingeben',
    encodeInfo: 'RSA Öffentlicher Schlüssel Kodierung',
    encodeInfo1: 'RSA Modulus und Exponent in DER/PEM-Format kodieren',
    encodeInfo2: 'Unterstützt sowohl vorzeichenbehaftete als auch vorzeichenlose Ganzzahl-Kodierung',
    decodeInfo: 'RSA Öffentlicher Schlüssel Dekodierung',
    decodeInfo1: 'DER/PEM-Format dekodieren, um Modulus und Exponent zu extrahieren',
    decodeInfo2: 'Unterstützt Hex-, Base64- und PEM-Eingabeformate',
    encodeResult: 'Kodiertes Ergebnis',
    decodeResult: 'Dekodiertes Ergebnis',
    errorNoModulus: 'Bitte Modulus eingeben',
    errorNoExponent: 'Bitte Exponent eingeben',
    errorNoInput: 'Bitte DER-Daten eingeben',
    errorInvalidModulusHex: 'Ungültiges Modulus-Hex',
    errorInvalidModulusBase64: 'Ungültiges Modulus-Base64',
    errorInvalidExponentHex: 'Ungültiges Exponent-Hex',
    errorInvalidExponentBase64: 'Ungültiges Exponent-Base64',
    errorInvalidHex: 'Ungültige Hex-Eingabe',
    errorInvalidBase64: 'Ungültige Base64-Eingabe',
    errorEncode: 'Kodierung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
    faqTitle: 'RSA DER Öffentlicher Schlüssel FAQ',
    faq1Question: 'Was ist DER-Kodierung?',
    faq1Answer: 'DER (Distinguished Encoding Rules) ist ein Binärformat zur Kodierung von ASN.1-Datenstrukturen, das häufig für kryptografische Schlüssel und Zertifikate verwendet wird.',
    faq2Question: 'Was ist das PEM-Format?',
    faq2Answer: 'PEM ist eine Base64-kodierte Version von DER mit Kopf- und Fußzeilen, die das Kopieren und Einfügen in Textform erleichtert.',
    usageTitle: 'Verwendung',
    usage1: 'Kodieren: Modulus und Exponent eingeben, um DER/PEM-kodierten öffentlichen Schlüssel zu generieren',
    usage2: 'Dekodieren: DER- oder PEM-Format öffentlichen Schlüssel eingeben, um Modulus und Exponent zu extrahieren',
    usage3: 'Unterstützt Hex- und Base64-Ein-/Ausgabeformate',
  },

  uuid: {
    title: 'UUID-Generator',
    description: 'Universell eindeutige Kennungen (UUID) generieren',
    variant: 'Variante',
    count: 'Anzahl',
    info: 'UUID-Information',
    infoFormat: 'Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36 Zeichen)',
    v1Desc: 'Zeitbasierte UUID mit Zeitstempel und zufälligem Knoten',
    v4Desc: 'Zufällige UUID - am häufigsten verwendet',
    v3Desc: 'Namensbasierte UUID mit MD5-Hash',
    v5Desc: 'Namensbasierte UUID mit SHA-1-Hash',
    generatedUUIDs: 'Generierte UUIDs',
    copyAll: 'Alle kopieren',
    errorInvalidCount: 'Anzahl muss zwischen 1 und 100 liegen',
    errorGenerate: 'Generierung fehlgeschlagen',
    withoutHyphen: 'Ohne "-"',
    maxCount: 'Max. 100',
    faqTitle: 'UUID FAQ',
    faq1Question: 'Was ist UUID?',
    faq1Answer: 'UUID (Universally Unique Identifier) ist ein 128-Bit-Bezeichner, der über Raum und Zeit eindeutig ist und häufig in verteilten Systemen verwendet wird.',
    faq2Question: 'Welche UUID-Version sollte ich verwenden?',
    faq2Answer: 'Version 4 (zufällig) wird am häufigsten verwendet. Version 1 ist zeitbasiert, während Versionen 3 und 5 namensbasiert sind und MD5 bzw. SHA-1 verwenden.',
    usageTitle: 'Verwendung',
    usage1: 'UUID-Variante/Version auswählen',
    usage2: 'Anzahl der zu generierenden UUIDs eingeben (1-100)',
    usage3: 'Auf Generieren klicken, um UUIDs zu erstellen',
  },

  cipher: {
    title: 'AES Verschlüsselung/Entschlüsselung',
    description: 'Daten mit AES-Algorithmus verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    aesInfo: 'AES-Informationen',
    keyLengthInfo: 'Schlüssellänge muss dem gewählten Algorithmus entsprechen',
    ivInfo: 'IV (Initialisierungsvektor) muss 16 Bytes betragen',
    paddingInfo: 'Verwendet PKCS7-Padding',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} sein',
    errorDataRequired: 'Daten erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für ECB/KCV-Modus nicht erforderlich',
    kcvInfo: 'KCV: Nullen verschlüsseln und erste 6 Hex-Zeichen nehmen',
    calculateKcv: 'KCV berechnen',
    noPaddingInfo: 'Kein Padding - Datenlänge muss ein Vielfaches von 16 Bytes sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 16 Bytes sein',
    kcvNoDataNeeded: 'Für KCV-Berechnung keine Daten erforderlich',
    kcvDataHint: 'KCV wird mit Nullen berechnet, keine Dateneingabe erforderlich',
    errorKcvCalculation: 'KCV-Berechnung fehlgeschlagen',
    kcvResult: 'KCV-Ergebnis',
  },

  des: {
    title: 'DES / 3DES Verschlüsselung/Entschlüsselung',
    description: 'Daten mit DES oder 3DES Algorithmus verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    padding: 'Padding',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    desInfo: 'DES/3DES Informationen',
    keyLengthInfoDes: 'DES benötigt einen 8-Byte (64-Bit) Schlüssel',
    keyLengthInfo3Des: '3DES benötigt einen 16 oder 24-Byte Schlüssel',
    ivInfo: 'IV (Initialisierungsvektor) muss 8 Bytes betragen',
    blockSizeInfo: 'Blockgröße ist 8 Bytes',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLengthDes: 'DES Schlüssellänge muss 8 Bytes sein',
    errorKeyLength3Des: '3DES Schlüssellänge muss 16 oder 24 Bytes sein',
    errorDataRequired: 'Daten erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 8 Bytes sein bei keinem Padding',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für ECB-Modus nicht erforderlich',
    paddingNone: 'Kein Padding',
    paddingZeros: 'Mit 0x00 auffüllen',
    paddingSpaces: 'Mit Leerzeichen 0x20 auffüllen',
    paddingANSIX923: 'Letztes Byte ist Padding-Länge, Rest mit 0x00 gefüllt',
    paddingISO10126: 'Letztes Byte ist Padding-Länge, Rest mit Zufallsbytes gefüllt',
    paddingPKCS5: 'Jeder Padding-Byte-Wert entspricht der Padding-Länge',
    paddingPKCS7: 'Wie PKCS#5',
    paddingISO7816: '0x80 hinzufügen, dann mit 0x00 auffüllen',
    paddingRijndael: 'Wie Zero Padding',
    paddingISO9797M1: 'Mit 0x00 auf Blockgröße auffüllen',
    paddingISO9797M2: 'Wie ISO 7816-4',
    mode8BitNote: 'Hinweis: 8-Bit-Modus verarbeitet 1 Byte pro Durchgang',
    mode64BitNote: '64-Bit-Modus verarbeitet vollständigen Block (8 Bytes) pro Durchgang',
  },

  rsa: {
    title: 'RSA Verschlüsselung/Entschlüsselung',
    description: 'RSA asymmetrische Verschlüsselung, Entschlüsselung, Signierung und Verifizierung',
    rsaInfo: 'RSA Information',
    rsaInfo1: 'RSA ist ein asymmetrischer Verschlüsselungsalgorithmus',
    rsaInfo2: 'Schlüsselgrößen: 1024, 2048, 4096 Bit (2048+ empfohlen)',
    rsaInfo3: 'PKCS#1 v1.5 und OAEP Padding unterstützt',
    tabKeys: 'Schlüssel',
    tabEncrypt: 'Verschlüsseln',
    tabDecrypt: 'Entschlüsseln',
    tabSign: 'Signieren',
    tabVerify: 'Verifizieren',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA-Modul in Hexadezimal',
    privateExpPlaceholder: 'RSA privater Exponent in Hexadezimal',
    keyLength: 'Schlüssellänge',
    generateKeys: 'Schlüssel generieren',
    importKeys: 'Schlüssel importieren',
    clearKeys: 'Löschen',
    keyGenerated: 'Schlüsselpaar erfolgreich generiert',
    keysCleared: 'Schlüssel gelöscht',
    keyImported: 'Öffentlicher Schlüssel erfolgreich importiert',
    privateKeyImportNote: 'Privater Schlüsselimport erfordert vollständige CRT-Parameter. Verwenden Sie "Schlüssel generieren" für volle Funktionalität.',
    padding: 'Padding',
    hashAlgorithm: 'Hash-Algorithmus',
    data: 'Daten',
    dataToEncrypt: 'Zu verschlüsselnde Daten',
    dataPlaceholderAscii: 'Textdaten eingeben',
    encodingMethod: 'Kodierungsmethode',
    private: 'Privat',
    public: 'Öffentlich',
    inputDataFormat: 'Eingabedatenformat',
    hexadecimal: 'Hexadezimal',
    paddingMethod: 'Padding-Methode',
    noPadding: 'Kein Padding',
    errorDataRequired: 'Daten erforderlich',
    privateEncryptNote: 'Hinweis: Verwendung des öffentlichen Schlüssels zur Verschlüsselung',
    dataToSign: 'Zu signierende Daten',
    dataToVerify: 'Zu verifizierende Daten',
    ciphertextToDecrypt: 'Zu entschlüsselnder Chiffretext',
    signatureToVerify: 'Signatur',
    dataPlaceholder: 'Hexadezimale Daten eingeben',
    ciphertextPlaceholder: 'Verschlüsselte Hexadezimaldaten eingeben',
    signaturePlaceholder: 'Signatur in Hexadezimal eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    sign: 'Signieren',
    verify: 'Verifizieren',
    encryptedResult: 'Verschlüsseltes Ergebnis',
    encryptionFinished: 'Datenverschlüsselung abgeschlossen',
    decryptionFinished: 'Datenentschlüsselung abgeschlossen',
    decodingMethod: 'Dekodierungsmethode',
    copyResult: 'Ergebnis kopieren',
    result: 'ERGEBNIS',
    decryptedResult: 'Entschlüsseltes Ergebnis',
    signatureResult: 'Signatur',
    signatureValid: '✓ Signatur ist gültig',
    signatureInvalid: '✗ Signatur ist ungültig',
    encryptInfo: 'RSA Verschlüsselung',
    encryptDesc: 'Daten mit dem öffentlichen Schlüssel verschlüsseln',
    decryptInfo: 'RSA Entschlüsselung',
    decryptDesc: 'Daten mit dem privaten Schlüssel entschlüsseln',
    signInfo: 'RSA Signatur',
    signDesc: 'Daten mit dem privaten Schlüssel signieren (RSA-PSS)',
    verifyInfo: 'RSA Signaturverifizierung',
    verifyDesc: 'Signatur mit dem öffentlichen Schlüssel verifizieren (RSA-PSS)',
    oaepDesc1: 'OAEP ist ein Padding-Schema für RSA-Verschlüsselung',
    oaepDesc2: 'Sicherer als PKCS#1 v1.5 Padding',
    oaepDesc3: 'Verhindert Chosen-Ciphertext-Angriffe',
    oaepDesc4: 'Empfohlen für neue Anwendungen',
    oaepStructure: 'OAEP Struktur',
    maxDataSize: 'Maximale Datengröße',
    errorKeyGen: 'Schlüsselgenerierung fehlgeschlagen',
    errorKeyImport: 'Schlüsselimport fehlgeschlagen',
    errorInvalidModulus: 'Ungültiges Modul',
    errorInvalidPublicExp: 'Ungültiger öffentlicher Exponent',
    errorNoPublicKey: 'Bitte generieren oder importieren Sie zuerst einen öffentlichen Schlüssel',
    errorNoPrivateKey: 'Bitte generieren Sie zuerst ein Schlüsselpaar (privater Schlüssel erforderlich)',
    errorInvalidData: 'Ungültige Daten (muss hexadezimal sein)',
    errorInvalidCiphertext: 'Ungültiger Chiffretext (muss hexadezimal sein)',
    errorInvalidSignature: 'Ungültige Signatur (muss hexadezimal sein)',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorSign: 'Signierung fehlgeschlagen',
    errorVerify: 'Verifizierung fehlgeschlagen',
  },

  fpe: {
    title: 'Format-erhaltende Verschlüsselung',
    description: 'Daten verschlüsseln unter Beibehaltung von Format und Länge (NIST SP 800-38G)',
    radix: 'Basis',
    encryptionType: 'Verschlüsselungstyp',
    keyInput: 'Schlüsseleingabe',
    useTweak: 'Tweak verwenden?',
    fpeInfo: 'FPE-Informationen',
    formatPreserving: 'Format-erhaltend: Ausgabe hat das gleiche Format und die gleiche Länge wie die Eingabe',
    radixInfo: 'Die aktuelle Basis definiert den gültigen Zeichensatz für Daten',
    tweakInfo: 'Tweak bietet zusätzliche Eingabe für die Verschlüsselung (wie ein IV)',
    minLength: 'Minimale Datenlänge: 2 Zeichen',
    dataPlaceholder: 'Daten mit gültigen Basis-Zeichen eingeben',
    tweakPlaceholderFF1: 'Tweak in Hexadezimal eingeben (beliebige Länge)',
    tweakPlaceholderFF3: '16 Hex-Zeichen (8 Bytes)',
    resultLength: 'Länge',
    characters: 'Zeichen',
    algorithm: 'Algorithmus',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} sein',
    errorDataRequired: 'Daten erforderlich',
    errorDataTooShort: 'Daten müssen mindestens 2 Zeichen lang sein',
    errorInvalidDataForRadix: 'Daten enthalten ungültige Zeichen für Basis {radix}',
    errorInvalidTweakHex: 'Tweak muss gültiges Hexadezimal sein',
    errorTweakLength: 'Tweak-Länge muss {length} Bytes für {algorithm} sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    algorithmNotImplemented: 'Dieser Algorithmus ist noch nicht vollständig implementiert',
  },

  // SEO Content
  seo: {
    home: {
      title: 'HSM Kit - Kostenlose Online-Verschlüsselung & Schlüsselverwaltung',
      description: 'Kostenlose Online-Kryptografie-Tools für HSM-Schlüsselverwaltung. KCV berechnen, TR-31 Schlüsselblöcke parsen, sichere Schlüssel generieren, AES/DES/RSA-Verschlüsselung und mehr. Alle Berechnungen erfolgen clientseitig für maximale Sicherheit.',
      keywords: 'HSM Tools, Verschlüsselungs-Toolkit, Schlüsselverwaltung, KCV Rechner, TR-31 Parser, AES Verschlüsselung, DES Verschlüsselung, RSA Verschlüsselung, PIN Block, Schlüsselgenerator, Kryptografie-Tools, Zahlungssicherheit',
      faqTitle: 'Häufig gestellte Fragen',
      usageTitle: 'Über HSM Kit',
      faqs: [
        { question: 'Ist HSM Kit kostenlos?', answer: 'Ja, HSM Kit ist vollständig kostenlos. Alle Tools sind ohne Registrierung oder Zahlung verfügbar.' },
        { question: 'Sind meine Daten sicher?', answer: 'Absolut. Alle kryptografischen Operationen werden vollständig in Ihrem Browser (clientseitig) durchgeführt. Keine Daten werden jemals an unsere Server gesendet.' },
        { question: 'Welche Verschlüsselungsalgorithmen werden unterstützt?', answer: 'HSM Kit unterstützt AES (128/192/256-Bit), DES, 3DES, RSA, ECC (ECDSA) und Format-Preserving Encryption (FPE).' },
        { question: 'Kann ich HSM Kit für Zahlungssicherheit verwenden?', answer: 'Ja, HSM Kit enthält Tools speziell für Zahlungssicherheit, einschließlich PIN Block Generierung, TR-31 Schlüsselblock-Parsing und KCV-Berechnung.' },
      ],
      usage: [
        'HSM Kit ist eine umfassende Suite von Kryptografie-Tools für Sicherheitsexperten, Entwickler und alle, die mit Verschlüsselung arbeiten.',
        'Alle Tools arbeiten vollständig in Ihrem Browser - keine Server-Kommunikation bedeutet, dass Ihre sensiblen Daten Ihr Gerät nie verlassen.',
        'Perfekt für Tests, Entwicklung und Bildungszwecke im Bereich Kryptografie und Zahlungssicherheit.',
      ],
    },
    asn1: {
      title: 'ASN.1 Parser Online - Kostenloser DER/BER Struktur-Decoder | HSM Kit',
      description: 'Kostenloser Online ASN.1 Parser und Decoder. ASN.1 DER/BER Strukturen parsen, X.509 Zertifikate decodieren, PKCS Formate analysieren. Unterstützt Hex, Base64 und PEM Eingabe mit RFC-Definition-Matching.',
      keywords: 'ASN.1 Parser, DER Decoder, BER Decoder, X.509 Zertifikat Parser, PKCS Decoder, ASN1 Online Tool, Zertifikat Analyzer, PEM Parser',
      faqTitle: 'ASN.1 Parser FAQ',
      usageTitle: 'ASN.1 Parser Anleitung',
      faqs: [
        { question: 'Was ist ASN.1?', answer: 'ASN.1 (Abstract Syntax Notation One) ist eine Standard-Schnittstellenbeschreibungssprache zur Definition von Datenstrukturen, die serialisiert und deserialisiert werden können. Es wird weitverbreitet in Kryptografie, Telekommunikation und Netzwerkprotokollen verwendet.' },
        { question: 'Welche Formate unterstützt dieser Parser?', answer: 'Dieser Parser unterstützt DER (Distinguished Encoding Rules) und BER (Basic Encoding Rules) kodierte ASN.1 Strukturen. Sie können Daten im Hexadezimal-, Base64- oder PEM-Format eingeben.' },
        { question: 'Kann ich X.509 Zertifikate parsen?', answer: 'Ja, dieses Tool kann X.509 Zertifikate, CSRs, PKCS#7/8/12 Strukturen und andere Zertifikatformate parsen, die ASN.1 Kodierung verwenden.' },
        { question: 'Was ist die Hex-Dump Funktion?', answer: 'Die Hex-Dump Funktion zeigt die rohen Bytes der ASN.1 Struktur neben der geparsten Baumansicht, was das Verständnis der binären Kodierung erleichtert.' },
      ],
      usage: [
        'Fügen Sie Ihre ASN.1 kodierten Daten im Hexadezimal-, Base64- oder PEM-Format in das Eingabefeld ein.',
        'Klicken Sie auf "Parsen" um die Struktur zu decodieren und die hierarchische Baumdarstellung anzuzeigen.',
        'Aktivieren Sie "mit Hex-Dump" um die rohen Bytes neben der geparsten Struktur zu sehen.',
        'Verwenden Sie "mit Definitionen" um die Struktur mit bekannten RFC-Definitionen wie X.509, PKCS usw. abzugleichen.',
      ],
    },
    aes: {
      title: 'AES Verschlüsselung Online - Kostenloser AES Rechner | HSM Kit',
      description: 'Kostenloses Online AES Verschlüsselungs- und Entschlüsselungs-Tool. Unterstützt AES-128, AES-192, AES-256 mit ECB, CBC, CFB, OFB, CTR Modi. KCV berechnen, Hex- oder Textdaten sicher im Browser verschlüsseln/entschlüsseln.',
      keywords: 'AES Verschlüsselung, AES Entschlüsselung, AES-128, AES-192, AES-256, AES Rechner, AES Online Tool, AES ECB, AES CBC, AES KCV',
      faqTitle: 'AES Verschlüsselung FAQ',
      usageTitle: 'AES Verschlüsselungs-Tool Anleitung',
      faqs: [
        { question: 'Was ist AES Verschlüsselung?', answer: 'AES (Advanced Encryption Standard) ist eine symmetrische Blockchiffre, die zum weltweiten Standard für Verschlüsselung geworden ist. Es verschlüsselt Daten in 128-Bit Blöcken mit Schlüsseln von 128, 192 oder 256 Bit.' },
        { question: 'Welchen AES Modus sollte ich verwenden?', answer: 'CBC Modus wird üblicherweise für die meisten Anwendungen empfohlen. ECB Modus sollte für Daten größer als ein Block vermieden werden, da er Muster offenbart. CTR Modus ist gut für Streaming-Daten.' },
        { question: 'Welche Schlüsselgrößen unterstützt AES?', answer: 'AES unterstützt drei Schlüsselgrößen: AES-128 (16 Bytes), AES-192 (24 Bytes) und AES-256 (32 Bytes). Längere Schlüssel bieten stärkere Sicherheit.' },
        { question: 'Was ist IV bei AES Verschlüsselung?', answer: 'IV (Initialisierungsvektor) ist ein zufälliger Wert, der mit Modi wie CBC, CFB, OFB und CTR verwendet wird, um sicherzustellen, dass identische Klartexte unterschiedliche Chiffretexte erzeugen. IV sollte einzigartig sein, muss aber nicht geheim sein.' },
      ],
      usage: [
        'Wählen Sie die AES Schlüsselgröße (128, 192 oder 256 Bit) und den Verschlüsselungsmodus (ECB, CBC, usw.).',
        'Geben Sie Ihren Verschlüsselungsschlüssel im Hexadezimalformat ein.',
        'Für Modi außer ECB geben Sie einen IV (16 Bytes in Hex) an.',
        'Geben Sie Ihre Daten zum Verschlüsseln oder Entschlüsseln ein und klicken Sie auf die entsprechende Schaltfläche.',
      ],
    },
    des: {
      title: 'DES/3DES Verschlüsselung Online - Kostenloser Triple DES Rechner | HSM Kit',
      description: 'Kostenloses Online DES und Triple DES (3DES) Verschlüsselungs- und Entschlüsselungs-Tool. Unterstützt DES, 2-Key 3DES, 3-Key 3DES mit ECB/CBC Modi. Mehrere Padding-Optionen einschließlich PKCS5, ISO 7816 und mehr.',
      keywords: 'DES Verschlüsselung, 3DES Verschlüsselung, Triple DES, DES Entschlüsselung, DES Rechner, 3DES Online Tool, TDES, DES ECB, DES CBC',
      faqTitle: 'DES/3DES Verschlüsselung FAQ',
      usageTitle: 'DES/3DES Tool Anleitung',
      faqs: [
        { question: 'Was ist der Unterschied zwischen DES und 3DES?', answer: 'DES verwendet einen einzelnen 56-Bit Schlüssel (8 Bytes mit Parität), während 3DES den DES-Algorithmus dreimal mit zwei oder drei verschiedenen Schlüsseln (16 oder 24 Bytes) anwendet und viel stärkere Sicherheit bietet.' },
        { question: 'Ist DES noch sicher?', answer: 'Einzel-DES gilt als unsicher und veraltet. 3DES wird noch in Legacy-Systemen verwendet, besonders in der Zahlungsbranche, aber AES wird für neue Anwendungen empfohlen.' },
        { question: 'Was sind Paritätsbits in DES-Schlüsseln?', answer: 'Bei DES hat jedes Byte des Schlüssels ein Paritätsbit (das niedrigstwertige Bit), wodurch die effektive Schlüssellänge von 64 Bit auf 56 Bit reduziert wird. Dieses Tool kann Paritätsbits automatisch anpassen.' },
        { question: 'Welches Padding sollte ich verwenden?', answer: 'PKCS5/PKCS7 ist die häufigste Wahl. ISO 9797 wird oft in Bankanwendungen verwendet. Die Wahl sollte mit dem übereinstimmen, was Ihre Gegenseite erwartet.' },
      ],
      usage: [
        'Wählen Sie DES (8 Bytes Schlüssel) oder 3DES (16 oder 24 Bytes Schlüssel).',
        'Wählen Sie den Verschlüsselungsmodus (ECB oder CBC) und die Padding-Methode.',
        'Geben Sie Ihren Schlüssel im Hexadezimalformat ein.',
        'Für CBC Modus geben Sie einen IV (8 Bytes in Hex) an.',
        'Geben Sie Daten ein und klicken Sie auf Verschlüsseln oder Entschlüsseln.',
      ],
    },
    rsa: {
      title: 'RSA Verschlüsselung Online - Kostenloser RSA Rechner & Schlüsselgenerator | HSM Kit',
      description: 'Kostenloses Online RSA Verschlüsselungs-, Entschlüsselungs-, Signatur- und Verifizierungs-Tool. Generieren Sie RSA Schlüsselpaare (1024-4096 Bit), verschlüsseln Sie mit dem öffentlichen Schlüssel, signieren Sie mit dem privaten Schlüssel. Unterstützt PKCS#1 und OAEP Padding.',
      keywords: 'RSA Verschlüsselung, RSA Entschlüsselung, RSA Schlüsselgenerator, RSA Rechner, RSA Online Tool, RSA Signatur, RSA Verifizierung, Public Key Verschlüsselung, PKCS1, OAEP',
      faqTitle: 'RSA Verschlüsselung FAQ',
      usageTitle: 'RSA Tool Anleitung',
      faqs: [
        { question: 'Was ist RSA Verschlüsselung?', answer: 'RSA ist ein asymmetrischer Verschlüsselungsalgorithmus, der ein Schlüsselpaar verwendet - einen öffentlichen Schlüssel zur Verschlüsselung und einen privaten Schlüssel zur Entschlüsselung. Er wird weitverbreitet für sichere Datenübertragung und digitale Signaturen verwendet.' },
        { question: 'Welche Schlüsselgröße sollte ich verwenden?', answer: 'Für aktuelle Sicherheitsstandards gelten 2048-Bit Schlüssel als Minimum. 4096-Bit Schlüssel werden für langfristige Sicherheit empfohlen. 1024-Bit Schlüssel sind veraltet.' },
        { question: 'Was ist der Unterschied zwischen PKCS#1 und OAEP?', answer: 'PKCS#1 v1.5 ist ein älteres Padding-Schema. OAEP (Optimal Asymmetric Encryption Padding) ist sicherer und wird für neue Anwendungen empfohlen, da es bestimmte Angriffe verhindert.' },
        { question: 'Was ist die maximale Datengröße für RSA Verschlüsselung?', answer: 'RSA kann nur Daten verschlüsseln, die kleiner sind als die Schlüsselgröße minus Padding-Overhead. Für einen 2048-Bit Schlüssel mit OAEP-SHA256 sind es maximal etwa 190 Bytes. Verwenden Sie hybride Verschlüsselung für größere Daten.' },
      ],
      usage: [
        'Generieren Sie ein neues RSA Schlüsselpaar oder importieren Sie vorhandene Schlüssel.',
        'Für Verschlüsselung: Klartext eingeben und Verschlüsseln klicken (verwendet öffentlichen Schlüssel).',
        'Für Entschlüsselung: Chiffretext eingeben und Entschlüsseln klicken (erfordert privaten Schlüssel).',
        'Für Signatur: Daten-Hash eingeben und Signieren klicken (erfordert privaten Schlüssel).',
        'Für Verifizierung: Daten, Signatur eingeben und Verifizieren klicken (verwendet öffentlichen Schlüssel).',
      ],
    },
    ecc: {
      title: 'ECC/ECDSA Online Tool - Elliptische Kurven Kryptografie | HSM Kit',
      description: 'Kostenloses Online ECC (Elliptische Kurven Kryptografie) Tool. Generieren Sie ECDSA Schlüsselpaare, signieren und verifizieren Sie Daten mit secp256k1, P-256, P-384 Kurven. Kompakte Schlüssel mit starker Sicherheit.',
      keywords: 'ECC Verschlüsselung, ECDSA, elliptische Kurve, secp256k1, P-256, P-384, ECC Schlüsselgenerator, ECDSA Signatur, ECDSA Verifizierung, Bitcoin Kryptografie',
      faqTitle: 'ECC/ECDSA FAQ',
      usageTitle: 'ECC/ECDSA Tool Anleitung',
      faqs: [
        { question: 'Was ist ECC?', answer: 'Elliptische Kurven Kryptografie (ECC) ist ein Ansatz zur Public-Key-Kryptografie basierend auf der algebraischen Struktur elliptischer Kurven. Es bietet äquivalente Sicherheit zu RSA mit viel kleineren Schlüsselgrößen.' },
        { question: 'Was ist secp256k1?', answer: 'secp256k1 ist die elliptische Kurve, die von Bitcoin und Ethereum für ihre digitalen Signaturen verwendet wird. Sie bietet eine gute Balance zwischen Sicherheit und Performance.' },
        { question: 'Warum ECC statt RSA verwenden?', answer: 'ECC bietet das gleiche Sicherheitsniveau wie RSA mit viel kleineren Schlüsseln (256-Bit ECC ≈ 3072-Bit RSA), was zu schnelleren Operationen und geringerem Speicher-/Bandbreitenbedarf führt.' },
        { question: 'Was ist ECDSA?', answer: 'ECDSA (Elliptic Curve Digital Signature Algorithm) ist der auf ECC basierende Signaturalgorithmus. Er wird verwendet, um digitale Signaturen zu erstellen, die die Authentizität von Daten verifizieren können.' },
      ],
      usage: [
        'Wählen Sie die elliptische Kurve (secp256k1, P-256 oder P-384).',
        'Generieren Sie ein neues Schlüsselpaar oder importieren Sie vorhandene Schlüssel.',
        'Für Signatur: Daten (oder deren Hash) eingeben und Signieren klicken.',
        'Für Verifizierung: Originaldaten, Signatur eingeben und Verifizieren klicken.',
      ],
    },
    fpe: {
      title: 'Format-Preserving Encryption (FPE) Online - FF1/FF3-1 Tool | HSM Kit',
      description: 'Kostenloses Online Format-Preserving Encryption Tool gemäß NIST SP 800-38G. Verschlüsseln Sie Daten unter Beibehaltung von Format und Länge. Ideal für die Tokenisierung von Kreditkartennummern, Sozialversicherungsnummern und anderen strukturierten Daten.',
      keywords: 'FPE, Format Preserving Encryption, FF1, FF3, FF3-1, NIST 800-38G, Tokenisierung, Kreditkarten Verschlüsselung, Datenmaskierung, PCI DSS',
      faqTitle: 'Format-Preserving Encryption FAQ',
      usageTitle: 'FPE Tool Anleitung',
      faqs: [
        { question: 'Was ist Format-Preserving Encryption?', answer: 'FPE ist eine Verschlüsselungsmethode, die Chiffretext im gleichen Format und mit gleicher Länge wie der Klartext erzeugt. Beispielsweise wird eine 16-stellige Kreditkartennummer zu einer anderen 16-stelligen Nummer verschlüsselt.' },
        { question: 'Was ist der Unterschied zwischen FF1 und FF3-1?', answer: 'Beide sind NIST-genehmigte FPE-Algorithmen. FF1 unterstützt Tweaks variabler Länge, während FF3-1 einen festen 56-Bit Tweak verwendet. FF3-1 ist im Allgemeinen schneller, hat aber mehr Einschränkungen.' },
        { question: 'Was ist Tokenisierung?', answer: 'Tokenisierung ersetzt sensible Daten durch nicht-sensible Platzhalter (Token). FPE wird oft für Tokenisierung verwendet, da die Token das ursprüngliche Datenformat beibehalten.' },
        { question: 'Ist FPE PCI DSS konform?', answer: 'Ja, FPE mit NIST SP 800-38G genehmigten Algorithmen (FF1, FF3-1) wird bei korrekter Implementierung für PCI DSS Compliance akzeptiert.' },
      ],
      usage: [
        'Wählen Sie den FPE-Algorithmus (FF1 oder FF3-1) und den Radix (Zahlenbasis).',
        'Geben Sie Ihren AES-Schlüssel (16, 24 oder 32 Bytes in Hex) ein.',
        'Optional einen Tweak-Wert für zusätzliche Sicherheit angeben.',
        'Klartext-Daten eingeben und Verschlüsseln klicken, um format-erhaltenden Chiffretext zu generieren.',
      ],
    },
    keyGenerator: {
      title: 'Sicherer Schlüsselgenerator Online - Zufalls AES/DES Schlüsselgenerator | HSM Kit',
      description: 'Kostenloser Online kryptografischer Schlüsselgenerator. Generieren Sie sichere Zufallsschlüssel für AES, DES, 3DES Verschlüsselung. Schlüsselkombination (XOR), Paritätsanpassung und Schlüsselvalidierungs-Tools enthalten.',
      keywords: 'Schlüsselgenerator, Zufallsschlüssel, AES Schlüsselgenerator, DES Schlüsselgenerator, 3DES Schlüsselgenerator, kryptografischer Schlüssel, sicherer Zufall, Schlüsselkombination, XOR Schlüssel',
      faqTitle: 'Schlüsselgenerator FAQ',
      usageTitle: 'Schlüsselgenerator Anleitung',
      faqs: [
        { question: 'Wie werden die Zufallsschlüssel generiert?', answer: 'Schlüssel werden mit der Web Crypto API (crypto.getRandomValues) generiert, die kryptografisch sichere Zufallszahlen bereitstellt, die für Verschlüsselungsschlüssel geeignet sind.' },
        { question: 'Was ist Schlüsselkombination (XOR)?', answer: 'Schlüsselkombination ermöglicht es Ihnen, mehrere Schlüsselkomponenten zu XOR-en, um einen vollständigen Schlüssel zu bilden. Dies wird häufig bei Zeremonien verwendet, bei denen mehrere Verwahrer jeweils eine Komponente halten.' },
        { question: 'Was sind Paritätsbits?', answer: 'Bei DES/3DES-Schlüsseln hat jedes Byte ein Paritätsbit zur Fehlererkennung. Dieses Tool kann Paritätsbits automatisch auf ungerade Parität anpassen, wie vom DES-Standard gefordert.' },
        { question: 'Welche Schlüssellängen werden unterstützt?', answer: 'Der Generator unterstützt DES (8 Bytes/64 Bit), 2-Key 3DES (16 Bytes/128 Bit), 3-Key 3DES (24 Bytes/192 Bit) und AES-128/192/256.' },
      ],
      usage: [
        'Wählen Sie die gewünschte Schlüssellänge aus dem Dropdown.',
        'Klicken Sie auf "Generieren" um einen neuen Zufallsschlüssel zu erstellen.',
        'Verwenden Sie den Tab Schlüsselkombination um mehrere Komponenten zu XOR-en.',
        'Verwenden Sie den Tab Parität um DES/3DES Schlüssel-Paritätsbits anzupassen.',
        'Verwenden Sie den Tab Validierung um zu prüfen, ob ein Schlüssel korrektes Format und Parität hat.',
      ],
    },
    tr31: {
      title: 'TR-31 Schlüsselblock Parser Online - ANSI X9.143 Decoder | HSM Kit',
      description: 'Kostenloser Online TR-31 Schlüsselblock Parser und Analyzer. Decodieren Sie ANSI X9.143 (TR-31) Schlüsselblöcke, zeigen Sie Version, Schlüsselverwendung, Algorithmus, Exportierbarkeit und optionale Blöcke an. Essentielles Tool für Zahlungs-HSM-Operationen.',
      keywords: 'TR-31, Schlüsselblock, ANSI X9.143, TR31 Parser, Schlüsselblock Decoder, Zahlungs-HSM, Schlüsselverwendung, Schlüssel-Exportierbarkeit, DUKPT, Schlüsselverwaltung',
      faqTitle: 'TR-31 Schlüsselblock FAQ',
      usageTitle: 'TR-31 Parser Anleitung',
      faqs: [
        { question: 'Was ist TR-31?', answer: 'TR-31 (jetzt ANSI X9.143) ist ein Standardformat für sicheren Schlüsselaustausch in der Zahlungsbranche. Es umhüllt Verschlüsselungsschlüssel mit Metadaten einschließlich Schlüsselverwendung, Algorithmus und Exportierbarkeitsregeln.' },
        { question: 'Welche TR-31 Versionen gibt es?', answer: 'Version A/B verwenden TDES Schlüsselumhüllung, Version C verwendet TDES mit Variantenbindung, Version D verwendet AES Schlüsselumhüllung (sicherste), und Version E verwendet AES mit Variantenbindung.' },
        { question: 'Was ist Schlüsselverwendung in TR-31?', answer: 'Schlüsselverwendung (2 Zeichen wie P0, B0, D0) definiert, wie der umhüllte Schlüssel verwendet werden kann - P0 für PIN-Verschlüsselung, B0 für BDK (Base Derivation Key), D0 für Datenverschlüsselung, usw.' },
        { question: 'Was ist Exportierbarkeit?', answer: 'Das Exportierbarkeits-Flag zeigt an, ob der Schlüssel exportiert werden kann: E=Exportierbar, N=Nicht exportierbar, S=Sensitiv (unter bestimmten Bedingungen exportierbar).' },
      ],
      usage: [
        'Fügen Sie Ihren TR-31 Schlüsselblock-String in das Eingabefeld ein.',
        'Klicken Sie auf "Schlüsselblock parsen" um die Struktur zu decodieren.',
        'Sehen Sie die Header-Informationen einschließlich Version, Länge und Schlüsselverwendung.',
        'Untersuchen Sie Algorithmus, Modus, Schlüsselversion und Exportierbarkeits-Einstellungen.',
      ],
    },
    kcv: {
      title: 'KCV Rechner Online - Key Check Value Generator | HSM Kit',
      description: 'Kostenloser Online KCV (Key Check Value) Rechner für AES und DES/3DES Schlüssel. Verifizieren Sie die Korrektheit von Verschlüsselungsschlüsseln durch Berechnung des Prüfwerts. Unterstützt automatische Paritätsanpassung für DES-Schlüssel.',
      keywords: 'KCV Rechner, Key Check Value, KCV Generator, AES KCV, DES KCV, 3DES KCV, CMAC, Schlüsselverifizierung, Zahlungsschlüssel',
      faqTitle: 'KCV Rechner FAQ',
      usageTitle: 'KCV Rechner Anleitung',
      faqs: [
        { question: 'Was ist KCV (Key Check Value)?', answer: 'KCV ist eine Prüfsumme, die verwendet wird um zu verifizieren, dass ein kryptografischer Schlüssel korrekt eingegeben oder übertragen wurde. Sie wird berechnet, indem ein Block aus Nullen verschlüsselt und die ersten 3 Bytes des Ergebnisses genommen werden.' },
        { question: 'Wie wird KCV für DES/3DES berechnet?', answer: 'Für DES/3DES: Verschlüsseln Sie 8 Bytes Nullen (0x0000000000000000) im ECB-Modus, dann nehmen Sie die ersten 6 Hex-Zeichen (3 Bytes) des Chiffretexts.' },
        { question: 'Wie wird KCV für AES berechnet?', answer: 'Für AES: Berechnen Sie CMAC über 16 Bytes Nullen mit dem Schlüssel, dann nehmen Sie die ersten 6 Hex-Zeichen (3 Bytes) des MAC-Werts.' },
        { question: 'Was ist automatische Paritätsanpassung?', answer: 'DES-Schlüssel erfordern ungerade Parität für jedes Byte. Wenn Ihr Schlüssel keine korrekte Parität hat, aktivieren Sie die automatische Anpassung, um sie vor der KCV-Berechnung zu korrigieren.' },
      ],
      usage: [
        'Wählen Sie den Algorithmus (AES oder DES/3DES).',
        'Geben Sie Ihren Verschlüsselungsschlüssel im Hexadezimalformat ein.',
        'Für DES-Schlüssel optional die automatische Paritätsanpassung aktivieren.',
        'Klicken Sie auf "KCV berechnen" um den Key Check Value zu generieren.',
        'Vergleichen Sie den KCV mit dem erwarteten Wert, um die Schlüsselkorrektheit zu verifizieren.',
      ],
    },
    pinBlock: {
      title: 'PIN Block Generator Online - ISO 9564 Format 0/1/3/4 | HSM Kit',
      description: 'Kostenloser Online PIN Block Generator mit Unterstützung für ISO 9564 Formate (Format 0, 1, 3, 4). Generieren Sie PIN Blocks für Zahlungstransaktionen, ATM und POS-Systeme. Essentielles Tool für Zahlungssicherheitstests.',
      keywords: 'PIN Block, ISO 9564, PIN Block Format 0, PIN Block Format 4, Zahlungssicherheit, ATM PIN, POS PIN, PIN Verschlüsselung, Karten-PIN',
      faqTitle: 'PIN Block FAQ',
      usageTitle: 'PIN Block Generator Anleitung',
      faqs: [
        { question: 'Was ist ein PIN Block?', answer: 'Ein PIN Block ist ein standardisiertes Format zur Kodierung einer PIN (Personal Identification Number) vor der Verschlüsselung. Es kombiniert die PIN mit einem Füllmuster oder PAN-Daten, um einen Block fester Länge für die Verschlüsselung zu erstellen.' },
        { question: 'Was ist Format 0 (ISO 9564-1)?', answer: 'Format 0 XOR-t den PIN Block mit den rechtesten 12 Ziffern der PAN (ohne Prüfziffer). Es ist das am weitesten verbreitete Format in Zahlungssystemen.' },
        { question: 'Was ist Format 4 (ISO 9564-1:2017)?', answer: 'Format 4 ist das neueste Format, das für AES-Verschlüsselung konzipiert wurde. Es enthält zufälliges Padding und bietet bessere Sicherheit als ältere Formate.' },
        { question: 'Warum wird PAN für PIN Block benötigt?', answer: 'Bei Format 0 und einigen anderen wird die PAN mit den PIN-Daten XOR-t, wodurch die PIN an eine bestimmte Karte gebunden und bestimmte Angriffe verhindert werden.' },
      ],
      usage: [
        'Wählen Sie das PIN Block Format (0, 1, 3 oder 4).',
        'Geben Sie die PIN (4-12 Ziffern) ein.',
        'Für Formate, die PAN erfordern, geben Sie die Kartennummer ein.',
        'Klicken Sie auf "Generieren" um den PIN Block zu erstellen.',
        'Verwenden Sie den generierten Hex-String als Eingabe für Ihren Verschlüsselungsprozess.',
      ],
    },
    hash: {
      title: 'Hash-Rechner Online - MD5, SHA-256, SHA-512, BLAKE2 | HSM Kit',
      description: 'Kostenloser Online-Hash-Rechner mit Unterstützung für MD5, SHA-1, SHA-256, SHA-512, RIPEMD-160, WHIRLPOOL, BLAKE2, CRC32 und mehr. Hash-Werte aus Text oder Hex-Eingabe berechnen.',
      keywords: 'Hash-Rechner, MD5-Hash, SHA-256-Hash, SHA-512-Hash, BLAKE2, RIPEMD-160, WHIRLPOOL, CRC32, Hash-Generator, Prüfsummenrechner',
      faqTitle: 'Hash-Rechner FAQ',
      usageTitle: 'Hash-Rechner Anleitung',
      faqs: [
        { question: 'Was ist eine Hash-Funktion?', answer: 'Eine Hash-Funktion ist ein mathematischer Algorithmus, der Eingabedaten beliebiger Größe in eine Ausgabe fester Größe (Hash-Wert) umwandelt.' },
        { question: 'Welchen Hash-Algorithmus sollte ich verwenden?', answer: 'Für Sicherheitszwecke verwenden Sie SHA-256 oder SHA-512. MD5 und SHA-1 gelten als unsicher für kryptografische Zwecke.' },
        { question: 'Was ist der Unterschied zwischen MD5 und SHA-256?', answer: 'MD5 erzeugt einen 128-Bit-Hash und ist schnell, aber kryptografisch gebrochen. SHA-256 erzeugt einen 256-Bit-Hash und ist derzeit kryptografisch sicher. Verwenden Sie SHA-256 für sicherheitskritische Anwendungen.' },
        { question: 'Kann ein Hash entschlüsselt werden?', answer: 'Nein, Hash-Funktionen sind konstruktionsbedingt Einwegfunktionen. Die ursprüngliche Eingabe kann nicht aus dem Hash wiederhergestellt werden. Diese Eigenschaft macht sie nützlich für Passwortspeicherung und Datenintegritätsprüfung.' },
      ],
      usage: ['Eingabetyp wählen', 'Algorithmus wählen', 'Daten eingeben', '"Berechnen" klicken'],
    },
    encoding: {
      title: 'Zeichencodierung Konverter Online - ASCII, EBCDIC, Hex | HSM Kit',
      description: 'Kostenloser Online-Zeichencodierung-Konverter. Konvertierung zwischen ASCII, EBCDIC, Hexadezimal, Binär und ATM-Dezimal.',
      keywords: 'Zeichencodierung, ASCII EBCDIC Konverter, Hex-Konverter, Binär-Konverter, EBCDIC-Konverter, ATM-Dezimal',
      faqTitle: 'Zeichencodierung FAQ',
      usageTitle: 'Codierung-Konverter Anleitung',
      faqs: [
        { question: 'Was ist Zeichencodierung?', answer: 'Zeichencodierung ist ein System, das jedes Zeichen mit einer eindeutigen Nummer oder Bytesequenz verbindet.' },
        { question: 'Was ist EBCDIC?', answer: 'EBCDIC ist eine 8-Bit-Zeichencodierung, die hauptsächlich auf IBM-Mainframes verwendet wird.' },
        { question: 'Warum brauche ich ASCII-EBCDIC-Konvertierung?', answer: 'Viele Legacy-Bank- und Finanzsysteme laufen auf IBM-Mainframes mit EBCDIC. Bei der Integration moderner Systeme (ASCII/UTF-8) mit diesen Mainframes ist die Zeichenkonvertierung unverzichtbar.' },
        { question: 'Was ist ATM-Dezimalcodierung?', answer: 'ATM-Dezimal ist eine spezifische Codierung in der ATM-Kommunikation, bei der jede Ziffer (0-9) durch ihren ASCII-Code dargestellt wird. Sie wird häufig in Finanznachrichtenprotokollen verwendet.' },
      ],
      usage: ['Konvertierungstyp wählen', 'Daten eingeben', '"Konvertieren" klicken'],
    },
    bcd: {
      title: 'BCD Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-BCD-Encoder und -Decoder. Dezimalzahlen in BCD oder BCD zurück in Dezimal konvertieren.',
      keywords: 'BCD-Encoder, BCD-Decoder, Binär codierte Dezimalzahl, Dezimal-BCD-Konvertierung',
      faqTitle: 'BCD FAQ',
      usageTitle: 'BCD-Tool Anleitung',
      faqs: [
        { question: 'Was ist BCD?', answer: 'Binär codierte Dezimalzahl (BCD) ist eine Codierung, bei der jede Dezimalziffer durch 4 Bits dargestellt wird.' },
        { question: 'Warum wird BCD verwendet?', answer: 'BCD wird in Finanzanwendungen verwendet, wo genaue Dezimaldarstellung wichtig ist.' },
        { question: 'Was ist der Unterschied zwischen gepacktem und ungepacktem BCD?', answer: 'Gepacktes BCD speichert zwei Dezimalziffern pro Byte (je 4 Bits). Ungepacktes BCD verwendet ein ganzes Byte für jede Ziffer. Gepacktes BCD ist speichereffizienter.' },
        { question: 'Wo wird BCD üblicherweise verwendet?', answer: 'BCD wird häufig in Finanzsystemen, Taschenrechnern, Digitaluhren und Anwendungen verwendet, bei denen Dezimalpräzision wichtig ist. Zahlungsterminals und Geldautomaten verwenden oft BCD für Beträge.' },
      ],
      usage: ['Codieren oder Decodieren wählen', 'Daten eingeben', 'Schaltfläche klicken'],
    },
    checkDigits: {
      title: 'Prüfziffer-Rechner Online - Luhn MOD 10, MOD 9 | HSM Kit',
      description: 'Kostenloser Online-Prüfziffer-Rechner und -Validator. Prüfziffern mit Luhn (MOD 10) und MOD 9 generieren oder verifizieren.',
      keywords: 'Prüfziffer-Rechner, Luhn-Algorithmus, MOD 10, MOD 9, Kreditkartenvalidierung',
      faqTitle: 'Prüfziffer FAQ',
      usageTitle: 'Prüfziffer-Rechner Anleitung',
      faqs: [
        { question: 'Was ist eine Prüfziffer?', answer: 'Eine Prüfziffer ist eine Ziffer, die zur Fehlererkennung an eine Nummer angehängt wird.' },
        { question: 'Was ist der Luhn-Algorithmus?', answer: 'Der Luhn-Algorithmus (MOD 10) ist eine Prüfsummenformel zur Validierung von Kreditkartennummern usw.' },
        { question: 'Welche Nummern verwenden den Luhn-Algorithmus?', answer: 'Kreditkartennummern (Visa, MasterCard, Amex), IMEI-Nummern, NPI (Gesundheitsanbieter-Identifikator), kanadische Sozialversicherungsnummern und viele andere Identifikationsnummern verwenden Luhn-Validierung.' },
        { question: 'Was ist der Amex SE MOD 9 Algorithmus?', answer: 'Der Amex SE (Service Establishment) MOD 9 Algorithmus wird von American Express zur Validierung von Händler-/Servicenummern verwendet. Er verwendet eine andere Berechnungsmethode als Luhn.' },
      ],
      usage: ['Algorithmus wählen', 'Verifizieren oder Generieren wählen', 'Nummer eingeben'],
    },
    base64: {
      title: 'Base64 Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-Base64-Encoder und -Decoder. Text in Base64 oder Base64 in Text konvertieren.',
      keywords: 'Base64-Encoder, Base64-Decoder, Base64-Konvertierung, Binär-Text-Konvertierung',
      faqTitle: 'Base64 FAQ',
      usageTitle: 'Base64-Tool Anleitung',
      faqs: [
        { question: 'Was ist Base64?', answer: 'Base64 ist eine Codierung, die Binärdaten in ASCII-Strings mit 64 Zeichen umwandelt.' },
        { question: 'Warum Base64 verwenden?', answer: 'Base64 wird verwendet, um Binärdaten in textbasierten Protokollen zu übertragen.' },
        { question: 'Bietet Base64 Verschlüsselung?', answer: 'Nein, Base64 ist ein Codierungsschema, keine Verschlüsselung. Jeder kann Base64-Daten decodieren. Es dient der Datenrepräsentation, nicht der Sicherheit.' },
        { question: 'Warum erhöht Base64 die Datengröße?', answer: 'Base64 kodiert 3 Bytes Binärdaten in 4 ASCII-Zeichen, was zu einer Größenerhöhung von etwa 33% führt. Wenn die Eingabelänge nicht durch 3 teilbar ist, werden Füllzeichen "=" verwendet.' },
      ],
      usage: ['Codieren oder Decodieren wählen', 'Daten eingeben', 'Schaltfläche klicken'],
    },
    base94: {
      title: 'Base94 Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-Base94-Encoder und -Decoder. Kompakte Codierung mit allen 94 druckbaren ASCII-Zeichen.',
      keywords: 'Base94-Encoder, Base94-Decoder, Kompakte Codierung',
      faqTitle: 'Base94 FAQ',
      usageTitle: 'Base94-Tool Anleitung',
      faqs: [
        { question: 'Was ist Base94?', answer: 'Base94 ist eine Codierung mit 94 druckbaren ASCII-Zeichen, effizienter als Base64.' },
        { question: 'Warum Base94 verwenden?', answer: 'Base94 bietet etwa 20% kompaktere Codierung als Base64.' },
        { question: 'Welche Zeichen verwendet Base94?', answer: 'Base94 verwendet alle 94 druckbaren ASCII-Zeichen von ! (0x21) bis ~ (0x7E), ausgenommen Leerzeichen. Dies umfasst Buchstaben, Ziffern und alle Standard-Satzzeichen.' },
        { question: 'Wann sollte ich Base94 verwenden?', answer: 'Verwenden Sie Base94, wenn Sie eine kompakte Textdarstellung von Binärdaten benötigen und Ihr Übertragungs-/Speichersystem alle druckbaren ASCII-Zeichen unterstützt. Ideal für URLs, QR-Codes oder Speicheroptimierung.' },
      ],
      usage: ['Codieren oder Decodieren wählen', 'Daten eingeben', 'Schaltfläche klicken'],
    },
    messageParser: {
      title: 'Nachrichtenparser Online - ATM NDC, Wincor, ISO 8583 | HSM Kit',
      description: 'Kostenloser Online-ATM- und Finanznachrichtenparser. ATM NDC, Wincor, ISO 8583 Nachrichtenformate analysieren.',
      keywords: 'Nachrichtenparser, ATM NDC, ATM Wincor, ISO 8583, Finanznachricht',
      faqTitle: 'Nachrichtenparser FAQ',
      usageTitle: 'Nachrichtenparser Anleitung',
      faqs: [
        { question: 'Was ist ATM NDC?', answer: 'NDC (NCR Direct Connect) ist ein Protokoll, das NCR-Geldautomaten zur Kommunikation mit Hostsystemen verwenden.' },
        { question: 'Was ist ISO 8583?', answer: 'ISO 8583 ist ein internationaler Standard für Finanztransaktionsnachrichten.' },
        { question: 'Was ist das Wincor/Nixdorf-Protokoll?', answer: 'Das Wincor Nixdorf (jetzt Diebold Nixdorf) Protokoll ist ein proprietäres ATM-Kommunikationsprotokoll, ähnlich wie NDC, aber mit herstellerspezifischen Variationen. Es wird in europäischen und asiatischen Märkten weit verbreitet.' },
        { question: 'Wie identifiziere ich das Nachrichtenformat?', answer: 'NDC-Nachrichten beginnen typischerweise mit bestimmten Nachrichtenklassen-Identifikatoren. ISO 8583-Nachrichten beginnen mit einem 4-stelligen MTI (Message Type Indicator). Die Hex-Dump-Struktur hilft bei der Identifizierung des verwendeten Protokolls.' },
      ],
      usage: ['Nachrichtenformat wählen', 'Hex-Daten eingeben', '"Analysieren" klicken'],
    },
    rsaDer: {
      title: 'RSA DER Öffentlicher Schlüssel Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-RSA-DER-Öffentlicher-Schlüssel-Encoder und -Decoder. Zwischen Modulus/Exponent und DER ASN.1 Format konvertieren.',
      keywords: 'RSA DER, RSA öffentlicher Schlüssel, DER-Codierung, ASN.1, PEM-Format',
      faqTitle: 'RSA DER Öffentlicher Schlüssel FAQ',
      usageTitle: 'RSA DER Tool Anleitung',
      faqs: [
        { question: 'Was ist DER-Codierung?', answer: 'DER (Distinguished Encoding Rules) ist ein Binärformat zur Codierung von ASN.1-Datenstrukturen.' },
        { question: 'Was ist PEM-Format?', answer: 'PEM ist eine Base64-codierte Version von DER mit Header-/Footer-Zeilen.' },
        { question: 'Was sind Modulus und Exponent in RSA?', answer: 'Der Modulus (n) ist das Produkt zweier großer Primzahlen und bestimmt die Schlüsselgröße. Der öffentliche Exponent (e) ist typischerweise 65537 (0x10001). Zusammen bilden sie den öffentlichen Schlüssel.' },
        { question: 'Wie extrahiere ich den Modulus aus einem Zertifikat?', answer: 'Verwenden Sie dieses Tool, um den DER/PEM-codierten öffentlichen Schlüssel zu decodieren. Der Parser extrahiert und zeigt Modulus und Exponent in verschiedenen Formaten (Hex, Dezimal, Base64) an.' },
      ],
      usage: ['Codieren: Modulus und Exponent eingeben', 'Decodieren: DER- oder PEM-Daten einfügen'],
    },
    uuid: {
      title: 'UUID Generator Online - Version 1, 3, 4, 5 | HSM Kit',
      description: 'Kostenloser Online-UUID-Generator mit Unterstützung für Version 1 (zeitbasiert), 3 (MD5), 4 (zufällig), 5 (SHA-1).',
      keywords: 'UUID-Generator, GUID-Generator, UUID v4, UUID v1, Zufällige UUID',
      faqTitle: 'UUID Generator FAQ',
      usageTitle: 'UUID Generator Anleitung',
      faqs: [
        { question: 'Was ist UUID?', answer: 'UUID (Universally Unique Identifier) ist ein 128-Bit-Bezeichner, der in Zeit und Raum eindeutig ist.' },
        { question: 'Welche UUID-Version sollte ich verwenden?', answer: 'Version 4 (zufällig) ist am häufigsten und wird empfohlen.' },
        { question: 'Was ist der Unterschied zwischen UUID und GUID?', answer: 'UUID und GUID (Globally Unique Identifier) sind das Gleiche. GUID ist Microsofts Begriff, während UUID der Standardbegriff (RFC 4122) ist. Gleiches Format, gleicher Zweck.' },
        { question: 'Sind UUIDs wirklich eindeutig?', answer: 'Die Kollisionswahrscheinlichkeit bei UUID v4 beträgt etwa 1 zu 2^122. Selbst bei der Generierung von einer Milliarde UUIDs ist die Wahrscheinlichkeit einer Duplikation extrem gering. Praktisch können sie als eindeutig angesehen werden.' },
      ],
      usage: ['UUID-Version wählen', 'Anzahl eingeben', '"Generieren" klicken'],
    },
  },
};

