// German translations
export default {
  common: {
    copy: 'Kopieren',
    generate: 'Generieren',
    calculate: 'Berechnen',
    parse: 'Analysieren',
    clear: 'Löschen',
    copied: 'In die Zwischenablage kopiert!',
    copyFailed: 'Kopieren fehlgeschlagen',
    error: 'Fehler',
    result: 'Ergebnis',
    loading: 'Wird geladen...',
    close: 'Schließen',
    cancel: 'Abbrechen',
  },

  mac: {
    as2805: {
      title: 'AS2805 MACs',
      description: 'Nachrichtenauthentifizierungscode mit AS2805.4.1-Standard berechnen.',
      infoTitle: 'Über AS2805 MACs',
      infoDescription1: 'AS2805.4.1 definiert MAC-Algorithmen, die in australischen Zahlungssystemen verwendet werden.',
      infoDescription2: 'Methode 2 verwendet DES CBC-MAC mit finaler 3DES-Verschlüsselung.',
      algorithm: 'MAC-Algorithmus:',
      algorithmMethod1: 'AS2805.4.1 MAC Methode 1',
      algorithmMethod2: 'AS2805.4.1 MAC Methode 2',
      keyKL: 'Schlüssel (K|KL):',
      keyKLPlaceholder: '0123456789ABCDEF',
      keyKR: 'Schlüssel (KR):',
      keyKRPlaceholder: 'FEDCBA9876543210',
      data: 'Daten:',
      dataPlaceholder: 'Hex-Daten eingeben',
      truncation: 'Kürzung:',
      truncationPlaceholder: '4',
      calculate: 'MAC berechnen',
      result: 'MAC:',
      hexChars: 'Hex-Zeichen',
      copied: 'Kopiert!',
      success: 'MAC erfolgreich berechnet',
      error: {
        invalidKeyKL: 'Schlüssel (K|KL) muss 16 Hex-Zeichen sein',
        invalidKeyKR: 'Schlüssel (KR) muss 16 Hex-Zeichen sein',
        emptyData: 'Daten sind erforderlich',
        invalidDataFormat: 'Ungültiges Datenformat',
        invalidTruncation: 'Kürzung muss zwischen 1 und 8 liegen',
        calculationFailed: 'MAC-Berechnung fehlgeschlagen',
      },
    },
    tdescbc: {
      title: 'TDES CBC-MAC',
      infoTitle: 'Über TDES CBC-MAC',
      info: 'MAC-Berechnung mit Triple DES CBC-Modus und ISO 9797-1 Padding',
      description: 'MAC mit Triple DES im CBC-Modus berechnen.',
      algorithm: 'Algorithmus',
      keyK: 'Schlüssel (K)',
      padding: 'Padding',
      data: 'Daten (Hex)',
      truncation: 'Kürzung (Bytes)',
      calculate: 'MAC berechnen',
      result: 'MAC-Ergebnis',
      hexChars: 'Hex-Zeichen',
      copied: 'Kopiert!',
      success: 'MAC erfolgreich berechnet',
      error: {
        invalidKeyFormat: 'Ungültiges Schlüsselformat',
        invalidKeyLength: 'Schlüssel muss 32 oder 48 Hex-Zeichen sein',
        emptyData: 'Daten sind erforderlich',
        invalidDataFormat: 'Ungültiges Datenformat',
        invalidTruncation: 'Kürzung muss 1-8 Bytes sein',
      },
    },
    hmac: {
      title: 'HMAC',
      description: 'Hash-basierten Nachrichten-Authentifizierungscode berechnen.',
      hashType: 'Hash-Typ',
      inputTypeLabel: 'Eingabetyp',
      hmacKey: 'HMAC-Schlüssel',
      data: 'Daten',
      keyPlaceholderHex: 'Hex-Schlüssel eingeben',
      keyPlaceholderAscii: 'ASCII-Schlüssel eingeben',
      dataPlaceholderHex: 'Hex-Daten eingeben',
      dataPlaceholderAscii: 'ASCII-Daten eingeben',
      calculate: 'HMAC berechnen',
      result: 'HMAC-Ergebnis',
      hexChars: 'Hex-Zeichen',
      copied: 'Kopiert!',
      success: 'HMAC erfolgreich berechnet',
      error: {
        emptyKey: 'Schlüssel ist erforderlich',
        invalidKeyFormat: 'Ungültiges Schlüsselformat',
        emptyData: 'Daten sind erforderlich',
        invalidDataFormat: 'Ungültiges Datenformat',
      },
    },
    cmac: {
      title: 'CMAC',
      infoTitle: 'Über CMAC',
      info: 'Cipher-basierte MAC-Berechnung mit AES oder TDES gemäß NIST SP 800-38B',
      description: 'Cipher-basierten Nachrichten-Authentifizierungscode berechnen.',
      encryptionType: 'Verschlüsselungstyp',
      cmacKey: 'CMAC-Schlüssel',
      data: 'Daten',
      inputTypeLabel: 'Eingabetyp',
      keyPlaceholderHex: 'Hex-Schlüssel eingeben',
      keyPlaceholderAscii: 'ASCII-Schlüssel eingeben',
      dataPlaceholderHex: 'Hex-Daten eingeben',
      dataPlaceholderAscii: 'ASCII-Daten eingeben',
      aesCmac96: 'AES CMAC 96 (auf 12 Bytes kürzen)',
      calculate: 'CMAC berechnen',
      result: 'CMAC-Ergebnis',
      hexChars: 'Hex-Zeichen',
      copied: 'Kopiert!',
      success: 'CMAC erfolgreich berechnet',
      error: {
        emptyKey: 'Schlüssel ist erforderlich',
        invalidKeyFormat: 'Ungültiges Schlüsselformat',
        invalidKeyLength: 'Ungültige Schlüssellänge',
        emptyData: 'Daten sind erforderlich',
        invalidDataFormat: 'Ungültiges Datenformat',
      },
    },
    retail: {
      title: 'Retail MAC',
      description: 'Retail MAC mit DES oder Triple DES berechnen.',
      algorithm: 'Algorithmus',
      finalize: 'Finalisieren',
      keyK: 'Schlüssel (K)',
      keyKPlaceholder: '0123456789ABCDEF',
      keyKPrime: 'Schlüssel (K\')',
      keyKPrimePlaceholder: 'FEDCBA9876543210',
      data: 'Daten (Hex)',
      dataPlaceholder: 'Hex-Daten eingeben',
      truncation: 'Kürzung (Bytes)',
      truncationPlaceholder: '1-8',
      calculate: 'MAC berechnen',
      result: 'MAC-Ergebnis',
      hexChars: 'Hex-Zeichen',
      copied: 'Kopiert!',
      success: 'MAC erfolgreich berechnet',
      error: {
        invalidKeyK: 'Schlüssel K muss 16 Hex-Zeichen sein',
        invalidKeyKPrime: 'Schlüssel K\' muss 16 Hex-Zeichen sein',
        emptyData: 'Daten sind erforderlich',
        invalidDataFormat: 'Ungültiges Datenformat',
        invalidTruncation: 'Kürzung muss 1-8 Bytes sein',
      },
    },
    zka: {
      title: 'ZKA (Deutscher Bankenstandard)',
      infoTitle: 'Über ZKA',
      info1: 'Deutscher Bankenstandard für Schlüsselverwaltung und kryptografische Operationen',
      info2: 'Umfasst SK-Ableitung, PIN-Verschlüsselung und MAC-Berechnung',
      description: 'ZKA-Kryptografie-Operationen für deutsche Bankensysteme',
    },
  },
  
  header: {
    title: 'HSM Kit',
    github: 'GitHub',
  },
  
  menu: {
    keyGenerator: 'Schlüssel Gen.',
    tr31: 'TR-31',
    kcv: 'KCV Rechner',
    pinBlock: 'PIN-Block',
    asn1: 'ASN.1',
    cipher: 'Verschlüsselung',
    generic: 'Allgemein',
    hashes: 'Hashes',
    characterEncoding: 'Zeichenkodierung',
    bcd: 'BCD',
    checkDigits: 'Prüfziffern',
    base64: 'Base64',
    base94: 'Base94',
    messageParser: 'Nachrichtenparser',
    rsaDerPublicKey: 'RSA DER Öffentlicher Schlüssel',
    uuid: 'UUID',
    // PKI Menü
    pki: 'PKI',
    asn1Decoder: 'ASN.1 Decoder',
    sslCertificates: 'SSL Zertifikate',
    // Keys Menü
    keys: 'Schlüssel',
    keysDea: 'Keys DEA',
    keyshareGenerator: 'Keyshare Generator',
    keysHsm: 'Keys HSM',
    keysFuturex: 'Keys Futurex',
    keysAtalla: 'Keys Atalla',
    keysSafeNet: 'Keys SafeNet',
    keysThales: 'Keys Thales',
    keyBlocks: 'Key Blocks',
    thalesKeyBlock: 'Thales Key Block',
    tr31KeyBlock: 'TR-31 Key Block',
    // Payments Menü
    payments: 'Payments',
    as2805: 'AS2805',
    bitmap: 'Bitmap',
    cardValidation: 'Card Validation',
    cvvs: 'CVVs',
    amexCscs: 'AMEX CSCs',
    mastercardCvc3: 'MasterCard dynamic CVC3',
    dukpt: 'DUKPT',
    dukptIso9797: 'DUKPT (ISO 9797)',
    dukptAes: 'DUKPT (AES)',
    macAlgorithms: 'MAC Algorithms',
    iso9797_1: 'ISO/IEC 9797-1',
    ansix9: 'ANSI X9.9 & X9.19',
    as2805_4_1: 'AS2805.4.1',
    tdesCbcMac: 'TDES CBC-MAC',
    hmac: 'HMAC',
    cmac: 'CMAC',
    retail: 'Retail',
    pinBlocks: 'PIN Blocks',
    pinBlocksGeneral: 'PIN Blocks General',
    pinBlocksAes: 'PIN Blocks AES',
    pinOffset: 'PIN Offset',
    pinPvv: 'PIN PVV',
    visaCertificates: 'Visa Certificates',
    zka: 'ZKA',
  },
  
  footer: {
    tagline: 'Browserbasierte Sicherheitsberechnungstools',
    privacyPolicy: 'Datenschutzrichtlinie',
    termsOfService: 'Nutzungsbedingungen',
    disclaimer: 'Haftungsausschluss',
    contact: 'Kontakt & Feedback',
  },

  privacyPolicy: {
    seoTitle: 'Datenschutzrichtlinie | HSM Kit',
    seoDescription: 'HSM Kit Datenschutzrichtlinie - Erfahren Sie, wie wir Ihre Daten durch clientseitige Verarbeitung schützen.',
    seoKeywords: 'Datenschutzrichtlinie, Datenschutz, clientseitige Verarbeitung, HSM Kit',
    title: 'Datenschutzrichtlinie',
    introTitle: 'Einleitung',
    introContent: 'Bei HSM Kit nehmen wir Ihre Sicherheit und Privatsphäre ernst. Diese Datenschutzrichtlinie beschreibt, wie wir mit Daten umgehen, wenn Sie unsere Online-Kryptographie-Tools verwenden.',
    clientSideTitle: 'Clientseitige Verarbeitung',
    clientSideContent: 'Wir sammeln, speichern oder übertragen Ihre Eingabedaten nicht. Alle kryptographischen Operationen (Verschlüsselung, Entschlüsselung, Hashing, Schlüsselformatierung) werden vollständig in Ihrem Webbrowser mit JavaScript ausgeführt. Ihre Schlüssel, PINs und Daten verlassen niemals Ihr Gerät und werden niemals an unsere Server gesendet.',
    dataCollectionTitle: 'Datenerfassung',
    dataCollectionContent: 'Wir verfolgen oder speichern keine persönlichen Informationen.',
    analyticsTitle: 'Nutzungsanalyse',
    analyticsContent: 'Wir können anonyme Analysetools (z.B. Google Analytics) verwenden, um Seitenaufrufe und Website-Leistung zu verfolgen. Diese Tools haben keinen Zugriff auf die Daten, die Sie in die Berechnungsformulare eingeben.',
    localStorageTitle: 'Lokaler Speicher',
    localStorageContent: 'Wir können den lokalen Speicher Ihres Browsers verwenden, um Ihre Schnittstellenpräferenzen (wie Dunkelmodus-Einstellungen) zu speichern. Diese Daten werden auf Ihrem Gerät gespeichert und nicht an uns übertragen.',
    thirdPartyTitle: 'Drittanbieter-Dienste',
    thirdPartyContent: 'Unsere Website wird bei einem öffentlichen Cloud-Anbieter gehostet. Obwohl wir keine Daten sammeln, können Standard-Serverprotokolle (IP-Adressen, Benutzer-Agents) vom Hosting-Anbieter zu Sicherheits- und Wartungszwecken verarbeitet werden.',
    changesTitle: 'Änderungen dieser Richtlinie',
    changesContent: 'Wir können diese Datenschutzrichtlinie von Zeit zu Zeit aktualisieren. Wir empfehlen Ihnen, diese Seite regelmäßig auf Änderungen zu überprüfen.',
    lastUpdated: 'Zuletzt aktualisiert',
    lastUpdatedDate: 'Januar {year}',
    backToHome: 'Zurück zur Startseite',
    contactTitle: 'Kontakt',
    contactContent: 'Wenn Sie Fragen zu dieser Datenschutzrichtlinie haben, kontaktieren Sie uns bitte unter ',
  },

  termsOfService: {
    seoTitle: 'Nutzungsbedingungen | HSM Kit',
    seoDescription: 'HSM Kit Nutzungsbedingungen - Lesen Sie unsere Allgemeinen Geschäftsbedingungen für die Nutzung unserer Kryptographie-Tools.',
    seoKeywords: 'Nutzungsbedingungen, Allgemeine Geschäftsbedingungen, Benutzervereinbarung, HSM Kit',
    title: 'Nutzungsbedingungen',
    acceptanceTitle: '1. Annahme der Bedingungen',
    acceptanceContent: 'Durch den Zugriff auf und die Nutzung von HSM Kit (hsmkit.com) akzeptieren Sie die Bedingungen dieser Vereinbarung und stimmen ihnen zu. Wenn Sie diesen Bedingungen nicht zustimmen, nutzen Sie diese Website bitte nicht.',
    useOfServiceTitle: '2. Nutzung des Dienstes',
    useOfServiceIntro: 'HSM Kit bietet Online-Kryptographie-Tools für Entwickler und Sicherheitsexperten.',
    licenseTitle: 'Lizenz',
    licenseContent: 'Wir gewähren Ihnen eine begrenzte, nicht-exklusive, nicht übertragbare Lizenz zur Nutzung der Tools für persönliche, pädagogische und professionelle Testzwecke.',
    restrictionsTitle: 'Einschränkungen',
    restrictionsContent: 'Sie erklären sich damit einverstanden, die Dienste nicht zu missbrauchen. Dies umfasst unter anderem:',
    restriction1: 'Versuche, den ordnungsgemäßen Betrieb der Website zu stören (z.B. DDoS-Angriffe).',
    restriction2: 'Verwendung automatisierter Systeme (Roboter, Spider) zum Zugriff auf die Website ohne unsere Genehmigung.',
    restriction3: 'Nutzung der Tools für illegale Aktivitäten oder zur Erleichterung böswilliger Handlungen.',
    intellectualPropertyTitle: '3. Geistiges Eigentum',
    intellectualPropertyContent: 'Der Inhalt, das Layout, das Design, die Daten, Datenbanken und Grafiken auf dieser Website sind durch Gesetze zum Schutz geistigen Eigentums geschützt und gehören HSM Kit, sofern nicht anders angegeben. Sie dürfen keinen Teil des Dienstes ohne unsere ausdrückliche schriftliche Genehmigung reproduzieren, duplizieren, kopieren, verkaufen oder nutzen.',
    disclaimerTitle: '4. Gewährleistungsausschluss',
    disclaimerContent: 'Die Tools werden auf einer "WIE SIE SIND" und "WIE VERFÜGBAR"-Basis bereitgestellt. HSM Kit gibt keine ausdrücklichen oder stillschweigenden Zusicherungen oder Garantien hinsichtlich der Genauigkeit, Zuverlässigkeit oder Vollständigkeit der Berechnungen.',
    limitationTitle: '5. Haftungsbeschränkung',
    limitationContent: 'In keinem Fall haften HSM Kit oder seine Betreiber für direkte, indirekte, zufällige, besondere oder Folgeschäden, die sich aus oder in irgendeiner Weise in Verbindung mit der Nutzung dieser Website ergeben. Dies umfasst unter anderem Datenverlust, Gewinnverlust oder Geschäftsunterbrechung.',
    changesTitle: '6. Änderungen der Bedingungen',
    changesContent: 'Wir behalten uns das Recht vor, diese Bedingungen jederzeit zu ändern. Ihre fortgesetzte Nutzung der Website nach Änderungen bedeutet Ihre Zustimmung zu den neuen Bedingungen.',
    lastUpdated: 'Zuletzt aktualisiert',
    lastUpdatedDate: 'Januar {year}',
    backToHome: 'Zurück zur Startseite',
    contactTitle: 'Kontakt',
    contactContent: 'Wenn Sie Fragen zu diesen Nutzungsbedingungen haben, kontaktieren Sie uns bitte unter ',
  },

  disclaimer: {
    seoTitle: 'Haftungsausschluss | HSM Kit',
    seoDescription: 'HSM Kit rechtlicher Haftungsausschluss - Wichtige Informationen zur Nutzung unserer Kryptographie-Tools.',
    seoKeywords: 'Haftungsausschluss, rechtlicher Hinweis, Nutzungsbedingungen, HSM Kit',
    title: 'Haftungsausschluss',
    generalTitle: 'Allgemeiner Haftungsausschluss',
    generalContent: 'Die auf HSM Kit bereitgestellten Tools und Informationen dienen ausschließlich Bildungs-, Test- und Entwicklungszwecken. Obwohl wir uns bemühen, die Genauigkeit der Algorithmen und Berechnungen sicherzustellen, wird die Software "WIE SIE IST" ohne jegliche ausdrückliche oder stillschweigende Garantie bereitgestellt.',
    noLiabilityTitle: 'Haftungsbeschränkung',
    noLiabilityContent: 'In keinem Fall haften die Autoren oder Urheberrechtsinhaber für Ansprüche, Schäden oder andere Haftungen, sei es aus Vertrag, unerlaubter Handlung oder anderweitig, die sich aus oder in Verbindung mit der Software oder der Nutzung oder anderen Geschäften in der Software ergeben.',
    securityTitle: 'Sicherheitswarnung',
    securityContent: 'Verwenden Sie KEINE echten Produktionsschlüssel, sensiblen Finanzdaten oder echte persönliche Informationen auf dieser Website. Obwohl alle Berechnungen clientseitig durchgeführt werden, ist es eine bewährte Praxis in der Sicherheitsbranche, niemals echtes kryptographisches Material in einer Browser-Umgebung preiszugeben.',
    securityWarningTitle: 'Wichtiger Sicherheitshinweis',
    securityWarningContent: 'Verwenden Sie niemals echte Produktionsschlüssel, sensible Daten oder echte Anmeldedaten auf dieser Website. Dieses Tool dient nur zu Bildungs- und Testzwecken.',
    complianceTitle: 'Compliance',
    complianceContent: 'Die Benutzer sind dafür verantwortlich sicherzustellen, dass ihre Nutzung dieser Tools allen anwendbaren lokalen, staatlichen und bundesstaatlichen Gesetzen und Vorschriften entspricht.',
    lastUpdated: 'Zuletzt aktualisiert',
    lastUpdatedDate: 'Januar {year}',
    backToHome: 'Zurück zur Startseite',
    contactTitle: 'Kontakt',
    contactContent: 'Wenn Sie Fragen zu diesem Haftungsausschluss haben, kontaktieren Sie uns bitte unter ',
  },

  home: {
    heroTitle: 'Kostenlose Online-Verschlüsselung & Schlüsselverwaltung',
    heroDescription: 'Eine umfassende Suite von Kryptografie-Tools für Sicherheitsexperten. Alle Berechnungen werden clientseitig in Ihrem Browser durchgeführt — Ihre Daten verlassen niemals Ihr Gerät.',
    searchPlaceholder: 'Tools suchen... (z.B. MD5, AES, PIN Block)',
    availableTools: 'Beliebte Tools',
    gridView: 'Rasteransicht',
    listView: 'Listenansicht',
    whyChoose: 'Warum HSM Kit wählen?',
    categories: {
      all: 'Alle',
      symmetric: 'Symmetrisch',
      asymmetric: 'Asymmetrisch',
      payment: 'Zahlung/Finanzen',
      encoding: 'Codierung',
      hashing: 'Hashing',
    },
    tools: {
      asn1: {
        title: 'ASN.1 Parser',
        description: 'ASN.1 DER/BER-Strukturen analysieren, X.509-Zertifikate und PKCS-Formate dekodieren.',
      },
      aes: {
        title: 'AES-Verschlüsselung',
        description: 'Daten mit AES-128/192/256 verschlüsseln/entschlüsseln. ECB, CBC, CFB, OFB, CTR Modi.',
      },
      des: {
        title: 'DES/3DES-Verschlüsselung',
        description: 'DES und Triple DES Verschlüsselung mit mehreren Padding-Optionen für Legacy-Systeme.',
      },
      rsa: {
        title: 'RSA-Verschlüsselung',
        description: 'RSA asymmetrische Verschlüsselung, Entschlüsselung, digitale Signatur und Verifizierung.',
      },
      ecc: {
        title: 'ECC/ECDSA',
        description: 'Elliptische-Kurven-Kryptografie für kompakte Schlüssel und effiziente digitale Signaturen.',
      },
      fpe: {
        title: 'Format-erhaltende Verschlüsselung',
        description: 'FPE (FF1/FF3-1) zur Verschlüsselung unter Beibehaltung von Format und Länge.',
      },
      keyGenerator: {
        title: 'Schlüsselgenerator',
        description: 'Sichere Zufallsschlüssel für AES, DES, 3DES generieren. Schlüsselkombination und Parität-Tools.',
      },
      tr31: {
        title: 'TR-31 Schlüsselblock',
        description: 'TR-31/ANSI X9.143 Schlüsselblöcke mit KBPK-Schutz kodieren/dekodieren. TDES- und AES-Versionen unterstützt.',
      },
      kcv: {
        title: 'KCV-Rechner',
        description: 'Key Check Value (KCV) für AES und DES/3DES Schlüssel berechnen.',
      },
      pinBlock: {
        title: 'PIN-Block Generator',
        description: 'ISO 9564 PIN-Blöcke (Format 0, 1, 3, 4) für Zahlungstransaktionen generieren.',
      },
      pinBlockGeneral: {
        title: 'PIN-Blöcke Allgemein',
        description: 'PIN-Blöcke in allen ISO 9564-Formaten (0, 1, 2, 3, 4) mit PAN kodieren und dekodieren.',
      },
      pinBlockAes: {
        title: 'PIN-Blöcke AES',
        description: 'AES-128 Ver-/Entschlüsselung von ISO 9564 Format 4 PIN-Blöcken mit 32 Hex-Ausgabe.',
      },
      pinOffset: {
        title: 'PIN-Offset',
        description: 'PIN-Offset mit IBM 3624-Methode und Validierungsdaten berechnen und verifizieren.',
      },
      pinPvv: {
        title: 'PIN PVV',
        description: 'Visa PIN-Prüfwert (PVV) Berechnung und PIN-Verifizierung mit PDK/PVKI.',
      },
      as2805: {
        title: 'AS2805 Nachrichten-Tools',
        description: 'Australische ISO 8583 Zahlungstools mit Schlüsselgenerierung, PIN-Block-Übersetzung und MAC-Berechnung.',
      },
      ansiMac: {
        title: 'ANSI MAC (X9.9 & X9.19)',
        description: 'ANSI X9.9/X9.19 Nachrichtenauthentifizierungscodes mit DES CBC-MAC oder 3DES.',
      },
      as2805Mac: {
        title: 'AS2805 MAC',
        description: 'AS2805.4.1 MAC für australische EFTPOS mit Methode 1 und Methode 2.',
      },
      tdesCbcMac: {
        title: 'TDES CBC-MAC',
        description: 'Triple DES CBC-MAC mit 2/3-Schlüssel TDES und ISO 9797-1 Padding.',
      },
      hmac: {
        title: 'HMAC',
        description: 'Hash-basierter MAC mit SHA-256/SHA-512 für API-Authentifizierung und Datenintegrität.',
      },
      cmac: {
        title: 'CMAC',
        description: 'NIST SP 800-38B Cipher-basierter MAC mit AES/TDES und CMAC-96.',
      },
      retailMac: {
        title: 'Retail MAC',
        description: 'ISO 9797-1 Methode 2 Retail MAC mit DES/3DES für POS und Geldautomaten.',
      },
      iso9797: {
        title: 'ISO 9797-1 MAC',
        description: 'ISO/IEC 9797-1 MAC-Rechner mit Algorithmen 1-6 und mehreren Padding-Methoden.',
      },
      visaCertificates: {
        title: 'VISA-Zertifikate',
        description: 'VISA-Zertifikatsvalidierung mit VSDC CA V92/V94 und benutzerdefinierten CA-Schlüsseln.',
      },
      zka: {
        title: 'ZKA',
        description: 'Deutscher Bankenstandard mit Schlüsselableitung, PIN-Verschlüsselung und MAC-Berechnung.',
      },
      bitmap: {
        title: 'ISO8583 Bitmap',
        description: 'ISO 8583 Bitmaps für Zahlungsnachrichten kodieren und dekodieren. Primäre und sekundäre Bitmaps.',
      },
      cvv: {
        title: 'CVV/CVC',
        description: 'CVV, iCVV, CVV2, dCVV für Kartenverifizierung und Zahlungssicherheit generieren und validieren.',
      },
      amexCsc: {
        title: 'AMEX CSC',
        description: 'AMEX Kartensicherheitscodes (CSC-5, CSC-4, CSC-3) für American Express generieren und validieren.',
      },
      mastercardCvc3: {
        title: 'MasterCard CVC3',
        description: 'Dynamisches CVC3 für MasterCard kontaktlose EMV-Transaktionen generieren.',
      },
      dukpt: {
        title: 'DUKPT (ISO 9797)',
        description: 'PEK von BDK/IPEK und KSN ableiten. PIN ver-/entschlüsseln, MAC berechnen, Daten verarbeiten.',
      },
      dukptAes: {
        title: 'DUKPT (AES)',
        description: 'DUKPT mit AES-Unterstützung (2TDEA, 3TDEA, AES-128/192/256). Arbeitsschlüssel ableiten und Daten verarbeiten.',
      },
      hash: {
        title: 'Hash-Rechner',
        description: 'Hash-Werte mit MD5, SHA-1, SHA-256, SHA-512, BLAKE2 und mehr berechnen.',
      },
      encoding: {
        title: 'Zeichencodierung',
        description: 'Konvertierung zwischen ASCII, EBCDIC, Hexadezimal, Binär und ATM-Dezimal.',
      },
      bcd: {
        title: 'BCD Encoder/Decoder',
        description: 'Dezimalzahlen zu BCD kodieren oder BCD zurück zu Dezimal dekodieren.',
      },
      checkDigits: {
        title: 'Prüfziffern',
        description: 'Prüfziffern mit Luhn (MOD 10) und MOD 9 Algorithmen berechnen und verifizieren.',
      },
      base64: {
        title: 'Base64',
        description: 'Daten mit Base64 Binär-zu-Text-Codierung kodieren und dekodieren.',
      },
      base94: {
        title: 'Base94',
        description: 'Kompakte Codierung mit allen 94 druckbaren ASCII-Zeichen.',
      },
      messageParser: {
        title: 'Nachrichtenparser',
        description: 'ATM NDC, Wincor und ISO 8583 Finanznachrichtenformate analysieren.',
      },
      rsaDer: {
        title: 'RSA DER Öffentlicher Schlüssel',
        description: 'RSA öffentliche Schlüssel zwischen Modulus/Exponent und DER-Format kodieren/dekodieren.',
      },
      uuid: {
        title: 'UUID Generator',
        description: 'Universell eindeutige Kennungen (UUID v1, v3, v4, v5) generieren.',
      },
      // Keys HSM Tools
      keyshareGenerator: {
        title: 'Schlüsselanteil-Generator',
        description: 'Schlüsselanteile für sichere Schlüsselaufteilung und Komponentenverwaltung mit KCV-Berechnung generieren.',
      },
      futurexKeys: {
        title: 'Futurex Schlüssel',
        description: 'Futurex HSM Schlüsselverschlüsselung, -entschlüsselung und -suche mit mehreren Varianten.',
      },
      atallaKeys: {
        title: 'Atalla Schlüssel (AKB)',
        description: 'Atalla AKB-Format Schlüsselverschlüsselung und -entschlüsselung mit MFK und MAC-Verifizierung.',
      },
      safeNetKeys: {
        title: 'SafeNet Schlüssel',
        description: 'SafeNet HSM Schlüsselverschlüsselung, -entschlüsselung und -suche mit KM-Schlüssel-Varianten.',
      },
      thalesKeys: {
        title: 'Thales Schlüssel',
        description: 'Thales HSM LMK Schlüsselverschlüsselung, -entschlüsselung und -suche mit Varianten.',
      },
      thalesKeyBlock: {
        title: 'Thales Schlüsselblock',
        description: 'Thales proprietäre Schlüsselblöcke mit KBPK-Schutz kodieren und dekodieren.',
      },
      sslCert: {
        title: 'SSL Zertifikate',
        description: 'RSA-Schlüsselpaare generieren, CSRs erstellen, selbstsignierte X.509-Zertifikate und Zertifikate analysieren.',
      },
    },
    features: {
      clientSide: {
        title: '100% Browserbasiert',
        description: 'Alle kryptografischen Operationen laufen vollständig im Browser. Ihre Schlüssel, PINs und sensiblen Daten verlassen nie Ihr Gerät.',
      },
      free: {
        title: 'Kostenlos & Offen',
        description: 'Über 25 Tools völlig kostenlos. Keine Registrierung, kein Login, keine versteckten Kosten. Sofort nutzbar.',
      },
      paymentReady: {
        title: 'HSM & Zahlungsbereit',
        description: 'Professionelle Unterstützung für Thales, Futurex, Atalla, SafeNet HSMs. TR-31, KCV, PIN-Block und mehr.',
      },
    },
  },
  
  asn1: {
    title: 'ASN.1 Parser',
    description: 'Analysieren Sie ASN.1 DER/BER-Strukturen mit RFC-Definitionsabgleich',
    infoTitle: 'Über ASN.1 Parser',
    infoContent1: 'Analysiert ASN.1 DER/BER-kodierte Datenstrukturen',
    infoContent2: 'Unterstützt Hex-, Base64- und PEM-Eingabeformate',
    infoContent3: 'RFC-Definitionen aktivieren für bekannte Strukturen wie X.509, PKCS',
    inputLabel: 'Eingabe (Hex, Base64 oder PEM):',
    inputPlaceholder: 'Hex-, Base64- oder PEM-kodierte ASN.1 BER/DER-Strukturen einfügen oder Datei hochladen',
    withHexDump: 'Hex Dump anzeigen',
    trimBigChunks: 'Große Daten kürzen',
    withDefinitions: 'Definitionsabgleich aktivieren',
    uploadFile: 'Datei hochladen',
    parse: 'Analysieren',
    clear: 'Löschen',
    structureDefinition: 'Strukturdefinition:',
    selectDefinition: 'Strukturdefinition auswählen...',
    parsedResult: 'Analyseergebnis:',
    hexDump: 'Hex Dump:',
    offset: 'Offset',
    length: 'Länge',
    value: 'Wert',
    constructed: 'Konstruiert',
    loadError: 'ASN.1-Parsing-Bibliothek konnte nicht geladen werden',
    inputRequired: 'Bitte ASN.1-Daten eingeben',
    parseError: 'Analyse fehlgeschlagen',
    copied: 'Kopiert',
    copyHex: 'Hex kopieren',
    copyHexDump: 'Hex Dump kopieren',
    copyBase64: 'Base64 kopieren',
    copySubtree: 'Teilbaum kopieren',
    copyValue: 'Wert kopieren',
  },
  
  dukpt: {
    title: 'DUKPT (ISO 9797)',
    subtitle: 'Schlüssel ableiten und Daten verschlüsseln/entschlüsseln mit DUKPT (Derived Unique Key Per Transaction) Standard.',
    infoTitle: 'Über DUKPT',
    info1: 'DUKPT (Derived Unique Key Per Transaction) ist ein Schlüsselverwaltungsschema für POS- und ATM-Systeme.',
    info2: 'Es leitet für jede Transaktion einen eindeutigen Verschlüsselungsschlüssel von einem Base Derivation Key (BDK) und Key Serial Number (KSN) ab, um sicherzustellen, dass kompromittierte Schlüssel nicht für die Entschlüsselung vergangener Transaktionen verwendet werden können.',
    tabPekDerivation: 'PEK Ableitung',
    tabDukptPin: 'DUKPT PIN',
    tabDukptMac: 'DUKPT MAC',
    tabDukptData: 'DUKPT DATA',
    inputKeyDesignation: 'Eingabeschlüsselbezeichnung',
    bdk: 'BDK',
    ipek: 'IPEK',
    ksn: 'KSN',
    pek: 'PEK',
    pinBlock: 'PIN-Block',
    algorithm: 'Algorithmus',
    des: 'DES',
    threeDes: '3DES',
    data: 'Daten',
    dataVariant: 'Datenvariante',
    dataInput: 'Dateneingabe',
    ascii: 'ASCII',
    hexadecimal: 'Hexadezimal',
    derivePek: 'PEK ableiten',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    calculateMac: 'MAC berechnen',
    result: 'Ergebnis',
    mac: 'MAC',
    errorInvalidBdk: 'BDK muss 32 Hex-Zeichen sein',
    errorInvalidIpek: 'IPEK muss 32 Hex-Zeichen sein',
    errorInvalidKsn: 'KSN muss 20 Hex-Zeichen sein',
    errorInvalidPek: 'PEK muss 32 Hex-Zeichen sein',
    errorInvalidPekPin: 'PEK muss 32 Hex-Zeichen sein',
    errorInvalidPinBlock: 'PIN-Block muss 16 Hex-Zeichen sein',
    errorInvalidPekMac: 'PEK muss 32 oder 48 Hex-Zeichen sein',
    errorInvalidPekData: 'PEK muss 32 Hex-Zeichen sein',
    errorInvalidData: 'Daten sind erforderlich',
    errorInvalidEncryptedData: 'Verschlüsselte Daten müssen ein Vielfaches von 16 Hex-Zeichen sein',
    errorDerivation: 'Fehler beim Ableiten des PEK',
    errorEncryption: 'Fehler beim Verschlüsseln des PIN-Blocks',
    errorDecryption: 'Fehler beim Entschlüsseln des PIN-Blocks',
    errorMacCalculation: 'Fehler beim Berechnen des MAC',
    errorDataEncryption: 'Fehler beim Verschlüsseln der Daten',
    errorDataDecryption: 'Fehler beim Entschlüsseln der Daten',
  },
  dukptAes: {
    title: 'DUKPT (AES)',
    subtitle: 'Schlüssel ableiten und Daten verschlüsseln/entschlüsseln mit DUKPT mit AES-Unterstützung.',
    infoTitle: 'Über DUKPT (AES)',
    info1: 'DUKPT (Derived Unique Key Per Transaction) mit AES-Unterstützung erweitert den ursprünglichen DUKPT-Standard um AES-Verschlüsselungsalgorithmen.',
    info2: 'Es unterstützt 2TDEA, 3TDEA, AES-128, AES-192 und AES-256 Verschlüsselung und bietet verbesserte Sicherheit für moderne Zahlungssysteme.',
    tabWorkingKeyDerivation: 'Arbeitsschlüssel-Ableitung',
    tabDukptPin: 'DUKPT PIN',
    tabDukptMac: 'DUKPT MAC',
    tabDukptData: 'DUKPT DATA',
    inputKeyDesignation: 'Eingabeschlüsselbezeichnung',
    bdk: 'BDK',
    ik: 'IK',
    workingKeyType: 'Arbeitsschlüsseltyp',
    ksn: 'KSN',
    pek: 'PEK',
    pinBlock: 'PIN-Block',
    macGen: 'MAC Gen.',
    dek: 'DEK',
    dataInput: 'Dateneingabe',
    ascii: 'ASCII',
    hexadecimal: 'Hexadezimal',
    data: 'Daten',
    deriveKey: 'Schlüssel ableiten',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    calculateMac: 'MAC berechnen',
    result: 'Ergebnis',
    workingKey: 'Arbeitsschlüssel',
    mac: 'MAC',
    errorInvalidKeyLength: '{keyDesignation} muss {expectedLength} Hex-Zeichen sein',
    errorInvalidKsn: 'KSN muss 24 Hex-Zeichen sein',
    errorInvalidPekLength: 'PEK muss {expectedLength} Hex-Zeichen sein',
    errorInvalidPinBlock: 'PIN-Block muss 32 Hex-Zeichen sein',
    errorInvalidMacLength: 'MAC Gen. muss {expectedLength} Hex-Zeichen sein',
    errorInvalidDekLength: 'DEK muss {expectedLength} Hex-Zeichen sein',
    errorInvalidData: 'Daten sind erforderlich',
    errorInvalidEncryptedData: 'Verschlüsselte Daten müssen ein Vielfaches von {blockSize} Hex-Zeichen sein',
    errorDerivation: 'Fehler beim Ableiten des Arbeitsschlüssels',
    errorEncryption: 'Fehler beim Verschlüsseln',
    errorDecryption: 'Fehler beim Entschlüsseln',
    errorMacCalculation: 'Fehler beim Berechnen des MAC',
    errorDataEncryption: 'Fehler beim Verschlüsseln der Daten',
    errorDataDecryption: 'Fehler beim Entschlüsseln der Daten',
  },

  keyGenerator: {
    title: 'Zufälliger Schlüsselgenerator',
    description: 'Generieren Sie kryptografisch starke Zufallsschlüssel für DES, 3DES oder AES.',
    infoTitle: 'Über den Schlüsselgenerator',
    infoContent1: 'Generiert kryptografisch sichere Zufallsschlüssel mit Web Crypto API',
    infoContent2: 'Unterstützt DES (8 Bytes), 3DES (16/24 Bytes) und AES (16/24/32 Bytes)',
    infoContent3: 'KCV (Schlüsselprüfwert) wird zur Schlüsselverifizierung berechnet',
    keyLength: 'Schlüssellänge',
    bytes: 'Bytes',
    bits: 'Bits',
    generateNow: 'Jetzt generieren',
    generatedKey: 'Generierter Schlüssel (Hexadezimal)',
    kcv: 'KCV',
    length: 'Länge',
    tabKeyGen: 'Generator',
    tabCombination: 'Kombination',
    tabParity: 'Parität',
    tabValidation: 'Validierung',
    combinationTitle: 'Schlüsselkombination',
    combinationDesc: 'Kombinieren Sie mehrere Schlüsselkomponenten per XOR',
    component: 'Komponente',
    components: 'Komponenten',
    combinedKey: 'Kombinierter Schlüssel',
    addComponent: 'Hinzufügen',
    removeComponent: 'Entfernen',
    combineKeys: 'Kombinieren',
    errorInvalidComponent: 'Komponente {index} ungültig',
    errorComponentLength: 'Alle Komponenten müssen die gleiche Länge haben',
    errorComponentLength2: 'Länge muss sein',
    errorMinComponents: 'Mindestens 2 Komponenten erforderlich',
    errorMaxComponents: 'Maximal 9 Komponenten erlaubt',
    clearAll: 'Alles löschen',
    parityTitle: 'Paritätsanpassung',
    parityDesc: 'Paritätsbits für DES/3DES-Schlüssel anpassen',
    keyInput: 'Schlüsseleingabe',
    keyInputPlaceholder: 'Hexadezimalen Schlüssel eingeben',
    parityType: 'Paritätstyp',
    odd: 'Ungerade',
    even: 'Gerade',
    adjustParity: 'Anpassen',
    adjustedKey: 'Angepasster Schlüssel',
    validationTitle: 'Schlüsselvalidierung',
    validationDesc: 'Format, Länge und Parität prüfen',
    validateKey: 'Validieren',
    validKey: 'Gültiger Schlüssel',
    invalidKey: 'Ungültiger Schlüssel',
    keyType: 'Schlüsseltyp',
    parityStatus: 'Paritätsstatus',
    parityValid: 'Gültig',
    parityInvalid: 'Ungültig',
  },
  
  kcvCalculator: {
    title: 'KCV-Rechner',
    description: 'Berechnen Sie den Schlüsselprüfwert zur Überprüfung der Schlüsselkorrektheit.',
    algorithm: 'Algorithmus',
    keyInput: 'Schlüssel (Hexadezimal)',
    keyPlaceholder: 'z.B.: 0123456789ABCDEFFEDCBA9876543210',
    calculateKCV: 'KCV berechnen',
    keyCheckValue: 'Schlüsselprüfwert',
    errorInvalidHex: 'Der Schlüssel muss aus gültigen Hexadezimalzeichen bestehen',
    errorDesLength: 'DES/3DES-Schlüssellänge muss 8, 16 oder 24 Bytes betragen',
    errorAesLength: 'AES-Schlüssellänge muss 16, 24 oder 32 Bytes betragen',
    errorCalculation: 'Berechnung fehlgeschlagen, bitte Schlüsselformat überprüfen',
    format: 'Format',
    autoAdjustParity: 'Paritätsbits automatisch anpassen',
    parityAdjustmentHint: 'Einige Schlüssel haben möglicherweise keine korrekten Paritätsbits, aktivieren Sie diese Option zur automatischen Korrektur',
    kcvCalcTitle: 'Berechnung des Schlüsselprüfwerts',
    desCalcDesc: 'Verwenden Sie den Klartext des Schlüssels, um 16 Zeichen lange \'0\' mit dem 3DES-ECB-Algorithmus zu verschlüsseln, und extrahieren Sie dann die ersten sechs Zeichen des verschlüsselten Werts als Schlüsselprüfwert',
    aesCalcDesc: 'Verwenden Sie den Klartext des Schlüssels, um 32 Zeichen lange \'0\' mit dem CMAC-AES-Algorithmus zu verschlüsseln, und extrahieren Sie dann die ersten sechs Zeichen des verschlüsselten Werts als Schlüsselprüfwert',
  },
  
  pinBlock: {
    title: 'PIN-Block-Generator',
    description: 'Generieren Sie ISO-Format-PIN-Blöcke für Zahlungstransaktionen.',
    format: 'PIN-Block-Format',
    pinLabel: 'PIN (4-12 Ziffern)',
    pinPlaceholder: 'z.B.: 1234',
    panLabel: 'PAN (Primäre Kontonummer)',
    panPlaceholder: 'z.B.: 4111111111111111',
    generatePinBlock: 'PIN-Block generieren',
    pinBlockHex: 'PIN-Block (Hexadezimal)',
    errorInvalidPin: 'PIN muss 4-12 Ziffern lang sein',
    errorInvalidPan: 'PAN muss 13-19 Ziffern lang sein',
    errorGeneration: 'Generierung fehlgeschlagen, bitte Eingabe überprüfen',
    errorFormat1: 'ISO Format 1 in Kürze verfügbar...',
    pinLengthHint: 'Unterstützt 4-12 stellige PIN',
    panHint: 'Geben Sie die vollständige Kartennummer ein (13-19 Ziffern), das System extrahiert automatisch die rechtesten 12 Ziffern (ohne Prüfziffer)',
  },

  pinBlockGeneral: {
    title: 'PIN-Blöcke',
    infoTitle: 'Über PIN-Blöcke',
    info1: 'ISO 9564 definiert PIN-Block-Formate für sichere PIN-Übertragung in Zahlungssystemen.',
    info2: 'Format 0: XOR mit PAN (am häufigsten). Format 1: Kein PAN erforderlich (zufälliges Padding).',
    info3: 'Formate 2-4: Verbesserte Sicherheit mit unterschiedlichen PAN-Kodierungen und zufälligen Padding-Schemata.',
    formatLabel: 'PIN-Block-Format:',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    panLabel: 'PAN:',
    panPlaceholder: '456789012345cccc',
    pinLabel: 'PIN:',
    pinPlaceholder: '123456',
    pinBlockLabel: 'PIN-Block:',
    pinBlockPlaceholder: '041226FFFFFFFF1234',
    paddingLabel: 'Padding-Zeichen:',
    paddingHint: 'Einzelne Hexadezimalziffer (0-9, A-F). Standard: F',
    encodeButton: 'Kodieren',
    decodeButton: 'Dekodieren',
    resultPinBlock: 'PIN-Block (Hex)',
    resultPin: 'Dekodierte PIN',
    format: 'Format',
    length: 'Länge',
    hexChars: 'Hex-Zeichen',
    pinLength: 'PIN-Länge',
    errorInvalidPin: 'PIN muss 4-12 Ziffern lang sein',
    errorInvalidPan: 'PAN muss 13-19 Ziffern lang sein',
    errorInvalidPinBlock: 'Ungültige PIN-Block-Länge',
    errorInvalidFormat: 'Ungültiges PIN-Block-Format',
    errorInvalidPinLength: 'Ungültige PIN-Länge im Block',
    errorProcessing: 'Verarbeitung fehlgeschlagen, bitte Eingabe überprüfen',
  },
  
  pinBlockAes: {
    title: 'AES PIN-Block Format 4',
    infoTitle: 'Über AES PIN-Blöcke',
    info1: 'PIN-Block Format 4 ist speziell für AES-Verschlüsselung mit 128-Bit-Blockgröße entwickelt.',
    info2: 'Im Gegensatz zu älteren Formaten verwendet Format 4 einen 32-Hex-Zeichen-Block (16 Bytes), der für AES geeignet ist.',
    info3: 'Der PIN-Block wird vor der AES-Verschlüsselung mit dem PAN-Block XOR-verknüpft für erhöhte Sicherheit.',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    keyLabel: 'Schlüssel:',
    keyPlaceholder: 'C1D0F8FB4958670DBA40AB1F3752EF0D',
    keyHint: 'AES-128-Schlüssel: 32 Hex-Zeichen (16 Bytes)',
    panLabel: 'PAN (Kartennummer):',
    panPlaceholder: '4567890123456789',
    panHint: '13-19 Ziffern',
    pinLabel: 'PIN:',
    pinPlaceholder: '1234',
    pinHint: '4-12 Ziffern',
    encryptedBlockLabel: 'Verschlüsselter Block:',
    encryptedBlockPlaceholder: 'E14F478E9A8F7D5C1B2E3A4D5C6F7A8B',
    encryptedBlockHint: '32 Hex-Zeichen (16 Bytes)',
    encryptButton: 'Verschlüsseln',
    decryptButton: 'Entschlüsseln',
    showIntermediateSteps: 'Zwischenschritte anzeigen',
    intermediateTitle: 'Zwischenschritte',
    clearPinBlock: 'Klarer PIN-Block (vor Verschlüsselung)',
    panBlock: 'PAN-Block',
    xorResult: 'XOR-Ergebnis (AES-Eingabe)',
    encryptedResult: 'Verschlüsselungsergebnis (AES-Ausgabe)',
    decryptedXor: 'Entschlüsseltes XOR-Ergebnis',
    extractedPinBlock: 'Extrahierter PIN-Block',
    errorInvalidKey: 'Schlüssel muss 32 Hex-Zeichen haben (AES-128)',
    errorInvalidPin: 'PIN muss 4-12 Ziffern lang sein',
    errorInvalidPan: 'PAN muss 13-19 Ziffern lang sein',
    errorInvalidBlock: 'Verschlüsselter Block muss 32 Hex-Zeichen haben',
    errorProcessing: 'Verarbeitung fehlgeschlagen, bitte Eingabe überprüfen',
  },
  
  as2805: {
    infoTitle: 'Über AS2805 Tools',
    info1: 'Enthält Generierung von Terminal-Schlüsselsätzen, PIN-Block-Übersetzung (Formate 01/46), MAC-Berechnung (ISO9797-1 M2, TDES-CBC) und OWF (HMAC-SHA256). Alle Vorgänge erfolgen clientseitig.',
    description: 'Clientseitige Implementierungen gängiger Zahlungsoperationen',
    tabGenerate: 'Terminal-Schlüsselsatz erzeugen',
    tabTranslatePin: 'PIN-Block übersetzen',
    kekFlag: 'KEK-Flag',
    kekrKey: 'KEKr-Schlüssel',
    schemeKek: 'Schlüsselschema KEK',
    schemeLmk: 'Schlüsselschema LMK',
    kcvType: 'KCV-Typ',
    translate: 'Übersetzen',
    sysZpk: 'System-ZPK',
    termTpk: 'Terminal-TPK',
    stan: 'STAN',
    amount: 'Transaktionsbetrag',
    inFmt: 'Eingehendes PIN-Block-Format',
    outFmt: 'Ausgehendes PIN-Block-Format',
    inPinBlock: 'Eingehender PIN-Block',
    account: 'Kontonummer',
    key: 'Schlüssel',
    data: 'Daten',
    errorInvalidHex: 'Ungültige hexadezimale Eingabe',
    errorGeneration: 'Erzeugung fehlgeschlagen',
    errorPinBlock: 'PIN-Block muss 16 Hex-Zeichen haben',
    errorAccount: 'Kontonummer muss 12–19 Ziffern enthalten',
    errorKeyLength: 'Ungültige Schlüssellänge',
    errorCalculation: 'Berechnung fehlgeschlagen',
  },
  
  pinOffset: {
    title: 'PIN Offset (IBM 3624 Methode)',
    infoTitle: 'Über PIN Offset',
    info1: 'Die IBM 3624-Methode berechnet den PIN-Offset mit 3DES-Verschlüsselung unter Verwendung von PDK und Dezimalisierungstabelle.',
    info2: 'Der Offset wird als (Kunden-PIN - Natürliche PIN) mod 10 berechnet.',
    info3: 'Validierungsdaten können mit Parametern oder einem Maskenmuster für flexible PIN-Verifizierung extrahiert werden.',
    tabOffset: 'Offset',
    tabPin: 'PIN',
    pdkLabel: 'PDK:',
    pdkPlaceholder: '0123456789ABCDEFFEDCBA9876543210',
    panLabel: 'PAN:',
    panPlaceholder: '1234567899876543',
    pinLabel: 'PIN:',
    pinPlaceholder: '3196',
    offsetLabel: 'PIN-Offset:',
    offsetPlaceholder: '0000',
    decTabLabel: 'DecTab:',
    validationDataLabel: 'Validierungsdaten',
    useParameters: 'Validierungsdatenparameter verwenden',
    useMask: 'Validierungsdatenmaske verwenden',
    startLabel: 'Start:',
    lengthLabel: 'Länge:',
    padLabel: 'Auffüllung:',
    pinLengthLabel: 'PIN-Länge:',
    validationMaskLabel: 'Validierungsdatenmaske:',
    maskHint: 'N für natürliche PIN-Ziffern verwenden, 0-9 für feste Werte',
    calculateOffset: 'Offset berechnen',
    calculatePin: 'PIN berechnen',
    offsetResult: 'PIN-Offset',
    pinResult: 'Berechnete PIN',
    errorInvalidPdk: 'PDK muss 32 Hex-Zeichen haben (16 Bytes)',
    errorInvalidPan: 'PAN muss 12-19 Ziffern haben',
    errorInvalidPin: 'PIN muss 4-12 Ziffern haben',
    errorInvalidOffset: 'PIN-Offset muss 4-12 Ziffern haben',
    errorInvalidDecTab: 'DecTab muss 16 Ziffern haben',
    errorInvalidMask: 'Validierungsmaske darf nur Ziffern und N enthalten',
    errorProcessing: 'Verarbeitung fehlgeschlagen, bitte Eingabe überprüfen',
  },

  pinPvv: {
    title: 'PIN PVV-Rechner',
    infoTitle: 'Über PIN PVV',
    info1: 'PIN Verification Value (PVV) ist ein Visa-Standard für die PIN-Verifizierung. Er verwendet einen PIN Derivation Key (PDK), um die Kartennummer (PAN) zu verschlüsseln, wendet Dezimalisierung an und berechnet einen 4-stelligen Verifizierungswert.',
    info2: 'Der PVV-Tab berechnet den PVV aus einer PIN. Der PIN-Tab verifiziert eine PIN, indem sie aus einem bekannten PVV berechnet wird.',
    info3: 'PVKI (PIN Verification Key Index) bestimmt, welche Position im verschlüsselten Ergebnis für die Verifizierung verwendet wird.',
    tabPvv: 'PVV',
    tabPin: 'PIN',
    pdkLabel: 'PDK',
    panLabel: 'PAN',
    pinLabel: 'PIN',
    pvvLabel: 'PVV',
    pvkiLabel: 'PVKI',
    pdkHint: '32 Hex-Zeichen (16 Bytes) - PIN Derivation Key',
    panHint: '12-19 Ziffern - Primäre Kontonummer',
    pinHint: '4-12 Ziffern - Kunden-PIN',
    pvvHint: '4 Ziffern - PIN Verification Value',
    pvkiHint: '0-9 - PIN Verification Key Index',
    calculatePvv: 'PVV berechnen',
    calculatePin: 'PIN berechnen',
    pvvResult: 'PVV',
    pinResult: 'PIN',
    encryptedPan: 'Verschlüsselte PAN',
    tsp: 'TSP (Transformed Selection)',
    pvvCalculated: 'PVV erfolgreich berechnet',
    pinCalculated: 'PIN erfolgreich berechnet',
    copied: 'in Zwischenablage kopiert',
    errorInvalidPdk: 'PDK muss 32 Hex-Zeichen haben',
    errorInvalidPan: 'PAN muss 12-19 Ziffern haben',
    errorInvalidPin: 'PIN muss 4-12 Ziffern haben',
    errorInvalidPvv: 'PVV muss 4 Ziffern haben',
    errorProcessing: 'Fehler bei der Berechnung',
  },

  visaCertificates: {
    title: 'VISA Zertifikat-Validator',
    infoTitle: 'Über VISA Zertifikate',
    info1: 'Aussteller-Zertifikats-Signieranfragen validieren und signierte öffentliche Schlüsseldaten verifizieren',
    info2: 'Unterstützt VSDC CA V92, V94 oder benutzerdefinierte CA-Schlüssel',
    description: 'VISA Aussteller-Zertifikate für EMV-Zahlungskarten validieren und verifizieren',
    tabRequest: 'Aussteller-Signieranfrage validieren',
    tabSigned: 'Signierte Aussteller-Öffentliche-Schlüssel-Daten validieren',
    loadRequestFile: 'Aussteller-Zertifikatsanfrage-Datei laden ...',
    loadSignedFile: 'Signierte Aussteller-Öffentliche-Schlüssel-Daten-Datei laden ...',
    loadCaFile: 'CA-Öffentlicher-Schlüssel-Datei laden ...',
    debug: 'Debug',
    requestDataLabel: 'Aussteller-Zertifikatsanfrage-Daten:',
    signedDataLabel: 'Signierte Aussteller-Öffentliche-Schlüssel-Daten:',
    caKeyLabel: 'CA-Öffentlicher Schlüssel:',
    requestDataPlaceholder: 'Hex-Daten eingeben (z.B.: 22B0E1D3EC02...)',
    signedDataPlaceholder: 'Hex-Daten eingeben (z.B.: 2410100000004455...)',
    caKeyPlaceholder: 'CA-Öffentlicher Schlüssel wird automatisch geladen oder manuell eingegeben',
    validate: 'Validieren',
    validationSuccess: 'Validierung erfolgreich',
    validationFailed: 'Validierung fehlgeschlagen',
    debugInfo: 'Debug-Informationen:',
    lengthBytes: 'Länge: {0} Bytes',
    fileLoadSuccess: 'Datei erfolgreich geladen',
    fileLoadError: 'Datei konnte nicht geladen werden',
    errorInvalidHex: 'Ungültige Hex-Daten',
    errorTooShort: 'Ungültige Zertifikatsanfrage: zu kurz',
    errorDataTooShort: 'Ungültige Daten: zu kurz',
    errorNoCA: 'Bitte wählen Sie einen CA-Öffentlichen Schlüssel oder geben Sie einen an',
    errorInvalidSignedHex: 'Ungültige signierte Daten-Hex',
    errorValidationFailed: 'Validierung fehlgeschlagen: {0}',
    aboutRequestTitle: 'Über Zertifikatsanfrage',
    aboutRequestText1: 'Die Aussteller-Zertifikatsanfrage enthält den Öffentlichen Schlüssel und andere Zertifikatsinformationen, die von der CA signiert werden müssen.',
    aboutRequestText2: 'Dieses Tool validiert die Struktur und das Format der Zertifikatsanfrage, bevor sie zur Signierung an die CA gesendet wird.',
    aboutSignedTitle: 'Über signierte Öffentliche-Schlüssel-Daten',
    aboutSignedText1: 'Die signierten Aussteller-Öffentliche-Schlüssel-Daten enthalten das von der VISA CA signierte Zertifikat.',
    aboutSignedText2: 'Dieses Tool validiert die Signatur mit dem entsprechenden CA-Öffentlichen Schlüssel.',
    aboutCaTitle: 'Über CA-Öffentlichen Schlüssel',
    aboutCaText1: 'Wählen Sie einen vordefinierten VISA CA-Öffentlichen Schlüssel oder laden Sie einen benutzerdefinierten.',
    aboutCaText2: 'Der CA-Öffentliche Schlüssel wird verwendet, um die Signatur auf dem Aussteller-Zertifikat zu verifizieren.',
  },
  
  tr31: {
    title: 'TR-31-Schlüsselblock',
    description: 'TR-31/ANSI X9.143 Schlüsselblöcke mit KBPK-Schutz kodieren/dekodieren',
    keyBlock: 'TR-31-Schlüsselblock',
    keyBlockPlaceholder: 'z.B.: D0144B1AX00E0000...',
    parseKeyBlock: 'Schlüsselblock analysieren',
    header: 'Schlüsselblock-Header',
    version: 'Version',
    keyLength: 'Länge',
    keyUsage: 'Schlüsselverwendung',
    mode: 'Modus',
    keyVersion: 'Schlüsselversion',
    exportability: 'Exportierbarkeit',
    characters: 'Zeichen',
    errorTooShort: 'TR-31-Schlüsselblocklänge unzureichend',
    errorParsing: 'Analyse fehlgeschlagen, bitte TR-31-Format überprüfen',
    exportable: 'Exportierbar',
    nonExportable: 'Nicht exportierbar',
    sensitive: 'Sensibel',
    keyBlockFormatHint: 'TR-31 Schlüsselblock-Format (z.B. D0144B1AX00E0000...), das System validiert das Format automatisch',
  },

  tr31KeyBlock: {
    title: 'TR-31 Schlüsselblock',
    description: 'TR-31/ANSI X9.143 Schlüsselblöcke mit KBPK-Schutz kodieren/dekodieren',
    infoTitle: 'Über TR-31 Schlüsselblock',
    infoContent1: 'TR-31 (ANSI X9.143) ist der Branchenstandard für sicheren kryptografischen Schlüsselaustausch in Zahlungssystemen.',
    infoContent2: 'Schlüsselblöcke enthalten verschlüsselte Schlüsseldaten mit Metadaten (Verwendung, Algorithmus, Exportierbarkeit).',
    infoContent3: 'KBPK (Key Block Protection Key) schützt den verpackten Schlüssel mit TDES- oder AES-Verschlüsselung.',
    kbpkPlaceholder: 'KBPK eingeben - 32/48 Hex für TDES, 32/48/64 Hex für AES',
    keyBlockVersion: 'Schlüsselblock-Version',
    tabEncode: 'Kodieren',
    tabDecode: 'Dekodieren',
    plainKey: 'Klartext-Schlüssel',
    plainKeyPlaceholder: 'Klartext-Schlüssel in Hex eingeben (16/24/32 Bytes)',
    header: 'Header',
    versionId: 'Versions-ID',
    keyUsage: 'Schlüsselverwendung',
    algorithm: 'Algorithmus',
    modeOfUse: 'Verwendungsmodus',
    keyVersionNum: 'Schlüsselversion#',
    exportability: 'Exportierbarkeit',
    optKeyBlocks: 'Opt. Schlüsselblöcke',
    reserved: 'Reserviert',
    optionalHeadersSection: 'Optionale Header',
    optionalHeaders: 'Optionale Header',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    keyBlock: 'Schlüsselblock',
    keyBlockPlaceholder: 'TR-31 Schlüsselblockdaten eingeben (z.B. D0144B1AX00E0000...)',
    encodeResult: 'Kodierter Schlüsselblock',
    decodeResult: 'Dekodierter Schlüsselblock',
    headerInfo: 'Header',
    encodeSuccess: 'Schlüsselblock erfolgreich kodiert',
    decodeSuccess: 'Schlüsselblock erfolgreich dekodiert',
    errorInvalidKey: 'Ungültiges Klartext-Schlüsselformat',
    errorInvalidKbpk: 'Ungültiges KBPK-Format (mindestens 32 Hex-Zeichen erforderlich)',
    errorKeyBlockShort: 'Schlüsselblock ist zu kurz',
    errorEncode: 'Kodierung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
  },
  
  placeholder: {
    title: 'Demnächst verfügbar',
    description: 'Dieses Tool befindet sich in der Entwicklung. Bleiben Sie dran!',
  },

  hash: {
    title: 'Hash-Rechner',
    description: 'Hash-Werte mit verschiedenen Algorithmen wie MD5, SHA-1, SHA-256, SHA-512 berechnen',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    hashType: 'Hash-Typ',
    inputData: 'Eingabedaten',
    hashResult: 'Hash-Ergebnis',
    asciiPlaceholder: 'Textdaten eingeben...',
    hexPlaceholder: 'Hexadezimaldaten eingeben...',
    byteLength: 'Bytes',
    calculate: 'Hash berechnen',
    algorithmInfo: 'Algorithmusinformation',
    outputLength: 'Ausgabelänge',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorOddHex: 'Hexadezimaleingabe muss eine gerade Anzahl von Zeichen haben',
    errorCalculation: 'Hash-Berechnung fehlgeschlagen',
    faqTitle: 'Hash-Rechner FAQ',
    faq1Question: 'Was ist eine Hash-Funktion?',
    faq1Answer: 'Eine Hash-Funktion ist ein mathematischer Algorithmus, der Eingabedaten beliebiger Größe in eine Ausgabe fester Größe (Hash-Wert) umwandelt. Sie ist deterministisch und einseitig.',
    faq2Question: 'Welchen Hash-Algorithmus sollte ich verwenden?',
    faq2Answer: 'Für Sicherheitszwecke verwenden Sie SHA-256 oder SHA-512. MD5 und SHA-1 gelten für kryptografische Zwecke als unsicher, können aber für Prüfsummen verwendet werden.',
    usageTitle: 'Verwendung',
    usage1: 'Eingabetyp auswählen (ASCII-Text oder Hexadezimal)',
    usage2: 'Hash-Algorithmus aus dem Dropdown auswählen',
    usage3: 'Daten in das Eingabefeld eingeben',
    usage4: '"Hash berechnen" klicken, um den Hash-Wert zu generieren',
    hashInfo: 'Hash-Funktionen sind einweg - nicht umkehrbar',
    inputLength: 'Eingabe',
  },

  encoding: {
    title: 'Zeichenkodierung',
    description: 'Zwischen verschiedenen Zeichenkodierungen und Formaten konvertieren',
    encodingType: 'Kodierung',
    data: 'Daten',
    convert: 'Konvertieren',
    result: 'Konvertierungsergebnis',
    conversionInfo: 'Konvertierungsinformation',
    ebcdicInfo: 'EBCDIC wird auf IBM-Großrechnern verwendet',
    atmInfo: 'ATM-Format verwendet durch Leerzeichen getrennte Dezimalwerte (0-255)',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorConversion: 'Konvertierung fehlgeschlagen',
    placeholderBinary: 'Daten eingeben (z.B. 57652C206174...)',
    placeholderHex: 'Hexadezimaldaten eingeben',
    placeholderText: 'ASCII-Text eingeben',
    placeholderAtm: 'Durch Leerzeichen getrennte Dezimalwerte eingeben (z.B. 065 066 067)',
    faqTitle: 'Zeichenkodierung FAQ',
    faq1Question: 'Was ist Zeichenkodierung?',
    faq1Answer: 'Zeichenkodierung ist ein System, das jedes Zeichen mit einer eindeutigen Nummer oder Bytefolge verknüpft, sodass Computer Text speichern und übertragen können.',
    faq2Question: 'Was ist EBCDIC?',
    faq2Answer: 'EBCDIC (Extended Binary Coded Decimal Interchange Code) ist eine 8-Bit-Zeichenkodierung, die hauptsächlich auf IBM-Großrechnern und Midrange-Systemen verwendet wird.',
    usageTitle: 'Verwendung',
    usage1: 'Konvertierungstyp aus dem Dropdown auswählen',
    usage2: 'Daten im entsprechenden Format eingeben',
    usage3: '"Konvertieren" klicken, um das Ergebnis zu sehen',
  },

  bcd: {
    title: 'Binär codierte Dezimalzahl (BCD)',
    description: 'Dezimalzahlen zu BCD kodieren oder BCD zurück zu Dezimal dekodieren',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    inputFormat: 'Eingabeformat',
    binary: 'Binär',
    hexadecimal: 'Hexadezimal',
    data: 'Daten',
    info: 'BCD-Information',
    encodeInfo1: 'Jede Dezimalziffer (0-9) wird als 4 Bits kodiert',
    encodeInfo2: 'Beispiel: 25 → 0010 0101 (binär) / 25 (hex)',
    decodeInfo1: 'Jedes 4-Bit-Nibble muss 0-9 sein (nicht A-F)',
    decodeInfo2: 'Beispiel: 0010 0101 → 25',
    encodeResult: 'BCD-kodiertes Ergebnis',
    decodeResult: 'Dekodierte Dezimalzahl',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidDecimal: 'Ungültige Eingabe: nur Ziffern 0-9 erlaubt',
    errorInvalidBinary: 'Ungültige Binäreingabe (nur 0 und 1, Länge ein Vielfaches von 4)',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorConversion: 'Konvertierung fehlgeschlagen',
    placeholderEncode: 'Dezimalzahl eingeben (z.B. 12345)',
    placeholderBinary: 'BCD-Binär eingeben (z.B. 0010 0101)',
    placeholderHex: 'BCD-Hexadezimal eingeben (z.B. 25)',
    faqTitle: 'BCD FAQ',
    faq1Question: 'Was ist BCD?',
    faq1Answer: 'Binär codierte Dezimalzahl (BCD) ist eine Klasse von Binärkodierungen für Dezimalzahlen, bei der jede Dezimalziffer durch eine feste Anzahl von Bits (normalerweise vier) dargestellt wird.',
    faq2Question: 'Warum wird BCD verwendet?',
    faq2Answer: 'BCD wird in Finanz- und Geschäftsanwendungen verwendet, wo Dezimalpräzision wichtig ist, und in Systemen, die Dezimalziffern direkt anzeigen müssen.',
    usageTitle: 'Verwendung',
    usage1: '"Kodieren" wählen, um Dezimal zu BCD zu konvertieren',
    usage2: '"Dekodieren" wählen, um BCD zurück zu Dezimal zu konvertieren',
    usage3: 'Beim Dekodieren Binär- oder Hexadezimal-Eingabeformat wählen',
  },

  bitmap: {
    title: 'ISO8583 Bitmap',
    description: 'Bitmap (Hexadezimaldaten) in Bits analysieren und Bitmap aus Binärdaten konstruieren.',
    bitmapLabel: 'Bitmap',
    bitmapPlaceholder: 'z.B. B0300054020000000000000010000001',
    bitmapHint: 'Hexadezimale Bitmap eingeben oder Bits unten auswählen. Bit 1 gibt das Vorhandensein einer sekundären Bitmap an (ISO8583-Standard).',
    primaryBitmap: 'Primäre Bitmap',
    secondaryBitmap: 'Sekundäre Bitmap',
    bits: 'Bits',
    copySuccess: 'In Zwischenablage kopiert',
    copyError: 'Kopieren fehlgeschlagen',
    errorNoBitmap: 'Bitte Bitmap eingeben oder generieren',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    infoTitle: 'Über ISO8583 Bitmap',
    info1: 'Die ISO 8583 Bitmap zeigt an, welche Datenfelder in der Nachricht vorhanden sind.',
    info2: 'Die primäre Bitmap (64 Bits) deckt die Felder 1-64 ab. Wenn Bit 1 gesetzt ist, folgt eine sekundäre Bitmap (65-128).',
    info3: 'Jede Bitposition entspricht einer Datenfeldnummer in der ISO8583-Nachricht.',
  },

  cvv: {
    title: 'Kartenprüfwert',
    description: 'CVV/CVC, iCVV, CVV2/CVC2 und dCVV für Zahlungskartensicherheit generieren und validieren.',
    infoTitle: 'Über CVV/CVC',
    info1: 'CVV (Card Verification Value) und CVC (Card Verification Code) sind Sicherheitsfunktionen für Transaktionen ohne Kartenvorlage.',
    info2: 'CVV/CVC: Auf Karte gedruckt (3 Ziffern). CVV2/CVC2: Erweiterte Version. iCVV: Integrierter Chip-CVV. dCVV: Dynamischer CVV für kontaktlos.',
    info3: 'Generiert mit Kartendaten (PAN, Ablaufdatum, Servicecode), verschlüsselt mit Herausgeber-CVK-Schlüsseln.',
    tabGenerate: 'Generieren',
    tabValidate: 'Validieren',
    cvkA: 'CVK A',
    cvkB: 'CVK B',
    pan: 'PAN',
    expDate: 'Ablaufdatum',
    serviceCode: 'Servicecode',
    atc: 'ATC',
    cvvLabel: 'CVV/CVC',
    verificationType: 'Verifizierungswerttyp',
    errorInvalidCvkA: 'CVK A muss 32 Hex-Zeichen (16 Bytes) sein',
    errorInvalidCvkB: 'CVK B muss 32 Hex-Zeichen (16 Bytes) sein',
    errorInvalidPan: 'PAN muss 13-19 Ziffern sein',
    errorInvalidExpDate: 'Ablaufdatum muss 4 Ziffern sein (YYMM)',
    errorInvalidServiceCode: 'Servicecode muss 3 Ziffern sein',
    errorInvalidAtc: 'ATC muss 4 Ziffern für iCVV/dCVV sein',
    errorInvalidCvv: 'CVV muss 3 Ziffern sein',
    errorGeneration: 'CVV-Generierung fehlgeschlagen',
    errorValidation: 'CVV-Validierung fehlgeschlagen',
    validResult: '✓ Gültig - CVV ist korrekt',
    invalidResult: '✗ Ungültig - CVV stimmt nicht überein',
    copyError: 'Kopieren fehlgeschlagen',
  },

  amexCsc: {
    title: 'Kartensicherheitscode (AMEX)',
    description: 'AMEX Kartensicherheitscodes (CSC) für American Express Zahlungskarten generieren und validieren.',
    infoTitle: 'Über AMEX CSC',
    info1: 'AMEX CSC (Card Security Code) ist eine Sicherheitsfunktion ähnlich wie CVV/CVC, aber speziell für American Express Karten.',
    info2: 'CSC Ver. 1: 4-stelliger Code auf Magnetstreifen. CSC Ver. 2: Erweitert mit CSC-5 (5 Ziffern), CSC-4 (4 Ziffern) und CSC-3 (3 Ziffern auf Kartenvorderseite gedruckt).',
    info3: 'Generiert mit AMEX 15-stelliger PAN, Ablaufdatum und Servicecode, verschlüsselt mit dem Herausgeber-CSC-Schlüssel.',
    tabGenerate: 'Generieren',
    tabValidate: 'Validieren',
    cscKey: 'CSC-Schlüssel',
    pan: 'PAN',
    expDate: 'Ablaufdatum',
    serviceCode: 'Servicecode',
    csc: 'CSC',
    cscVersion: 'CSC-Version',
    verificationType: 'Verifizierungswerttyp',
    errorInvalidKey: 'CSC-Schlüssel muss 32 oder 48 Hex-Zeichen sein',
    errorInvalidPan: 'AMEX PAN muss 15 Ziffern sein',
    errorInvalidExpDate: 'Ablaufdatum muss 4 Ziffern sein (YYMM)',
    errorInvalidServiceCode: 'Servicecode muss 3 Ziffern sein',
    errorInvalidCsc: 'Ungültige CSC-Länge',
    errorGeneration: 'CSC-Generierung fehlgeschlagen',
    errorValidation: 'CSC-Validierung fehlgeschlagen',
    validResult: '✓ Gültig - CSC ist korrekt',
    invalidResult: '✗ Ungültig - CSC stimmt nicht überein',
    copyError: 'Kopieren fehlgeschlagen',
  },

  mastercardCvc3: {
    title: 'Kartenprüfcode (MasterCard)',
    subtitle: 'MasterCard dynamischen CVC3 für kontaktlose EMV-Zahlungskarten generieren und validieren.',
    infoTitle: 'Über MasterCard CVC3',
    info1: 'MasterCard dynamischer CVC3 ist ein 3-stelliger Sicherheitscode, der dynamisch für kontaktlose EMV-Transaktionen generiert wird.',
    info2: 'Der CVC3 wird vom ICC-Hauptschlüssel (IMK) abgeleitet und enthält PAN, Spurendaten, Unvorhersehbare Nummer und ATC, um sicherzustellen, dass jede Transaktion einzigartig ist.',
    imk: 'IMK',
    pan: 'PAN',
    panSeqNum: 'PAN-Sequenznr.',
    track12Data: 'Spur-1/2-Daten',
    unpredictableNum: 'Unvorhersehbare Nr.',
    atc: 'ATC',
    cvc3Type: 'CVC3-Typ',
    dynamicCvc3: 'Dynamischer CVC3',
    pinCvc3: 'PIN-CVC3',
    generate: 'Generieren',
    validate: 'Validieren',
    errorInvalidImk: 'IMK muss 32 Hex-Zeichen sein',
    errorInvalidPan: 'PAN muss 13-19 Ziffern sein',
    errorInvalidPanSeq: 'PAN-Sequenznr. muss 2 Ziffern sein',
    errorInvalidTrack: 'Spur-1/2-Daten müssen max. 128 Hex-Zeichen sein',
    errorInvalidUN: 'Unvorhersehbare Nummer muss 8 Hex-Zeichen sein',
    errorInvalidAtc: 'ATC muss 4 Hex-Zeichen sein',
    errorInvalidCvc3: 'CVC3 muss 3 Ziffern sein',
    errorGeneration: 'CVC3-Generierung fehlgeschlagen',
    errorValidation: 'CVC3-Validierung fehlgeschlagen',
    copyError: 'Kopieren fehlgeschlagen',
    validResult: '✓ Gültig - CVC3 ist korrekt',
    invalidResult: '✗ Ungültig - CVC3 stimmt nicht überein',
  },

  checkDigits: {
    title: 'Prüfziffern',
    description: 'Prüfziffern mit verschiedenen Algorithmen verifizieren oder generieren',
    operation: 'Operation',
    check: 'Prüfen',
    generate: 'Generieren',
    hashType: 'Algorithmus',
    input: 'Eingabe',
    info: 'Algorithmus-Information',
    luhnInfo: 'Luhn-Algorithmus (MOD 10) - Für Kreditkarten, IMEI, etc.',
    amexInfo: 'Amex SE Number (MOD 9) - Ziffernsumme modulo 9',
    checkInfo: 'Vollständige Nummer mit Prüfziffer eingeben',
    generateInfo: 'Nummer ohne Prüfziffer eingeben',
    checkResult: 'Prüfergebnis',
    generateResult: 'Generierte Prüfziffer',
    validResult: 'Gültig - Prüfziffer ist korrekt',
    invalidResult: 'Ungültig - Prüfziffer ist falsch',
    fullNumber: 'Vollständige Nummer',
    errorNoInput: 'Bitte Nummer eingeben',
    errorCalculation: 'Berechnung fehlgeschlagen',
    placeholderCheck: 'Nummer mit Prüfziffer eingeben (z.B. 79927398713)',
    placeholderGenerate: 'Nummer ohne Prüfziffer eingeben (z.B. 7992739871)',
    faqTitle: 'Prüfziffern FAQ',
    faq1Question: 'Was ist eine Prüfziffer?',
    faq1Answer: 'Eine Prüfziffer ist eine Ziffer zur Fehlererkennung, die mit einem bestimmten Algorithmus berechnet wird.',
    faq2Question: 'Was ist der Luhn-Algorithmus?',
    faq2Answer: 'Der Luhn-Algorithmus (MOD 10) ist eine Prüfsummenformel zur Validierung von Kreditkartennummern, IMEI-Nummern und anderen Identifikationsnummern.',
    usageTitle: 'Verwendung',
    usage1: '"Prüfen" wählen, um Nummer mit Prüfziffer zu verifizieren',
    usage2: '"Generieren" wählen, um Prüfziffer zu berechnen',
    usage3: 'Geeigneten Algorithmus für den Anwendungsfall wählen',
  },

  base64: {
    title: 'Base64',
    description: 'Daten zu Base64 kodieren oder Base64 zurück zum Originalformat dekodieren',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    inputEncoding: 'Eingabe-Kodierung',
    outputEncoding: 'Ausgabe-Kodierung',
    hexadecimal: 'HEXADEZIMAL',
    data: 'Daten',
    info: 'Base64-Information',
    encodeInfo1: 'Base64 kodiert Binärdaten in ASCII-Zeichen',
    encodeInfo2: 'Ausgabe ist ~33% größer als Eingabe',
    decodeInfo1: 'Dekodiert Base64 zurück zu Originaldaten',
    decodeInfo2: 'Ausgabeformat wählen: ASCII-Text oder Hexadezimal',
    encodeResult: 'Base64-kodiertes Ergebnis',
    decodeResult: 'Dekodiertes Ergebnis',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorInvalidBase64: 'Ungültige Base64-Eingabe',
    errorEncode: 'Kodierung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
    placeholderAscii: 'Text zum Kodieren eingeben',
    placeholderHex: 'Hexadezimaldaten zum Kodieren eingeben',
    placeholderBase64: 'Base64-String zum Dekodieren eingeben',
    faqTitle: 'Base64 FAQ',
    faq1Question: 'Was ist Base64?',
    faq1Answer: 'Base64 ist ein Binär-zu-Text-Kodierungsschema, das Binärdaten im ASCII-String-Format mit 64 Zeichen darstellt.',
    faq2Question: 'Warum Base64 verwenden?',
    faq2Answer: 'Base64 wird häufig verwendet, um Binärdaten in textbasierte Formate wie JSON, XML oder E-Mail-Anhänge einzubetten.',
    usageTitle: 'Verwendung',
    usage1: '"Kodieren" wählen, um Daten in Base64 zu konvertieren',
    usage2: '"Dekodieren" wählen, um Base64 zurück zu Originaldaten zu konvertieren',
    usage3: 'Eingabe-/Ausgabe-Kodierung wählen: ASCII oder Hexadezimal',
  },

  base94: {
    title: 'Base94',
    description: 'Daten zu Base94 kodieren oder Base94 zurück zum Originalformat dekodieren',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    inputEncoding: 'Eingabe-Kodierung',
    outputEncoding: 'Ausgabe-Kodierung',
    hexadecimal: 'HEXADEZIMAL',
    data: 'Daten',
    info: 'Base94-Information',
    encodeInfo1: 'Verwendet druckbare ASCII-Zeichen (0x20 Leerzeichen bis 0x7E Tilde)',
    encodeInfo2: '5:4 Verhältnis - 4 Bytes zu 5 Zeichen kodiert (25% Overhead)',
    decodeInfo1: 'Dekodiert Base94 zurück zu Originaldaten',
    decodeInfo2: 'Gültige Zeichen: Leerzeichen bis ~ (ASCII 32-126)',
    encodeResult: 'Base94-kodiertes Ergebnis',
    decodeResult: 'Dekodiertes Ergebnis',
    errorNoInput: 'Bitte Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorInvalidBase94: 'Ungültige Base94-Eingabe',
    errorEncode: 'Kodierung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
    placeholderAscii: 'Text zum Kodieren eingeben',
    placeholderHex: 'Hexadezimaldaten zum Kodieren eingeben',
    placeholderBase94: 'Base94-String zum Dekodieren eingeben',
    faqTitle: 'Base94 FAQ',
    faq1Question: 'Was ist Base94?',
    faq1Answer: 'Base94 ist eine Binär-zu-Text-Kodierung, die alle 94 druckbaren ASCII-Zeichen (! bis ~) verwendet und effizientere Kodierung als Base64 bietet.',
    faq2Question: 'Warum Base94 statt Base64 verwenden?',
    faq2Answer: 'Base94 hat weniger Overhead (~22%) im Vergleich zu Base64 (~33%), was zu kleinerer kodierter Ausgabe für dieselben Daten führt.',
    usageTitle: 'Verwendung',
    usage1: '"Kodieren" wählen, um Daten in Base94 zu konvertieren',
    usage2: '"Dekodieren" wählen, um Base94 zurück zu Originaldaten zu konvertieren',
    usage3: 'Eingabe-/Ausgabe-Kodierung wählen: ASCII oder Hexadezimal',
  },

  messageParser: {
    title: 'Nachrichten-Parser',
    description: 'ATM- und Finanztransaktionsnachrichten parsen',
    parseMode: 'Parse-Modus',
    hexData: 'Hex-Daten',
    info: 'Parse-Modus-Information',
    ndcDesc: 'NCR NDC/DDC-Protokoll für ATM-Kommunikation',
    wincorDesc: 'Wincor Nixdorf-Protokoll für ATM-Kommunikation',
    iso8583Desc: 'ISO 8583:1987 Finanztransaktions-Nachrichtenformat',
    hexInputInfo: 'Eingabe muss gültige Hexadezimaldaten sein',
    placeholder: 'Hexadezimale Nachrichtendaten zum Parsen eingeben...',
    parsedResult: 'Geparste Ergebnisse',
    fields: 'Felder',
    fieldName: 'Feld',
    length: 'Länge',
    value: 'Wert',
    errorNoInput: 'Bitte Hex-Daten eingeben',
    errorInvalidHex: 'Ungültige Hexadezimaleingabe',
    errorParseFailed: 'Nachricht konnte nicht geparst werden',
    faqTitle: 'Nachrichten-Parser FAQ',
    faq1Question: 'Was ist ATM NDC?',
    faq1Answer: 'NDC (NCR Direct Connect) ist ein Kommunikationsprotokoll, das von NCR-Geldautomaten zur Kommunikation mit Host-Systemen verwendet wird.',
    faq2Question: 'Was ist ISO 8583?',
    faq2Answer: 'ISO 8583 ist ein internationaler Standard für Finanztransaktionskarten-Nachrichten, der für Kartenzahlungstransaktionen verwendet wird.',
    usageTitle: 'Verwendung',
    usage1: 'Geeigneten Parse-Modus auswählen (ATM_NDC, ATM_WINCOR oder ISO_8583_1987)',
    usage2: 'Hexadezimale Nachrichtendaten in das Eingabefeld eingeben',
    usage3: 'Auf Parsen klicken, um geparste Felder und Werte anzuzeigen',
  },

  rsaDer: {
    title: 'RSA DER Öffentlicher Schlüssel',
    description: 'RSA öffentlichen Schlüssel im DER ASN.1 Format kodieren/dekodieren',
    info: 'RSA DER Information',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    modulus: 'Modulus',
    modulusEncoding: 'Modulus-Kodierung',
    exponent: 'Exponent',
    exponentEncoding: 'Exponent-Kodierung',
    modulusNegative: 'Modulus Negativ (vorzeichenlose Kodierung)',
    outputEncoding: 'Ausgabe-Kodierung',
    inputEncoding: 'Eingabe-Kodierung',
    derInput: 'DER/PEM-Eingabe',
    modulusPlaceholder: 'Modulus eingeben (Hex oder Base64)',
    exponentPlaceholder: 'Exponent eingeben (z.B. 010001 für 65537)',
    derInputPlaceholder: 'DER (Hex/Base64) oder PEM-Format öffentlichen Schlüssel eingeben',
    encodeInfo: 'RSA Öffentlicher Schlüssel Kodierung',
    encodeInfo1: 'RSA Modulus und Exponent in DER/PEM-Format kodieren',
    encodeInfo2: 'Unterstützt sowohl vorzeichenbehaftete als auch vorzeichenlose Ganzzahl-Kodierung',
    decodeInfo: 'RSA Öffentlicher Schlüssel Dekodierung',
    decodeInfo1: 'DER/PEM-Format dekodieren, um Modulus und Exponent zu extrahieren',
    decodeInfo2: 'Unterstützt Hex-, Base64- und PEM-Eingabeformate',
    encodeResult: 'Kodiertes Ergebnis',
    decodeResult: 'Dekodiertes Ergebnis',
    errorNoModulus: 'Bitte Modulus eingeben',
    errorNoExponent: 'Bitte Exponent eingeben',
    errorNoInput: 'Bitte DER-Daten eingeben',
    errorInvalidModulusHex: 'Ungültiges Modulus-Hex',
    errorInvalidModulusBase64: 'Ungültiges Modulus-Base64',
    errorInvalidExponentHex: 'Ungültiges Exponent-Hex',
    errorInvalidExponentBase64: 'Ungültiges Exponent-Base64',
    errorInvalidHex: 'Ungültige Hex-Eingabe',
    errorInvalidBase64: 'Ungültige Base64-Eingabe',
    errorEncode: 'Kodierung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
    faqTitle: 'RSA DER Öffentlicher Schlüssel FAQ',
    faq1Question: 'Was ist DER-Kodierung?',
    faq1Answer: 'DER (Distinguished Encoding Rules) ist ein Binärformat zur Kodierung von ASN.1-Datenstrukturen, das häufig für kryptografische Schlüssel und Zertifikate verwendet wird.',
    faq2Question: 'Was ist das PEM-Format?',
    faq2Answer: 'PEM ist eine Base64-kodierte Version von DER mit Kopf- und Fußzeilen, die das Kopieren und Einfügen in Textform erleichtert.',
    usageTitle: 'Verwendung',
    usage1: 'Kodieren: Modulus und Exponent eingeben, um DER/PEM-kodierten öffentlichen Schlüssel zu generieren',
    usage2: 'Dekodieren: DER- oder PEM-Format öffentlichen Schlüssel eingeben, um Modulus und Exponent zu extrahieren',
    usage3: 'Unterstützt Hex- und Base64-Ein-/Ausgabeformate',
  },

  uuid: {
    title: 'UUID-Generator',
    description: 'Universell eindeutige Kennungen (UUID) generieren',
    variant: 'Variante',
    count: 'Anzahl',
    info: 'UUID-Information',
    infoFormat: 'Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36 Zeichen)',
    v1Desc: 'Zeitbasierte UUID mit Zeitstempel und zufälligem Knoten',
    v4Desc: 'Zufällige UUID - am häufigsten verwendet',
    v3Desc: 'Namensbasierte UUID mit MD5-Hash',
    v5Desc: 'Namensbasierte UUID mit SHA-1-Hash',
    generatedUUIDs: 'Generierte UUIDs',
    copyAll: 'Alle kopieren',
    errorInvalidCount: 'Anzahl muss zwischen 1 und 100 liegen',
    errorGenerate: 'Generierung fehlgeschlagen',
    withoutHyphen: 'Ohne "-"',
    maxCount: 'Max. 100',
    faqTitle: 'UUID FAQ',
    faq1Question: 'Was ist UUID?',
    faq1Answer: 'UUID (Universally Unique Identifier) ist ein 128-Bit-Bezeichner, der über Raum und Zeit eindeutig ist und häufig in verteilten Systemen verwendet wird.',
    faq2Question: 'Welche UUID-Version sollte ich verwenden?',
    faq2Answer: 'Version 4 (zufällig) wird am häufigsten verwendet. Version 1 ist zeitbasiert, während Versionen 3 und 5 namensbasiert sind und MD5 bzw. SHA-1 verwenden.',
    usageTitle: 'Verwendung',
    usage1: 'UUID-Variante/Version auswählen',
    usage2: 'Anzahl der zu generierenden UUIDs eingeben (1-100)',
    usage3: 'Auf Generieren klicken, um UUIDs zu erstellen',
  },

  cipher: {
    title: 'AES Verschlüsselung/Entschlüsselung',
    description: 'Daten mit AES-Algorithmus verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    aesInfo: 'AES-Informationen',
    keyLengthInfo: 'Schlüssellänge muss dem gewählten Algorithmus entsprechen',
    ivInfo: 'IV (Initialisierungsvektor) muss 16 Bytes betragen',
    paddingInfo: 'Verwendet PKCS7-Padding',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} sein',
    errorDataRequired: 'Daten erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für ECB/KCV-Modus nicht erforderlich',
    kcvInfo: 'KCV: Nullen verschlüsseln und erste 6 Hex-Zeichen nehmen',
    calculateKcv: 'KCV berechnen',
    noPaddingInfo: 'Kein Padding - Datenlänge muss ein Vielfaches von 16 Bytes sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 16 Bytes sein',
    kcvNoDataNeeded: 'Für KCV-Berechnung keine Daten erforderlich',
    kcvDataHint: 'KCV wird mit Nullen berechnet, keine Dateneingabe erforderlich',
    errorKcvCalculation: 'KCV-Berechnung fehlgeschlagen',
    kcvResult: 'KCV-Ergebnis',
  },

  des: {
    title: 'DES / 3DES Verschlüsselung/Entschlüsselung',
    description: 'Daten mit DES oder 3DES Algorithmus verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    padding: 'Padding',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    desInfo: 'DES/3DES Informationen',
    keyLengthInfoDes: 'DES benötigt einen 8-Byte (64-Bit) Schlüssel',
    keyLengthInfo3Des: '3DES benötigt einen 16 oder 24-Byte Schlüssel',
    ivInfo: 'IV (Initialisierungsvektor) muss 8 Bytes betragen',
    blockSizeInfo: 'Blockgröße ist 8 Bytes',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLengthDes: 'DES Schlüssellänge muss 8 Bytes sein',
    errorKeyLength3Des: '3DES Schlüssellänge muss 16 oder 24 Bytes sein',
    errorDataRequired: 'Daten erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 8 Bytes sein bei keinem Padding',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für ECB-Modus nicht erforderlich',
    paddingNone: 'Kein Padding',
    paddingZeros: 'Mit 0x00 auffüllen',
    paddingSpaces: 'Mit Leerzeichen 0x20 auffüllen',
    paddingANSIX923: 'Letztes Byte ist Padding-Länge, Rest mit 0x00 gefüllt',
    paddingISO10126: 'Letztes Byte ist Padding-Länge, Rest mit Zufallsbytes gefüllt',
    paddingPKCS5: 'Jeder Padding-Byte-Wert entspricht der Padding-Länge',
    paddingPKCS7: 'Wie PKCS#5',
    paddingISO7816: '0x80 hinzufügen, dann mit 0x00 auffüllen',
    paddingRijndael: 'Wie Zero Padding',
    paddingISO9797M1: 'Mit 0x00 auf Blockgröße auffüllen',
    paddingISO9797M2: 'Wie ISO 7816-4',
    mode8BitNote: 'Hinweis: 8-Bit-Modus verarbeitet 1 Byte pro Durchgang',
    mode64BitNote: '64-Bit-Modus verarbeitet vollständigen Block (8 Bytes) pro Durchgang',
  },

  rsa: {
    title: 'RSA Verschlüsselung/Entschlüsselung',
    description: 'RSA asymmetrische Verschlüsselung, Entschlüsselung, Signierung und Verifizierung',
    rsaInfo: 'RSA Information',
    rsaInfo1: 'RSA ist ein asymmetrischer Verschlüsselungsalgorithmus',
    rsaInfo2: 'Schlüsselgrößen: 1024, 2048, 4096 Bit (2048+ empfohlen)',
    rsaInfo3: 'PKCS#1 v1.5 und OAEP Padding unterstützt',
    tabKeys: 'Schlüssel',
    tabEncrypt: 'Verschlüsseln',
    tabDecrypt: 'Entschlüsseln',
    tabSign: 'Signieren',
    tabVerify: 'Verifizieren',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA-Modul in Hexadezimal',
    privateExpPlaceholder: 'RSA privater Exponent in Hexadezimal',
    keyLength: 'Schlüssellänge',
    generateKeys: 'Schlüssel generieren',
    importKeys: 'Schlüssel importieren',
    clearKeys: 'Löschen',
    keyGenerated: 'Schlüsselpaar erfolgreich generiert',
    keysCleared: 'Schlüssel gelöscht',
    keyImported: 'Öffentlicher Schlüssel erfolgreich importiert',
    privateKeyImportNote: 'Privater Schlüsselimport erfordert vollständige CRT-Parameter. Verwenden Sie "Schlüssel generieren" für volle Funktionalität.',
    padding: 'Padding',
    hashAlgorithm: 'Hash-Algorithmus',
    data: 'Daten',
    dataToEncrypt: 'Zu verschlüsselnde Daten',
    dataPlaceholderAscii: 'Textdaten eingeben',
    encodingMethod: 'Kodierungsmethode',
    private: 'Privat',
    public: 'Öffentlich',
    inputDataFormat: 'Eingabedatenformat',
    hexadecimal: 'Hexadezimal',
    paddingMethod: 'Padding-Methode',
    noPadding: 'Kein Padding',
    errorDataRequired: 'Daten erforderlich',
    privateEncryptNote: 'Hinweis: Verwendung des öffentlichen Schlüssels zur Verschlüsselung',
    dataToSign: 'Zu signierende Daten',
    dataToVerify: 'Zu verifizierende Daten',
    ciphertextToDecrypt: 'Zu entschlüsselnder Chiffretext',
    signatureToVerify: 'Signatur',
    dataPlaceholder: 'Hexadezimale Daten eingeben',
    ciphertextPlaceholder: 'Verschlüsselte Hexadezimaldaten eingeben',
    signaturePlaceholder: 'Signatur in Hexadezimal eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    sign: 'Signieren',
    verify: 'Verifizieren',
    encryptedResult: 'Verschlüsseltes Ergebnis',
    encryptionFinished: 'Datenverschlüsselung abgeschlossen',
    decryptionFinished: 'Datenentschlüsselung abgeschlossen',
    decodingMethod: 'Dekodierungsmethode',
    copyResult: 'Ergebnis kopieren',
    result: 'ERGEBNIS',
    decryptedResult: 'Entschlüsseltes Ergebnis',
    signatureResult: 'Signatur',
    signatureValid: '✓ Signatur ist gültig',
    signatureInvalid: '✗ Signatur ist ungültig',
    encryptInfo: 'RSA Verschlüsselung',
    encryptDesc: 'Daten mit dem öffentlichen Schlüssel verschlüsseln',
    decryptInfo: 'RSA Entschlüsselung',
    decryptDesc: 'Daten mit dem privaten Schlüssel entschlüsseln',
    signInfo: 'RSA Signatur',
    signDesc: 'Daten mit dem privaten Schlüssel signieren (RSA-PSS)',
    verifyInfo: 'RSA Signaturverifizierung',
    verifyDesc: 'Signatur mit dem öffentlichen Schlüssel verifizieren (RSA-PSS)',
    oaepDesc1: 'OAEP ist ein Padding-Schema für RSA-Verschlüsselung',
    oaepDesc2: 'Sicherer als PKCS#1 v1.5 Padding',
    oaepDesc3: 'Verhindert Chosen-Ciphertext-Angriffe',
    oaepDesc4: 'Empfohlen für neue Anwendungen',
    oaepStructure: 'OAEP Struktur',
    maxDataSize: 'Maximale Datengröße',
    errorKeyGen: 'Schlüsselgenerierung fehlgeschlagen',
    errorKeyImport: 'Schlüsselimport fehlgeschlagen',
    errorInvalidModulus: 'Ungültiges Modul',
    errorInvalidPublicExp: 'Ungültiger öffentlicher Exponent',
    errorNoPublicKey: 'Bitte generieren oder importieren Sie zuerst einen öffentlichen Schlüssel',
    errorNoPrivateKey: 'Bitte generieren Sie zuerst ein Schlüsselpaar (privater Schlüssel erforderlich)',
    errorInvalidData: 'Ungültige Daten (muss hexadezimal sein)',
    errorInvalidCiphertext: 'Ungültiger Chiffretext (muss hexadezimal sein)',
    errorInvalidSignature: 'Ungültige Signatur (muss hexadezimal sein)',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorSign: 'Signierung fehlgeschlagen',
    errorVerify: 'Verifizierung fehlgeschlagen',
  },

  ecc: {
    title: 'ECC (ECDSA)',
    description: 'Elliptische Kurven-Kryptographie - Digitaler Signaturalgorithmus',
    infoTitle: 'Über ECC/ECDSA',
    infoContent1: 'Elliptische Kurven-Kryptographie bietet starke Sicherheit mit kleineren Schlüsselgrößen',
    infoContent2: 'Unterstützt P-256, P-384, P-521 Kurven für digitale Signaturen',
    infoContent3: 'ECDSA-Signaturen können die Authentizität und Integrität von Daten verifizieren',
  },

  sslCert: {
    title: 'SSL-Zertifikate (X509)',
    description: 'RSA-Schlüssel generieren, CSRs erstellen, selbstsignierte Zertifikate und X.509-Zertifikate analysieren',
    infoTitle: 'X.509-Zertifikatsinformationen',
    info1: 'X.509 ist das Standardformat für Public-Key-Zertifikate',
    info2: 'Wird für TLS/SSL, E-Mail-Signatur und Code-Signatur verwendet',
    info3: 'CSR (Certificate Signing Request) wird verwendet, um ein Zertifikat von einer CA anzufordern',
    tabKeys: 'Schlüssel',
    tabCSRs: 'CSRs',
    tabReadCSR: 'CSR lesen',
    tabSelfSigned: 'Selbstsignierte Zertifikate',
    tabReadCert: 'Zertifikat lesen',
    publicExponent: 'Öffentlicher Exponent (e)',
    keyLength: 'Schlüssellänge',
    passPhrase: 'Passphrase',
    passPhrasePlaceholder: 'Passphrase zur Verschlüsselung des privaten Schlüssels eingeben',
    generateKeys: 'Schlüssel generieren',
    privateKey: 'Privater Schlüssel',
    keyGenerated: 'Schlüsselpaar erfolgreich generiert',
    generating: 'RSA-Schlüsselpaar wird generiert...',
    privateKeyPlaceholder: 'Verschlüsselten PEM-Privatschlüssel einfügen',
    version: 'Version',
    country: 'Ländername',
    state: 'Bundesland/Provinz',
    locality: 'Ort',
    organization: 'Organisation',
    unit: 'Abteilung',
    commonName: 'Common Name',
    email: 'E-Mail-Adresse',
    generateCSR: 'CSR generieren',
    generatedCSR: 'Generierter CSR',
    csrGenerated: 'Certificate Signing Request wurde generiert',
    inputPK: 'Eingegebener privater Schlüssel',
    certificateSigningRequest: 'Certificate Signing Request',
    generatingCSR: 'CSR wird generiert...',
    inputCSR: 'CSR eingeben',
    csrPlaceholder: 'PEM-kodierten CSR einfügen (-----BEGIN CERTIFICATE REQUEST-----)',
    parseCSR: 'CSR analysieren',
    parsedCSRInfo: 'Analysierte CSR-Informationen',
    csrParsed: 'CSR erfolgreich analysiert',
    csrRead: 'Certificate Signing Request gelesen',
    pemData: 'PEM-Daten',
    publicKey: 'Öffentlicher Schlüssel',
    validityBefore: 'Gültigkeit ab',
    validityAfter: 'Gültigkeit bis',
    days: 'Tage',
    serialNumber: 'Seriennummer',
    generateCert: 'Zertifikat generieren',
    generatedCert: 'Generiertes Zertifikat',
    certGenerated: 'Zertifikat wurde generiert',
    generatingCert: 'Zertifikat wird generiert...',
    certificate: 'Zertifikat',
    inputCert: 'Zertifikat eingeben',
    certPlaceholder: 'PEM-kodiertes Zertifikat einfügen (-----BEGIN CERTIFICATE-----)',
    parseCert: 'Zertifikat analysieren',
    parsedCertInfo: 'Analysierte Zertifikatsinformationen',
    certParsed: 'Zertifikat erfolgreich analysiert',
    validFrom: 'Gültig ab',
    validTo: 'Gültig bis',
    issuer: 'Aussteller',
    subject: 'Subjekt',
    extensions: 'Erweiterungen',
    errorPassPhraseRequired: 'Passphrase erforderlich',
    errorPrivateKeyRequired: 'Privater Schlüssel erforderlich',
    errorCommonNameRequired: 'Common Name erforderlich',
    errorInvalidPrivateKey: 'Ungültiger privater Schlüssel oder Passphrase',
    errorCSRRequired: 'CSR erforderlich',
    errorCertRequired: 'Zertifikat erforderlich',
    errorKeyGen: 'Schlüsselgenerierung fehlgeschlagen',
    errorCSRGen: 'CSR-Generierung fehlgeschlagen',
    errorCSRParse: 'CSR-Analyse fehlgeschlagen',
    errorCertGen: 'Zertifikatsgenerierung fehlgeschlagen',
    errorCertParse: 'Zertifikatsanalyse fehlgeschlagen',
  },

  keyshareGenerator: {
    title: 'Keyshare Generator',
    description: 'Schlüssel eingeben und in mehrere Anteile aufteilen, mit KCV-Verifikation',
    infoTitle: 'Über Keyshare Generator',
    infoContent: 'Teilen Sie einen kryptografischen Schlüssel mittels XOR-Operation in mehrere Anteile auf.',
    infoContent2: 'Jeder Anteil kann für Schlüsselzeremonien an verschiedene Verwahrer verteilt werden.',
    mode: 'Modus',
    insecure: 'Insecure',
    secure: 'Secure',
    parity: 'Parität',
    ignore: 'Ignorieren',
    forceOdd: 'Ungerade erzwingen',
    combinedKey: 'Kombinierter Schlüssel',
    threePartKey: '3-Teil Schlüssel',
    twoPartKey: '2-Teil Schlüssel',
    parityAdjusted: 'Parität angepasst',
    setPinFirst: 'Bitte zuerst 4-stellige PIN festlegen',
    keyRevealed: 'Schlüsselanteil enthüllt',
    wrongPin: 'Falsche PIN',
    enterPin: 'PIN eingeben',
    enterPinToReveal: '4-stellige PIN eingeben, um Schlüsselanteil anzuzeigen',
    unlock: 'Entsperren',
    regenerate: 'Neu generieren',
  },

  futurexKeys: {
    title: 'Futurex Schlüssel Ver-/Entschlüsselung',
    description: 'Schlüssel mit Futurex HSM Schlüsselvarianten-Methode ver-/entschlüsseln',
    infoTitle: 'Über Futurex Schlüssel',
    infoContent1: 'Schlüssel mit Futurex HSM Varianten ver-/entschlüsseln.',
    infoContent2: 'Modifikator (0-F) erstellt verschiedene Varianten aus MFK.',
    infoContent3: 'MFK (Master File Key) ist der Basis-Verschlüsselungsschlüssel.',
    tabEncrypt: 'Schlüssel Ver-/Entschlüsselung',
    tabLookup: 'Schlüsselsuche',
    key: 'Schlüssel',
    modifier: 'Modifikator',
    modifierHint: 'Schlüsselvarianten-Selektor (0-F)',
    mfk: 'MFK (Master File Key)',
    customMfk: 'Benutzerdefinierter MFK...',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptedKey: 'Verschlüsselter Schlüssel',
    decryptedKey: 'Entschlüsselter Schlüssel',
    encryptedKeyInput: 'Verschlüsselter Schlüssel',
    lookup: 'Alle Modifikatoren durchsuchen',
    lookupResults: 'Suchergebnisse',
    encryptSuccess: 'Schlüssel erfolgreich verschlüsselt',
    decryptSuccess: 'Schlüssel erfolgreich entschlüsselt',
    errorInvalidKey: 'Ungültiges Schlüsselformat',
    errorKeyLength: 'Schlüssel muss 16, 24 oder 32 Bytes sein',
    errorInvalidMfk: 'Ungültiges MFK-Format (mindestens 32 Hex-Zeichen erforderlich)',
    errorEncrypt: 'Verschlüsselung fehlgeschlagen',
    errorDecrypt: 'Entschlüsselung fehlgeschlagen',
    errorLookup: 'Suche fehlgeschlagen',
    noResults: 'Keine gültige Entschlüsselung gefunden',
    encryptResult: 'Schlüssel-Verschlüsselungsergebnis',
    decryptResult: 'Schlüssel-Entschlüsselungsergebnis',
    plainKey: 'Klartext-Schlüssel',
    encryptedKeyLabel: 'Verschlüsselter Schlüssel',
    parityDetected: 'Parität erkannt',
    mfkLabel: 'MFK',
    keyModifier: 'Schlüssel-Modifikator',
    decodedKey: 'Entschlüsselter Schlüssel',
    kcvLabel: 'KCV',
    checkKcv: 'KCV prüfen?',
    type: 'Typ',
    typeAny: 'Alle',
    typeFuturex: 'Futurex',
    typeIbm: 'IBM',
    typeAtalla: 'Atalla',
    typeVisa: 'VISA',
    parityLabel: 'Parität',
    parityAny: 'Alle',
    parityOdd: 'Ungerade',
    parityEven: 'Gerade',
    keyPlaceholder: 'Verschlüsselten Schlüssel zur Suche eingeben',
    kcvPlaceholder: 'KCV zum Abgleich eingeben (6 Hex-Zeichen)',
    errorInvalidKcv: 'Ungültiges KCV-Format (mindestens 6 Hex-Zeichen erforderlich)',
  },

  atallaKeys: {
    title: 'Atalla Schlüssel (AKB)',
    description: 'Schlüssel mit Atalla HSM AKB-Format ver-/entschlüsseln',
    infoTitle: 'Über Atalla Schlüssel',
    infoContent1: 'Schlüssel mit Atalla Key Block (AKB) Format ver-/entschlüsseln.',
    infoContent2: 'AKB-Header (8 Zeichen) definiert die Schlüsselvariante.',
    infoContent3: 'MFK (Master File Key) ist der Basis-Verschlüsselungsschlüssel.',
    tabEncrypt: 'Schlüssel verschlüsseln',
    tabDecode: 'AKB dekodieren',
    key: 'Schlüssel',
    akbHeader: 'AKB-Header',
    akbHeaderHint: 'Atalla Key Block Header (8 Zeichen)',
    mfkKey: 'MFK-Schlüssel',
    mfkPlaceholder: 'MFK eingeben (48 Hex-Zeichen)',
    keyPlaceholder: 'Hex-Schlüssel eingeben (16/24/32 Bytes)',
    encrypt: 'Verschlüsseln',
    decode: 'Dekodieren',
    akb: 'AKB',
    akbPlaceholder: 'AKB eingeben (Header,verschlüsselte_Daten)',
    checkKcv: 'KCV prüfen?',
    kcvS: 'KCV (S)',
    kcvPlaceholder: 'Erwarteten KCV eingeben',
    parity: 'Parität',
    parityAny: 'Alle',
    parityOdd: 'Ungerade',
    parityEven: 'Gerade',
    encryptSuccess: 'Schlüssel erfolgreich verschlüsselt',
    decodeSuccess: 'AKB erfolgreich dekodiert',
    errorInvalidKey: 'Ungültiges Schlüsselformat',
    errorKeyLength: 'Schlüssel muss 16, 24 oder 32 Bytes sein',
    errorHeaderLength: 'AKB-Header muss 8 Zeichen sein',
    errorInvalidMfk: 'MFK muss mindestens 48 Hex-Zeichen sein',
    errorInvalidAkb: 'Ungültiges AKB-Format (muss Header,Daten enthalten)',
    errorInvalidAkbData: 'Ungültige verschlüsselte Daten im AKB',
    errorInvalidKcv: 'Ungültiges KCV-Format',
    errorEncrypt: 'Verschlüsselung fehlgeschlagen',
    errorDecode: 'Dekodierung fehlgeschlagen',
    kcvMismatch: 'KCV stimmt nicht überein',
    macMismatch: 'MAC-Verifikation fehlgeschlagen',
    parityMismatch: 'Parität stimmt nicht überein',
    decodeFailed: 'AKB-Dekodierung fehlgeschlagen',
    encryptResult: 'Verschlüsselungsergebnis',
    decodeResult: 'Dekodierungsergebnis',
    plainKey: 'Klartext-Schlüssel',
    encryptedAkb: 'Verschlüsselter AKB',
    kcv: 'KCV',
    header: 'Header',
    decodedKey: 'Entschlüsselter Schlüssel',
    parityDetected: 'Parität',
  },

  safenetKeys: {
    title: 'SafeNet Schlüssel Ver-/Entschlüsselung',
    description: 'Schlüssel mit SafeNet HSM Schlüsselvarianten-Methode ver-/entschlüsseln',
    infoTitle: 'Über SafeNet Schlüssel',
    infoContent1: 'Schlüssel mit SafeNet HSM Methode ver-/entschlüsseln.',
    infoContent2: 'Schlüsselformat definiert Verschlüsselungstyp (ECB/CBC).',
    infoContent3: 'Variante bestimmt Schlüsselverwendung (DPK, PPK, MPK, etc.).',
    tabEncrypt: 'Schlüssel Ver-/Entschlüsselung',
    tabLookup: 'Schlüsselsuche',
    key: 'Schlüssel',
    keyFormat: 'Schlüsselformat',
    variant: 'Variante',
    kmKey: 'KM-Schlüssel',
    kmKeyPlaceholder: 'KM-Schlüssel eingeben (32 Hex-Zeichen)',
    keyPlaceholder: 'Hex-Schlüssel eingeben',
    lookupKeyPlaceholder: 'Verschlüsselten Schlüssel zur Suche eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    lookup: 'Suchen',
    encryptSuccess: 'Schlüssel erfolgreich verschlüsselt',
    decryptSuccess: 'Schlüssel erfolgreich entschlüsselt',
    decryptFailed: 'Entschlüsselung fehlgeschlagen',
    errorInvalidKey: 'Ungültiges Schlüsselformat',
    errorInvalidKmKey: 'KM-Schlüssel muss mindestens 16 Bytes sein',
    errorInvalidKcv: 'Ungültiges KCV-Format',
    errorEncrypt: 'Verschlüsselung fehlgeschlagen',
    errorDecrypt: 'Entschlüsselung fehlgeschlagen',
    errorLookup: 'Suche fehlgeschlagen',
    noResults: 'Keine passenden Schlüssel gefunden',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    plainKey: 'Klartext-Schlüssel',
    encryptedKeyLabel: 'Verschlüsselter Schlüssel',
    decodedKey: 'Entschlüsselter Schlüssel',
    kcvLabel: 'KCV',
    parityDetected: 'Parität',
    checkKcv: 'KCV prüfen?',
    kcv: 'KCV',
    kcvPlaceholder: 'Erwarteten KCV eingeben',
    parity: 'Parität',
    parityAny: 'Alle',
    parityOdd: 'Ungerade',
    parityEven: 'Gerade',
  },

  thalesKeys: {
    title: 'Thales Schlüssel Ver-/Entschlüsselung',
    description: 'Schlüssel mit Thales HSM LMK Schlüsselvarianten-Methode ver-/entschlüsseln',
    infoTitle: 'Über Thales Schlüssel',
    infoContent1: 'Schlüssel mit Thales HSM LMK Methode ver-/entschlüsseln.',
    infoContent2: 'Schlüsselschema definiert Schlüssellänge und Verschlüsselungstyp.',
    infoContent3: 'Variante bestimmt die auf LMK angewendete XOR-Maske.',
    tabEncrypt: 'Schlüssel Ver-/Entschlüsselung',
    tabLookup: 'Schlüsselsuche',
    key: 'Schlüssel',
    keyScheme: 'Schlüsselschema',
    lmkSize: 'LMK-Größe',
    double: 'Doppelt',
    triple: 'Dreifach',
    lmkPair: 'LMK-Paar',
    lmkKey: 'LMK-Schlüssel',
    variant: 'Variante',
    keyPlaceholder: 'Hex-Schlüssel eingeben',
    lookupKeyPlaceholder: 'Verschlüsselten Schlüssel zur Suche eingeben (mit/ohne Schema-Präfix)',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    lookup: 'Suchen',
    encryptSuccess: 'Schlüssel erfolgreich verschlüsselt',
    decryptSuccess: 'Schlüssel erfolgreich entschlüsselt',
    decryptFailed: 'Entschlüsselung fehlgeschlagen',
    errorInvalidKey: 'Ungültiges Schlüsselformat',
    errorInvalidLmkKey: 'Ungültiger LMK-Schlüssel',
    errorInvalidKcv: 'Ungültiges KCV-Format',
    errorEncrypt: 'Verschlüsselung fehlgeschlagen',
    errorDecrypt: 'Entschlüsselung fehlgeschlagen',
    errorLookup: 'Suche fehlgeschlagen',
    noResults: 'Keine passenden Schlüssel gefunden',
    encryptResult: 'Verschlüsselungsergebnis',
    decryptResult: 'Entschlüsselungsergebnis',
    plainKey: 'Klartext-Schlüssel',
    encryptedKeyLabel: 'Verschlüsselter Schlüssel',
    decodedKey: 'Entschlüsselter Schlüssel',
    kcvLabel: 'KCV',
    parityDetected: 'Parität',
    checkKcv: 'KCV prüfen?',
    kcv: 'KCV',
    kcvPlaceholder: 'Erwarteten KCV eingeben',
    parity: 'Parität',
    parityAny: 'Alle',
    parityOdd: 'Ungerade',
    parityEven: 'Gerade',
  },

  thalesKeyBlock: {
    title: 'Thales Schlüsselblock',
    description: 'Thales proprietäre Schlüsselblöcke kodieren/dekodieren',
    infoTitle: 'Über Thales Schlüsselblock',
    infoContent1: 'Thales proprietäre Schlüsselblöcke kodieren/dekodieren.',
    infoContent2: 'Ähnlich wie TR-31, aber im Thales-spezifischen Format.',
    infoContent3: 'Verwendet KBPK (Key Block Protection Key) zur Verschlüsselung.',
    tabEncode: 'Kodieren',
    tabDecode: 'Dekodieren',
    plainKey: 'Klartext-Schlüssel',
    versionId: 'Versions-ID',
    keyUsage: 'Schlüsselverwendung',
    algorithm: 'Algorithmus',
    modeOfUse: 'Verwendungsmodus',
    keyVersionNum: 'Schlüsselversion#',
    exportability: 'Exportfähigkeit',
    optKeyBlocks: 'Opt. Schlüsselblöcke',
    lmkId: 'LMK-ID',
    optionalHeaders: 'Optionale Header',
    encode: 'Kodieren',
    decode: 'Dekodieren',
    keyBlock: 'Schlüsselblock',
    encodeResult: 'Kodierungsergebnis',
    decodeResult: 'Dekodierungsergebnis',
  },

  fpe: {
    title: 'Format-erhaltende Verschlüsselung',
    description: 'Daten verschlüsseln unter Beibehaltung von Format und Länge (NIST SP 800-38G)',
    radix: 'Basis',
    encryptionType: 'Verschlüsselungstyp',
    keyInput: 'Schlüsseleingabe',
    useTweak: 'Tweak verwenden?',
    fpeInfo: 'FPE-Informationen',
    formatPreserving: 'Format-erhaltend: Ausgabe hat das gleiche Format und die gleiche Länge wie die Eingabe',
    radixInfo: 'Die aktuelle Basis definiert den gültigen Zeichensatz für Daten',
    tweakInfo: 'Tweak bietet zusätzliche Eingabe für die Verschlüsselung (wie ein IV)',
    minLength: 'Minimale Datenlänge: 2 Zeichen',
    dataPlaceholder: 'Daten mit gültigen Basis-Zeichen eingeben',
    tweakPlaceholderFF1: 'Tweak in Hexadezimal eingeben (beliebige Länge)',
    tweakPlaceholderFF3: '16 Hex-Zeichen (8 Bytes)',
    resultLength: 'Länge',
    characters: 'Zeichen',
    algorithm: 'Algorithmus',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} sein',
    errorDataRequired: 'Daten erforderlich',
    errorDataTooShort: 'Daten müssen mindestens 2 Zeichen lang sein',
    errorInvalidDataForRadix: 'Daten enthalten ungültige Zeichen für Basis {radix}',
    errorInvalidTweakHex: 'Tweak muss gültiges Hexadezimal sein',
    errorTweakLength: 'Tweak-Länge muss {length} Bytes für {algorithm} sein',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    algorithmNotImplemented: 'Dieser Algorithmus ist noch nicht vollständig implementiert',
  },

  // SEO Content
  seo: {
    home: {
      title: 'HSM Kit - Kostenlose Online-Verschlüsselung & Schlüsselverwaltung',
      description: 'Kostenlose Online-Kryptografie-Tools. Unterstützung für Thales, Futurex, Atalla, SafeNet HSM-Schlüsseloperationen. KCV berechnen, TR-31 Schlüsselblöcke kodieren, sichere Schlüssel generieren, AES/DES/RSA-Verschlüsselung. Alle Berechnungen im Browser. 100% kostenlos, keine Registrierung erforderlich.',
      keywords: 'HSM Tools, Thales HSM, Futurex HSM, Atalla AKB, SafeNet Schlüssel, Verschlüsselungs-Toolkit, Schlüsselverwaltung, KCV Rechner, TR-31 Schlüsselblock, AES Verschlüsselung, DES Verschlüsselung, RSA Verschlüsselung, PIN Block, Schlüsselgenerator, Kryptografie-Tools, Zahlungssicherheit, LMK Verschlüsselung, Online Verschlüsselung Tools, kostenlose Kryptografie Tools',
      faqTitle: 'Häufig gestellte Fragen',
      usageTitle: 'Über HSM Kit',
      faqs: [
        { question: 'Ist HSM Kit kostenlos?', answer: 'Ja, HSM Kit ist 100% kostenlos mit über 25 Kryptografie-Tools. Keine Registrierung, kein Login, keine Zahlung erforderlich. Alle Funktionen sofort verfügbar.' },
        { question: 'Sind meine Daten sicher?', answer: 'Absolut. Alle Operationen laufen vollständig im Browser mit JavaScript. Ihre Schlüssel, PINs und sensiblen Daten verlassen nie Ihr Gerät - keine Server-Kommunikation.' },
        { question: 'Welche HSM-Hersteller werden unterstützt?', answer: 'HSM Kit unterstützt Thales (LMK-Verschlüsselung, Schlüsselblöcke), Futurex (MFK-Varianten), Atalla (AKB-Format) und SafeNet (KM-Schlüsselvarianten) HSM-Schlüsseloperationen.' },
        { question: 'Welche Verschlüsselungsalgorithmen werden unterstützt?', answer: 'Wir unterstützen AES (128/192/256-Bit), DES, 3DES, RSA, ECC/ECDSA und Format-Preserving Encryption (FPE FF1/FF3-1). Mehrere Modi und Padding-Optionen verfügbar.' },
        { question: 'Kann ich HSM Kit für Zahlungssicherheit verwenden?', answer: 'Natürlich! HSM Kit enthält professionelle Tools für PIN Block Generierung (ISO 9564), TR-31/Thales Schlüsselblöcke, KCV-Berechnung, Schlüsselanteil-Generierung und HSM-Schlüsselverschlüsselung/-entschlüsselung.' },
        { question: 'Welche Kodierungstools sind verfügbar?', answer: 'Base64, Base94, BCD, Zeichenkodierung (ASCII/EBCDIC/Hex), ASN.1/DER-Parsing, UUID-Generierung, Hash-Berechnung (MD5/SHA/BLAKE2) und Prüfziffer-Verifizierung.' },
      ],
      usage: [
        'HSM Kit ist eine umfassende Suite von über 25 Kryptografie-Tools für Sicherheitsexperten, Entwickler und alle, die mit Verschlüsselung und Zahlungssystemen arbeiten.',
        'Alle Tools arbeiten vollständig im Browser - keine Server-Kommunikation bedeutet, dass Ihre sensiblen Daten, Schlüssel und PINs Ihr Gerät nie verlassen.',
        'Professionelle HSM-Tools mit Unterstützung für Thales, Futurex, Atalla und SafeNet Schlüsseloperationen, TR-31 Schlüsselblöcke und KCV-Berechnungen.',
        'Perfekt für Tests, Entwicklung und Bildungszwecke in Kryptografie, Zahlungssicherheit und HSM-Schlüsselverwaltung.',
      ],
    },
    as2805: {
      title: 'AS2805 Zahlungs-Tools: Terminal-Schlüsselsatz, PIN-Block, MAC, OWF | HSM Kit',
      description: 'Umfassende AS2805-Hilfsprogramme: Terminal-Schlüsselsatz-Generierung, PIN-Block-Übersetzung, ISO9797-1 M2 TDES-CBC-MAC und OWF (HMAC-SHA256). Vollständig clientseitig, keine Daten verlassen Ihr Gerät.',
      keywords: 'AS2805, AS2805.4.1, Terminal-Schlüsselsatz, PIN-Block-Übersetzung, MAC, OWF, ISO9797-1 M2, TDES CBC-MAC, HMAC-SHA256, ZPK, TPK, KEK Flag 1,2,3, Key Scheme KEK B,C,H,F,G, Key Scheme LMK 0,T,U,X,Y,Z, KCV Typ 0,1,2, Zahlungssicherheit',
      faqTitle: 'AS2805 FAQ',
      usageTitle: 'Anwendung',
      faqs: [
        { question: 'Was ist AS2805?', answer: 'AS2805 ist ein in Australien weit verbreiteter Standard für Finanznachrichten und Sicherheitsoperationen.' },
        { question: 'Sind die Berechnungen clientseitig?', answer: 'Ja. Alle Operationen laufen vollständig in Ihrem Browser; es werden keine Daten an Server gesendet.' },
        { question: 'Welche KEK Flag Werte werden unterstützt?', answer: '1, 2 und 3.' },
        { question: 'Welche Key Scheme KEK Werte werden unterstützt?', answer: 'B, C, H, F und G.' },
        { question: 'Welche Key Scheme LMK Werte werden unterstützt?', answer: '0, T, U, X, Y und Z.' },
        { question: 'Welche KCV Typen werden unterstützt?', answer: '0, 1 und 2.' },
        { question: 'Welcher MAC-Algorithmus wird verwendet?', answer: 'ISO9797-1 Padding Methode 2 mit TDES CBC-MAC (letzter Block).' },
        { question: 'Welcher OWF-Algorithmus wird verwendet?', answer: 'HMAC-SHA256 mit 32-Byte Hex-Ausgabe.' },
      ],
      usage: [
        'Terminal-Schlüsselsatz: KEK Flag (1/2/3) auswählen.',
        'KEKr Schlüssel in Hex eingeben; die Länge wird oberhalb des Eingabefelds angezeigt.',
        'Key Scheme KEK (B/C/H/F/G) und Key Scheme LMK (0/T/U/X/Y/Z) wählen.',
        'KCV Typ (0/1/2) wählen und „Generieren“ klicken, um KCV, ZPK und TPK zu erhalten.',
        'PIN-Block-Übersetzung: System ZPK und Terminal TPK in Hex eingeben, Echtzeit-Längenanzeige beachten.',
        'STAN und Transaktionsbetrag eingeben, Ein-/Ausgangsformat wählen (z. B. 46 → 01).',
        'Eingehenden PIN-Block (16 Hex) und Kontonummer (12–19 Stellen) angeben, dann „Übersetzen“ klicken.',
        'MAC: Schlüssel (16/32/48 Hex) und Daten (Hex) eingeben. Das Tool wendet ISO9797-1 M2 Padding an und berechnet TDES CBC-MAC.',
        'OWF: Schlüssel (16/32/48/64 Hex) und Daten (Hex) eingeben. Das Tool berechnet HMAC-SHA256.',
        'Über die Kopier-Schaltfläche auf Ergebniskarten schnell kopieren.',
      ],
    },
    tdesCbcMac: {
      title: 'TDES CBC-MAC Rechner Online - Triple DES Nachrichten-Authentifizierung | HSM Kit',
      description: 'Kostenloser Online TDES CBC-MAC Rechner. Generieren Sie Nachrichten-Authentifizierungscodes mit Triple DES im CBC-Modus. Unterstützt 2-Schlüssel- und 3-Schlüssel-TDES mit ISO 9797-1 Padding-Methoden. PCI DSS konforme MAC-Generierung für Finanztransaktionen, Zahlungssysteme und sichere Kommunikation.',
      keywords: 'TDES CBC-MAC, Triple DES MAC, 3DES MAC, CBC-MAC, Nachrichten-Authentifizierung, DES MAC, ISO 9797-1, Zahlungs-MAC, Finanz-MAC, 2-Schlüssel TDES, 3-Schlüssel TDES, CBC-Modus',
      faqTitle: 'TDES CBC-MAC FAQ',
      usageTitle: 'So verwenden Sie den TDES CBC-MAC Rechner',
      faqs: [
        { question: 'Was ist TDES CBC-MAC?', answer: 'TDES CBC-MAC (Triple Data Encryption Standard Cipher Block Chaining Message Authentication Code) ist ein kryptografischer Algorithmus, der Triple DES-Verschlüsselung im CBC-Modus verwendet, um Authentifizierungs-Tags zu generieren, die die Integrität und Authentizität von Nachrichten verifizieren. Es verarbeitet Daten in 8-Byte-Blöcken und verkettet jeden Block mit der vorherigen verschlüsselten Ausgabe. Der letzte Block wird zum MAC-Wert und stellt sicher, dass jede Manipulation der Nachricht erkannt wird.' },
        { question: 'Was ist der Unterschied zwischen 2-Schlüssel- und 3-Schlüssel-TDES?', answer: '2-Schlüssel-TDES (112-Bit effektive Sicherheit) verwendet 16 Bytes (32 Hex-Zeichen) mit K1 und K2, wobei K3=K1 in der Verschlüsseln-Entschlüsseln-Verschlüsseln-Sequenz. 3-Schlüssel-TDES (168-Bit effektive Sicherheit) verwendet 24 Bytes (48 Hex-Zeichen) mit drei unabhängigen Schlüsseln K1, K2, K3. 3-Schlüssel-TDES bietet stärkere Sicherheit und wird für hochwertige Transaktionen und moderne Zahlungssysteme empfohlen, die PCI DSS-konform sein müssen.' },
        { question: 'Was sind ISO 9797-1 Padding-Methoden?', answer: 'ISO 9797-1 definiert zwei Padding-Methoden: Methode 1 verwendet Null-Bytes (0x00), um auf ein Vielfaches von 8 Bytes aufzufüllen - einfach, aber anfällig, wenn die ursprünglichen Daten in Nullen enden. Methode 2 (empfohlen) fügt 0x80 gefolgt von Null-Bytes hinzu und trennt immer Padding von Originaldaten. Methode 2 gewährleistet eindeutige Padding-Entfernung und schützt vor Padding-Oracle-Angriffen in MAC-Verifizierungssystemen.' },
        { question: 'Wann sollte ich TDES CBC-MAC verwenden?', answer: 'Verwenden Sie es für Legacy-Finanzsysteme, die Triple DES-Kompatibilität erfordern, Zahlungsterminal-Authentifizierung (POS, ATM), EMV-Chipkarten-Transaktionen, Schlüsselverwaltungs-MAC-Generierung und sichere Nachrichtenübermittlung in Banknetzwerken. Während AES-basierte MACs (wie CMAC) für neue Systeme bevorzugt werden, bleibt TDES CBC-MAC in bestehenden Zahlungsinfrastrukturen aufgrund von Rückwärtskompatibilitätsanforderungen und regulatorischer Akzeptanz weit verbreitet.' },
        { question: 'Was ist die typische MAC-Verkürzung für TDES CBC-MAC?', answer: 'TDES CBC-MAC erzeugt einen 8-Byte (16 Hex-Zeichen) MAC aus dem letzten verschlüsselten Block. Übliche Verkürzungswerte sind: 4 Bytes (8 Hex-Zeichen) für Standardsicherheit in Zahlungssystemen, 6 Bytes (12 Hex-Zeichen) für erhöhte Sicherheit oder die vollen 8 Bytes (16 Hex-Zeichen) für maximalen Schutz. Die Verkürzung gleicht Sicherheit und Nachrichteneffizienz aus - kürzere MACs reduzieren die Bandbreite, bieten aber weniger Sicherheitsbits gegen Brute-Force-Angriffe.' },
      ],
      usage: [
        'Wählen Sie den TDES-Schlüsseltyp: Verwenden Sie 3-Schlüssel-TDES (48 Hex-Zeichen, 24 Bytes) für maximale Sicherheit mit drei unabhängigen Schlüsseln K1, K2, K3 oder 2-Schlüssel-TDES (32 Hex-Zeichen, 16 Bytes) für Legacy-Systeme mit K3=K1. 3-Schlüssel-TDES wird für PCI DSS-Konformität und moderne Zahlungsanwendungen empfohlen.',
        'Geben Sie den TDES-Schlüssel im Hex-Format ein: Für 3-Schlüssel-TDES geben Sie genau 48 Hex-Zeichen ein, die K1||K2||K3 Verkettung darstellen. Für 2-Schlüssel-TDES geben Sie 32 Hex-Zeichen ein, die K1||K2 darstellen. Stellen Sie sicher, dass die Schlüssel korrekte Paritätsbits haben und mit einem kryptografisch sicheren Zufallszahlengenerator erzeugt wurden.',
        'Wählen Sie die Padding-Methode: Wählen Sie ISO 9797-1 Methode 1 (Null-Padding) für Legacy-System-Kompatibilität oder ISO 9797-1 Methode 2 (0x80 gefolgt von Nullen) für erhöhte Sicherheit und eindeutiges Padding. Methode 2 wird für alle neuen Implementierungen empfohlen, um padding-bezogene Schwachstellen zu verhindern.',
        'Geben Sie Nachrichtendaten im Hex-Format ein: Geben Sie die zu authentifizierenden Daten als Hex-Zeichen ein. Die Daten werden automatisch auf ein Vielfaches von 16 Hex-Zeichen (8 Bytes, DES-Blockgröße) gemäß der ausgewählten ISO 9797-1 Methode aufgefüllt, bevor die MAC-Berechnung erfolgt.',
        'Legen Sie die MAC-Verkürzungslänge fest: Geben Sie die Anzahl der Bytes (1-8 Bytes) an, die vom endgültigen 8-Byte-MAC ausgegeben werden sollen. Standard-Zahlungssysteme verwenden 4 Bytes, höhere Sicherheitsanforderungen verwenden 6 Bytes oder verwenden Sie 8 Bytes (vollständiger MAC) für maximale Authentifizierungsstärke. Überprüfen Sie Ihre Systemspezifikationen auf die erforderliche MAC-Länge.',
        'Klicken Sie auf "MAC berechnen": Das Tool verschlüsselt die aufgefüllten Daten mit TDES im CBC-Modus unter Verwendung eines Null-Initialisierungsvektors (IV). Jeder 8-Byte-Block wird mit dem vorherigen verschlüsselten Block XOR-verknüpft und dann mit TDES verschlüsselt. Der Chiffretext des letzten Blocks wird zu Ihrem MAC-Wert.',
        'Kopieren Sie den generierten MAC: Der berechnete MAC wird im Hex-Format mit der angegebenen Verkürzungslänge angezeigt. Verwenden Sie die Schaltfläche zum Kopieren, um den MAC in Ihre Transaktionsnachricht, Zahlungsanforderung, HSM-Befehl oder Verifizierungssystem zu übertragen. Verifizieren Sie den MAC am empfangenden Ende mit demselben Schlüssel, Padding und Verkürzung.',
      ],
    },
    hmac: {
      title: 'HMAC Rechner Online - Hash-basierte Nachrichten-Authentifizierung | HSM Kit',
      description: 'Kostenloser Online HMAC Rechner mit Unterstützung für SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-3, MD5, RIPEMD-160 und mehr Hash-Algorithmen. Generieren Sie RFC 2104 konforme hash-basierte Nachrichten-Authentifizierungscodes für API-Sicherheit, JWT-Token, Webhook-Verifizierung und sichere Kommunikation.',
      keywords: 'HMAC Rechner, HMAC-SHA256, HMAC-SHA512, HMAC-MD5, hash-basiertes MAC, Nachrichten-Authentifizierung, RFC 2104, HMAC-SHA1, HMAC-SHA3, API-Authentifizierung, JWT HMAC, Webhook-Signatur',
      faqTitle: 'HMAC FAQ',
      usageTitle: 'So verwenden Sie den HMAC Rechner',
      faqs: [
        { question: 'Was ist HMAC?', answer: 'HMAC (Hash-based Message Authentication Code, RFC 2104) kombiniert eine kryptografische Hash-Funktion mit einem geheimen Schlüssel, um Nachrichten-Authentifizierungscodes zu erstellen. Es bietet sowohl Datenintegrität als auch Authentizitätsverifizierung. HMAC verarbeitet Daten durch verschachtelte Hash-Operationen: HMAC(K, m) = H((K ⊕ opad) || H((K ⊕ ipad) || m)), wobei K der Schlüssel, m die Nachricht, H die Hash-Funktion und opad/ipad Padding-Konstanten sind. Diese Konstruktion stellt sicher, dass HMAC auch dann sicher bleibt, wenn die Hash-Funktion Schwächen aufweist.' },
        { question: 'Welche Hash-Funktion sollte ich für HMAC verwenden?', answer: 'SHA-256 wird für die meisten Anwendungen empfohlen und bietet 128-Bit-Sicherheitsstärke. Verwenden Sie SHA-512 für 256-Bit-Sicherheit in hochwertige Systemen oder SHA-384 für 192-Bit-Sicherheit. SHA-3 (Keccak) bietet den neuesten NIST-Standard mit unterschiedlicher interner Struktur. Vermeiden Sie MD5-HMAC und SHA-1-HMAC für neue sicherheitskritische Anwendungen aufgrund von Hash-Kollisions-Schwachstellen, obwohl die HMAC-Konstruktion selbst sicher bleibt. Für Legacy-System-Kompatibilität kann SHA-1-HMAC noch akzeptabel sein, da HMAC zusätzliche Sicherheit gegenüber einfachem Hashing bietet.' },
        { question: 'Was ist die empfohlene HMAC-Schlüssellänge?', answer: 'Die Schlüssellänge sollte der Hash-Ausgabegröße entsprechen für optimale Sicherheit: 32 Bytes (256 Bit) für SHA-256, 64 Bytes (512 Bit) für SHA-512, 20 Bytes (160 Bit) für SHA-1. Schlüssel kürzer als die Hash-Ausgabe reduzieren die Sicherheitsstärke. Schlüssel länger als die Hash-Blockgröße (64 Bytes für SHA-256, 128 Bytes für SHA-512) werden vor der Verwendung zunächst gehasht. Verwenden Sie kryptografisch sichere Zufallszahlengeneratoren (CSPRNG) zur Generierung von HMAC-Schlüsseln, verwenden Sie niemals Passwörter oder vorhersagbare Werte direkt als HMAC-Schlüssel.' },
        { question: 'Wo wird HMAC häufig verwendet?', answer: 'HMAC wird weit verbreitet eingesetzt in: API-Authentifizierung (AWS Signature, OAuth 2.0, HMAC-basierte Token), JWT (JSON Web Tokens) mit HS256/HS384/HS512 Algorithmen, Webhook-Signatur-Verifizierung (GitHub, Stripe, PayPal), TLS/SSL (HMAC für Record-Integrität in Cipher Suites), IPsec (Authentication Headers und ESP), Challenge-Response-Protokolle, sichere Dateiintegritäts-Verifizierung und Blockchain/Kryptowährungs-Transaktionssignierung. HMAC wird gegenüber einfachem Hashing für Authentifizierung bevorzugt, weil es Kenntnis des geheimen Schlüssels erfordert.' },
        { question: 'Kann ich die HMAC-Ausgabe verkürzen?', answer: 'Ja, HMAC unterstützt Verkürzung unter Beibehaltung der Sicherheit. RFC 2104 empfiehlt, mindestens die Hälfte der Hash-Ausgabelänge beizubehalten: Minimum 16 Bytes für SHA-256-HMAC (128 Bit Sicherheit), 20 Bytes für SHA-512-HMAC (160 Bit). Übliche Verkürzungen umfassen HMAC-SHA-256-128 (16 Bytes), HMAC-SHA-512-256 (32 Bytes). Verkürzung reduziert die MAC-Größe für bandbreitenbeschränkte Umgebungen, während die Authentifizierungsstärke gegen Fälschungsangriffe erhalten bleibt. Verkürzen Sie niemals unter 80 Bit (10 Bytes) für Sicherheitsanwendungen.' },
      ],
      usage: [
        'Wählen Sie den Hash-Algorithmus: Wählen Sie SHA-256 für Standardsicherheit (128-Bit-Stärke), SHA-512 für hohe Sicherheit (256-Bit-Stärke) oder SHA-3-Varianten für den neuesten NIST-Standard. Vermeiden Sie MD5 und SHA-1 für neue sicherheitskritische Systeme. SHA-224/SHA-384 bieten mittlere Sicherheitsstufen.',
        'Wählen Sie das Schlüssel-Eingabeformat: Wählen Sie "Hexadezimal" für binäre Schlüssel, die als Hex-Strings dargestellt werden (z.B. kryptografische Schlüssel aus Schlüsselverwaltungssystemen), oder "ASCII" für textbasierte gemeinsame Geheimnisse. Hexadezimalformat ist Standard für Zahlungs-HSMs, API-Schlüssel und kryptografische Anwendungen.',
        'Geben Sie den HMAC-Schlüssel ein: Geben Sie Ihren geheimen Schlüssel im ausgewählten Format ein. Für Hexadezimal geben Sie genau die benötigte Anzahl von Bytes ein (32 Hex-Zeichen = 16 Bytes für SHA-256-Schlüssel). Schlüssel sollten mit CSPRNG generiert und sicher gespeichert werden. Hardcodieren Sie niemals Schlüssel oder verwenden Sie schwache Passwörter als HMAC-Schlüssel.',
        'Wählen Sie das Daten-Eingabeformat: Wählen Sie "Hexadezimal" für binäre Nachrichtendaten (Zahlungsnachrichten, binäre Protokolle) oder "ASCII" für Textnachrichten (API-Anfragen, Webhook-Payloads). Das Format muss übereinstimmen, wie Ihr System die Daten verarbeitet, um eine erfolgreiche HMAC-Verifizierung zu gewährleisten.',
        'Geben Sie Nachrichtendaten ein: Geben Sie die vollständige Nachricht oder Daten zur Authentifizierung ein. Für API-Anfragen umfasst dies typischerweise HTTP-Methode, URL-Pfad, Zeitstempel und Request-Body in einer bestimmten Reihenfolge verkettet. Stellen Sie exakte Byte-für-Byte-Übereinstimmung einschließlich Leerzeichen für erfolgreiche HMAC-Verifizierung sicher.',
        'Klicken Sie auf "HMAC berechnen": Das Tool berechnet HMAC mit dem RFC 2104 Algorithmus: HMAC(K,m) = H((K ⊕ opad) || H((K ⊕ ipad) || m)). Der Schlüssel wird mit inneren und äußeren Padding-Konstanten XOR-verknüpft, dann wird verschachteltes Hashing angewendet. Das Ergebnis wird im Hexadezimalformat angezeigt.',
        'Kopieren und verifizieren Sie den HMAC: Verwenden Sie die Schaltfläche zum Kopieren, um den HMAC in Ihre Anwendung, API-Header (z.B. X-Signature, Authorization) oder Verifizierungssystem zu übertragen. Die empfangende Partei berechnet HMAC mit demselben Schlüssel und Algorithmus neu und vergleicht dann Byte für Byte. Übereinstimmende HMACs bestätigen Nachrichtenintegrität und Authentizität.',
      ],
    },
    cmac: {
      title: 'CMAC Rechner Online - Blockchiffre-basierte Nachrichten-Authentifizierung | HSM Kit',
      description: 'Kostenloser Online CMAC Rechner mit Unterstützung für AES-CMAC und TDES-CMAC (3DES-CMAC). Generieren Sie NIST SP 800-38B konforme chiffrebasierte Nachrichten-Authentifizierungscodes für sichere Kommunikation, Datenintegritätsverifizierung und kryptografische Protokolle.',
      keywords: 'CMAC Rechner, AES-CMAC, TDES-CMAC, 3DES-CMAC, chiffrebasiertes MAC, AES CMAC 96, NIST SP 800-38B, Nachrichten-Authentifizierung, Blockchiffre MAC, AES-128 CMAC, AES-256 CMAC',
      faqTitle: 'CMAC FAQ',
      usageTitle: 'So verwenden Sie den CMAC Rechner',
      faqs: [
        { question: 'Was ist CMAC?', answer: 'CMAC (Cipher-based Message Authentication Code, NIST SP 800-38B) ist ein auf Blockchiffren basierender MAC-Algorithmus, der Datenintegrität und Authentizitätsverifizierung bietet. Es verwendet Blockchiffren wie AES oder Triple DES (TDES) in einem ausgeklügelten Subkey-Ableitungsschema. CMAC verarbeitet Daten in Blöcken, generiert zwei Subkeys (K1 und K2) aus dem Verschlüsselungsschlüssel und wendet dann Cipher Block Chaining mit spezifischen Padding-Regeln an. Der letzte Block wird vor der finalen Verschlüsselung mit K1 (für vollständige Blöcke) oder K2 (für gepolsterte Blöcke) XOR-verknüpft. CMAC bietet eine Sicherheit, die der zugrunde liegenden Blockchiffre entspricht, und wird in modernen kryptografischen Protokollen weit verbreitet verwendet.' },
        { question: 'Welche Chiffre sollte ich für CMAC verwenden?', answer: 'AES-CMAC wird für neue Anwendungen dringend empfohlen und bietet je nach Schlüsselgröße (AES-128, AES-192, AES-256) 128-Bit-, 192-Bit- oder 256-Bit-Sicherheit. AES bietet exzellente Leistung auf moderner Hardware mit AES-NI-Beschleunigung. TDES-CMAC (3DES-CMAC) bietet nur 112-Bit effektive Sicherheit und ist deutlich langsamer, kann jedoch für Legacy-System-Kompatibilität oder regulatorische Compliance in Finanz-/Zahlungssystemen erforderlich sein. Für neue Implementierungen verwenden Sie AES-256-CMAC für maximale Sicherheit. AES-128-CMAC bietet ein gutes Gleichgewicht zwischen Sicherheit und Leistung für die meisten Anwendungen.' },
        { question: 'Was sind die CMAC-Schlüssellängenanforderungen?', answer: 'AES-CMAC unterstützt drei Schlüssellängen: 128 Bit (16 Bytes/32 Hex-Zeichen) für AES-128-CMAC, 192 Bit (24 Bytes/48 Hex-Zeichen) für AES-192-CMAC und 256 Bit (32 Bytes/64 Hex-Zeichen) für AES-256-CMAC. TDES-CMAC benötigt entweder 128 Bit (16 Bytes/32 Hex-Zeichen) für 2-Key TDES (K1=K3) oder 192 Bit (24 Bytes/48 Hex-Zeichen) für 3-Key TDES (alle Schlüssel eindeutig). Schlüssel müssen mit kryptografisch sicheren Zufallszahlengeneratoren (CSPRNG) generiert werden. Leiten Sie niemals CMAC-Schlüssel von Passwörtern ohne geeignete Key Derivation Functions (KDF) wie PBKDF2 oder HKDF ab. Speichern Sie Schlüssel sicher mit Hardware-Sicherheitsmodulen (HSM) oder Schlüsselverwaltungssystemen.' },
        { question: 'Wo wird CMAC häufig verwendet?', answer: 'CMAC wird weit verbreitet in modernen kryptografischen Protokollen eingesetzt: TLS 1.3 Cipher Suites für Record-Authentifizierung, IPsec AH (Authentication Header) und ESP (Encapsulating Security Payload) für VPN-Sicherheit, IEEE 802.11i (WPA2/WPA3) für WLAN-Authentifizierung, NIST-Schlüsselverwaltungsstandards (SP 800-108, SP 800-56C) für Schlüsselableitung und -bestätigung, EMV-Contactless-Zahlungskarten für Offline-Authentifizierung, ISO/IEC 9797-1 Algorithmus 5 für Finanzn achrichten-Authentifizierung, Automotive-Sicherheit (AUTOSAR SecOC) für Fahrzeug-Netzwerkschutz, Bluetooth LE Secure Connections für Gerätekopplung und Firmware-Integritätsverifizierung in Secure-Boot-Prozessen. CMAC wird gegenüber CBC-MAC bevorzugt, da es Nachrichten variabler Länge sicher ohne Längenvoranstellung verarbeitet.' },
        { question: 'Kann ich die CMAC-Ausgabe verkürzen?', answer: 'Ja, CMAC unterstützt Verkürzung unter Beibehaltung der Sicherheit. NIST SP 800-38B empfiehlt minimale MAC-Längen: Für AES-CMAC verwenden Sie mindestens 64 Bit (8 Bytes) für allgemeine Sicherheit, 96 Bit (12 Bytes) für starke Sicherheitsanwendungen (AES-CMAC-96 ist üblich in IPsec und drahtlosen Protokollen) oder volle 128 Bit (16 Bytes) für maximale Sicherheit. Für TDES-CMAC verwenden Sie minimum 64 Bit (8 Bytes), typisch sind 80 Bit (10 Bytes) oder volle 64 Bit (8 Bytes) Ausgabe. Verkürzung beeinflusst die Sicherheitsstärke: 96-Bit MAC bietet 2^96 Kollisionsresistenz und 2^48 Fälschungsresistenz, 64-Bit MAC bietet 2^64 Kollisionsresistenz und 2^32 Fälschungsresistenz (marginal für hochwertige Daten). Verkürzen Sie niemals unter 64 Bit für sicherheitskritische Anwendungen. Verkürzung erfolgt durch Nehmen der linkesten (höchstwertigen) Bytes der vollen CMAC-Ausgabe.' },
      ],
      usage: [
        'Verschlüsselungsalgorithmus wählen: Wählen Sie "AES" für moderne Anwendungen mit 128-Bit- bis 256-Bit-Sicherheit und Hardware-Beschleunigungsunterstützung, oder "TDES" für Legacy-System-Kompatibilität (112-Bit effektive Sicherheit, langsamere Leistung). AES-CMAC wird für neue Implementierungen empfohlen.',
        'Schlüssel-Eingabeformat wählen: Wählen Sie "Hexadezimal" für binäre Schlüssel, die als Hex-Strings dargestellt werden (Standard für kryptografische Anwendungen, HSMs und Schlüsselverwaltungssysteme), oder "ASCII" für textbasierte Schlüssel (weniger üblich, nicht für Produktion empfohlen). Hexadezimalformat wird für präzise binäre Schlüsseleingabe bevorzugt.',
        'CMAC-Schlüssel eingeben: Geben Sie Ihren geheimen Schlüssel im ausgewählten Format ein. Für AES muss der Schlüssel exakt 32 Hex-Zeichen (128-Bit AES-128), 48 Hex-Zeichen (192-Bit AES-192) oder 64 Hex-Zeichen (256-Bit AES-256) sein. Für TDES muss der Schlüssel 32 Hex-Zeichen (2-Key TDES, K1=K3) oder 48 Hex-Zeichen (3-Key TDES) sein. Schlüssel sollten mit CSPRNG generiert und sicher gespeichert werden. Hardcodieren Sie niemals Schlüssel oder verwenden Sie schwache Passwörter direkt als CMAC-Schlüssel.',
        'Daten-Eingabeformat wählen: Wählen Sie "Hexadezimal" für binäre Nachrichtendaten (Protokollnachrichten, binäre Dateien, Zahlungsnachrichten) oder "ASCII" für Textnachrichten (API-Anfragen, Zeichenkettendaten). Das Format muss übereinstimmen, wie Ihr System die Daten verarbeitet, um erfolgreiche CMAC-Verifizierung zu gewährleisten.',
        'Nachrichtendaten eingeben: Geben Sie die vollständige Nachricht oder Daten zur Authentifizierung ein. CMAC verarbeitet Nachrichten variabler Länge automatisch mit geeignetem Padding (ISO/IEC 9797-1 Padding-Methode 2). Für Verifizierung stellen Sie exakte Byte-für-Byte-Übereinstimmung der Nachricht sicher, einschließlich aller Header, Zeitstempel oder strukturierten Daten in der exakten Reihenfolge, die für die ursprüngliche CMAC-Berechnung verwendet wurde.',
        'Optionale AES-CMAC-96-Verkürzung: Nur für AES, aktivieren Sie die Option "AES CMAC 96", um die Ausgabe auf 96 Bit (12 Bytes) statt voller 128 Bit zu verkürzen. Dies wird häufig in IPsec, IEEE 802.11i und anderen Protokollen verwendet, bei denen die Bandbreite begrenzt ist. Verkürzte MACs bieten immer noch starke Sicherheit (2^96 Kollisionsresistenz) bei reduziertem Overhead.',
        'CMAC berechnen und verifizieren: Klicken Sie auf "CMAC berechnen", um den Authentifizierungscode mit dem NIST SP 800-38B-Algorithmus mit Subkey-Ableitung (K1/K2) zu generieren. Das Ergebnis wird im Hexadezimalformat angezeigt. Verwenden Sie die Kopieren-Schaltfläche, um CMAC in Ihre Anwendung, API-Header oder Verifizierungssystem zu übertragen. Die empfangende Partei berechnet CMAC mit demselben Schlüssel und Algorithmus neu und führt dann einen Byte-für-Byte-Vergleich durch. Übereinstimmende CMACs bestätigen Nachrichtenintegrität und Authentizität.',
      ],
    },
    retailMac: {
      title: 'Retail MAC Rechner Online - DES & 3DES Nachrichtenauthentifizierung | HSM Kit',
      description: 'Kostenloser Online Retail MAC Rechner mit Unterstützung für DES und Triple DES mit ISO 9797-1 Methode 2 Padding. Generieren Sie sichere MACs für Zahlungssysteme mit optionaler 3DES-Finalisierung für erhöhte Sicherheit.',
      keywords: 'Retail MAC, DES MAC, 3DES MAC, Triple DES, ISO 9797-1, Methode 2 Padding, Nachrichtenauthentifizierung, Zahlungs-MAC, Finanz-MAC, POS MAC, ATM-Sicherheit, Bank-MAC, 3DES-Finalisierung',
      faqTitle: 'Retail MAC FAQ',
      usageTitle: 'So verwenden Sie den Retail MAC Rechner',
      faqs: [
        { question: 'Was ist Retail MAC?', answer: 'Retail MAC ist ein weit verbreiteter MAC-Algorithmus in Zahlungs- und Banksystemen, der DES- oder Triple DES-Verschlüsselung mit ISO 9797-1 Methode 2 Padding (0x80 gefolgt von Nullen) verwendet. Er verarbeitet Daten im CBC-Modus und extrahiert den letzten Block als MAC-Wert. Retail MAC wird häufig in POS-Terminals, Geldautomaten und der Authentifizierung von Finanznachrichten verwendet, wo DES-basierte Sicherheit für die Kompatibilität mit Legacy-Systemen erforderlich ist.' },
        { question: 'Sollte ich 3DES-Finalisierung verwenden?', answer: 'Ja, die Verwendung der 3DES-Finalisierung wird für bessere Sicherheit dringend empfohlen. Standard-DES Retail MAC verwendet durchgehend Single DES und bietet 56-Bit effektive Sicherheit. Bei aktivierter 3DES-Finalisierung wird der finale MAC-Block mit Triple DES verschlüsselt (112-Bit effektive Sicherheit), was ihn erheblich widerstandsfähiger gegen Brute-Force-Angriffe macht, während die Rückwärtskompatibilität mit Systemen erhalten bleibt, die DES-basierte MACs erwarten.' },
        { question: 'Was ist der Unterschied zwischen DES- und 3DES-Algorithmusauswahl?', answer: 'Wenn Sie den "DES"-Algorithmus wählen, verwendet die gesamte CBC-MAC-Kette Single-DES-Verschlüsselung (optional mit 3DES-Finalisierung am letzten Block). Wenn Sie den "3DES"-Algorithmus wählen, verwendet die gesamte CBC-MAC-Kette Triple-DES-Verschlüsselung, was durchgehend stärkere Sicherheit bietet. Verwenden Sie den DES-Modus für die Kompatibilität mit Legacy-Systemen und den 3DES-Modus für moderne sichere Implementierungen.' },
        { question: 'Welche Padding-Methode verwendet Retail MAC?', answer: 'Retail MAC verwendet ISO 9797-1 Methode 2 Padding: Hängen Sie 0x80-Byte gefolgt von Null-Bytes an, um die nächste 8-Byte-Blockgrenze zu erreichen. Wenn Ihre Daten beispielsweise bei 5 Bytes enden, fügt Padding 0x80 00 00 (3 Bytes) hinzu. Wenn die Daten genau blockausgerichtet sind (8, 16, 24 Bytes...), wird ein vollständiger Padding-Block (0x80 00 00 00 00 00 00 00) angehängt.' },
        { question: 'Welche Schlüssellängen werden unterstützt?', answer: 'Für DES-Modus: Schlüssel K muss genau 16 Hexadezimalzeichen (8 Bytes) sein. Wenn 3DES-Finalisierung aktiviert ist, sollte Schlüssel K\' auch 16 Hexadezimalzeichen für den finalen Verschlüsselungsschritt sein. Für 3DES-Modus: Schlüssel K ist 16 Hexadezimalzeichen (2-Schlüssel TDES, K1=K3), oder Sie können sowohl Schlüssel K als auch Schlüssel K\' (jeweils 16 Hexadezimalzeichen) für vollständiges 3-Schlüssel Triple DES bereitstellen, bei dem alle drei Schlüssel eindeutig sind.' },
      ],
      usage: [
        'Algorithmus auswählen (DES oder 3DES): Wählen Sie DES für Legacy-Kompatibilität mit Single-DES-Verschlüsselung in der gesamten MAC-Kette oder 3DES für stärkere Sicherheit mit Triple-DES-Verschlüsselung während der gesamten Berechnung.',
        'Finalisierungsmethode wählen: Wählen Sie "Keine" für Standardverarbeitung oder "3DES", um den finalen MAC-Block mit Triple DES zu verschlüsseln, um die Sicherheit zu erhöhen und gleichzeitig die DES-basierte MAC-Struktur beizubehalten.',
        'Schlüssel K eingeben: Geben Sie den Primärschlüssel als 16 Hexadezimalzeichen (8 Bytes) ein. Dieser Schlüssel wird für die DES-Verschlüsselung in der CBC-MAC-Kette verwendet. Stellen Sie sicher, dass der Schlüssel sicher generiert und in einem Hardware-Sicherheitsmodul (HSM) gespeichert ist.',
        'Schlüssel K\' eingeben (falls zutreffend): Wenn Sie 3DES-Finalisierung oder 3DES-Algorithmusmodus verwenden, geben Sie den zweiten Schlüssel als 16 Hexadezimalzeichen an. Für 2-Schlüssel TDES können Sie dies leer lassen, um Schlüssel K wiederzuverwenden.',
        'Nachrichtendaten eingeben: Geben Sie die zu authentifizierenden Daten im Hexadezimalformat ein. Das Tool wendet automatisch ISO 9797-1 Methode 2 Padding (0x80 gefolgt von Nullen) an, um Daten auf 8-Byte-Blöcke auszurichten.',
        'Kürzungslänge festlegen: Geben Sie die MAC-Ausgabelänge in Bytes an (1-8). Vollständiger MAC ist 8 Bytes (64 Bit). Typische Werte sind 4 Bytes (32 Bit) für bandbreitenbeschränkte Systeme oder 8 Bytes (vollständiger MAC) für maximale Sicherheit.',
        'MAC berechnen und verifizieren: Klicken Sie auf "MAC berechnen", um den Authentifizierungscode mit CBC-Modus und dem ausgewählten Algorithmus und Finalisierung zu generieren. Das Ergebnis wird im Hexadezimalformat angezeigt. Kopieren Sie den MAC in Ihr Zahlungssystem, API-Header oder Verifizierungsmodul.',
      ],
    },
    zka: {
      title: 'ZKA Deutscher Bankenstandard Kryptografische Operationen | HSM Kit',
      description: 'Kostenloses Online-ZKA-Kryptografie-Tool für deutsche Bankensysteme. Führen Sie Sitzungsschlüssel(SK)-Ableitung, PIN-Verschlüsselung/-Entschlüsselung und MAC-Berechnung mit Triple DES durch. Implementiert den ZKA-Standard für sichere Zahlungsverarbeitung.',
      keywords: 'ZKA, Deutsche Banken, Zentraler Kreditausschuss, Sitzungsschlüsselableitung, SK-Ableitung, PIN-Verschlüsselung, MAC-Berechnung, TDES, 3DES, Deutscher Zahlungsstandard, Bankenkryptografie',
      faqTitle: 'ZKA FAQ',
      usageTitle: 'So verwenden Sie das ZKA-Tool',
      faqs: [
        { question: 'Was ist ZKA?', answer: 'ZKA (Zentraler Kreditausschuss) ist ein deutscher Bankenstandard, der kryptografische Operationen für sichere Zahlungsverarbeitung definiert, einschließlich Schlüsselableitung, PIN-Verarbeitung und Nachrichtenauthentifizierung. Er wird in der deutschen Bankeninfrastruktur für Geldautomaten- und POS-Transaktionen weit verbreitet eingesetzt.' },
        { question: 'Was ist SK-Ableitung?', answer: 'Die Sitzungsschlüssel(SK)-Ableitung ist der Prozess der Generierung eines temporären Sitzungsschlüssels aus einem Hauptschlüssel (MK), Befehlsdaten (CM) und einer Zufallszahl (Rnd). Dies stellt sicher, dass jede Transaktion einen eindeutigen Schlüssel verwendet und erhöht die Sicherheit durch Verhinderung von Schlüsselwiederverwendungsangriffen.' },
        { question: 'Wie funktioniert die ZKA-PIN-Verschlüsselung?', answer: 'ZKA verwendet Triple DES (3DES) im ECB-Modus, um PIN-Blöcke mit dem abgeleiteten Sitzungsschlüssel (SK-pac) zu verschlüsseln. Der PIN-Block muss 8 Bytes (16 Hex-Zeichen) umfassen. Dies ermöglicht eine sichere PIN-Übertragung zwischen Zahlungsterminals und Hostsystemen.' },
        { question: 'Welchen MAC-Algorithmus verwendet ZKA?', answer: 'ZKA verwendet Triple DES CBC-MAC zur Nachrichtenauthentifizierung. Der MAC wird berechnet, indem Datenblöcke im CBC-Modus verarbeitet und der endgültige verschlüsselte Block als MAC-Wert genommen wird. Dies gewährleistet die Integrität und Authentizität von Nachrichten bei Finanztransaktionen.' },
      ],
      usage: [
        'SK-Ableitungs-Tab: Geben Sie Hauptschlüssel (MK), Befehlsdaten (CM) und Zufallszahl (Rnd) im Hex-Format ein (jeweils 32 Hex-Zeichen). Klicken Sie auf "SK ableiten", um den Sitzungsschlüssel zu generieren.',
        'PIN-Tab: Geben Sie den Sitzungsschlüssel (SK-pac) und den PIN-Block (8 Bytes, 16 Hex-Zeichen) ein. Klicken Sie auf "Verschlüsseln", um den PIN-Block zu verschlüsseln, oder auf "Entschlüsseln", um ihn zu entschlüsseln.',
        'MAC-Tab: Geben Sie den MAC-Schlüssel (32 Hex-Zeichen) und Daten im Hex-Format ein. Klicken Sie auf "MAC berechnen", um den Nachrichtenauthentifizierungscode zu generieren.',
        'Alle Eingaben müssen im Hex-Format vorliegen. Schlüssel sind 16 Bytes (32 Hex-Zeichen) und PIN-Blöcke sind 8 Bytes (16 Hex-Zeichen).',
      ],
    },
    asn1: {
      title: 'ASN.1 Parser Online - Kostenloser DER/BER Struktur-Decoder | HSM Kit',
      description: 'Kostenloser Online ASN.1 Parser und Decoder. ASN.1 DER/BER Strukturen parsen, X.509 Zertifikate decodieren, PKCS Formate analysieren. Unterstützt Hex, Base64 und PEM Eingabe mit RFC-Definition-Matching. 100% clientseitig.',
      keywords: 'ASN.1 Parser, DER Decoder, BER Decoder, X.509 Zertifikat Parser, PKCS Decoder, ASN1 Online Tool, Zertifikat Analyzer, PEM Parser, ASN.1 Decoder, Zertifikat Parser, PKCS Parser',
      faqTitle: 'ASN.1 Parser FAQ',
      usageTitle: 'ASN.1 Parser Anleitung',
      faqs: [
        { question: 'Was ist ASN.1?', answer: 'ASN.1 (Abstract Syntax Notation One) ist eine Standard-Schnittstellenbeschreibungssprache zur Definition von Datenstrukturen, die serialisiert und deserialisiert werden können. Es wird weitverbreitet in Kryptografie, Telekommunikation und Netzwerkprotokollen verwendet.' },
        { question: 'Welche Formate unterstützt dieser Parser?', answer: 'Dieser Parser unterstützt DER (Distinguished Encoding Rules) und BER (Basic Encoding Rules) kodierte ASN.1 Strukturen. Sie können Daten im Hexadezimal-, Base64- oder PEM-Format eingeben.' },
        { question: 'Kann ich X.509 Zertifikate parsen?', answer: 'Ja, dieses Tool kann X.509 Zertifikate, CSRs, PKCS#7/8/12 Strukturen und andere Zertifikatformate parsen, die ASN.1 Kodierung verwenden.' },
        { question: 'Was ist die Hex-Dump Funktion?', answer: 'Die Hex-Dump Funktion zeigt die rohen Bytes der ASN.1 Struktur neben der geparsten Baumansicht, was das Verständnis der binären Kodierung erleichtert.' },
      ],
      usage: [
        'Fügen Sie Ihre ASN.1 kodierten Daten im Hexadezimal-, Base64- oder PEM-Format in das Eingabefeld ein.',
        'Klicken Sie auf "Parsen" um die Struktur zu decodieren und die hierarchische Baumdarstellung anzuzeigen.',
        'Aktivieren Sie "mit Hex-Dump" um die rohen Bytes neben der geparsten Struktur zu sehen.',
        'Verwenden Sie "mit Definitionen" um die Struktur mit bekannten RFC-Definitionen wie X.509, PKCS usw. abzugleichen.',
      ],
    },
    aes: {
      title: 'AES Verschlüsselung Online - Kostenloser AES Rechner | HSM Kit',
      description: 'Kostenloses Online AES Verschlüsselungs- und Entschlüsselungs-Tool. Unterstützt AES-128, AES-192, AES-256 mit ECB, CBC, CFB, OFB, CTR Modi. KCV berechnen, Hex- oder Textdaten sicher im Browser verschlüsseln/entschlüsseln. 100% clientseitig, keine Daten werden an Server gesendet.',
      keywords: 'AES Verschlüsselung, AES Entschlüsselung, AES-128, AES-192, AES-256, AES Rechner, AES Online Tool, AES ECB, AES CBC, AES KCV, Advanced Encryption Standard, symmetrische Verschlüsselung',
      faqTitle: 'AES Verschlüsselung FAQ',
      usageTitle: 'AES Verschlüsselungs-Tool Anleitung',
      faqs: [
        { question: 'Was ist AES Verschlüsselung?', answer: 'AES (Advanced Encryption Standard) ist eine symmetrische Blockchiffre, die zum weltweiten Standard für Verschlüsselung geworden ist. Es verschlüsselt Daten in 128-Bit Blöcken mit Schlüsseln von 128, 192 oder 256 Bit.' },
        { question: 'Welchen AES Modus sollte ich verwenden?', answer: 'CBC Modus wird üblicherweise für die meisten Anwendungen empfohlen. ECB Modus sollte für Daten größer als ein Block vermieden werden, da er Muster offenbart. CTR Modus ist gut für Streaming-Daten.' },
        { question: 'Welche Schlüsselgrößen unterstützt AES?', answer: 'AES unterstützt drei Schlüsselgrößen: AES-128 (16 Bytes), AES-192 (24 Bytes) und AES-256 (32 Bytes). Längere Schlüssel bieten stärkere Sicherheit.' },
        { question: 'Was ist IV bei AES Verschlüsselung?', answer: 'IV (Initialisierungsvektor) ist ein zufälliger Wert, der mit Modi wie CBC, CFB, OFB und CTR verwendet wird, um sicherzustellen, dass identische Klartexte unterschiedliche Chiffretexte erzeugen. IV sollte einzigartig sein, muss aber nicht geheim sein.' },
      ],
      usage: [
        'Wählen Sie die AES Schlüsselgröße (128, 192 oder 256 Bit) und den Verschlüsselungsmodus (ECB, CBC, usw.).',
        'Geben Sie Ihren Verschlüsselungsschlüssel im Hexadezimalformat ein.',
        'Für Modi außer ECB geben Sie einen IV (16 Bytes in Hex) an.',
        'Geben Sie Ihre Daten zum Verschlüsseln oder Entschlüsseln ein und klicken Sie auf die entsprechende Schaltfläche.',
      ],
    },
    des: {
      title: 'DES/3DES Verschlüsselung Online - Kostenloser Triple DES Rechner | HSM Kit',
      description: 'Kostenloses Online DES und Triple DES (3DES) Verschlüsselungs- und Entschlüsselungs-Tool. Unterstützt DES, 2-Key 3DES, 3-Key 3DES mit ECB/CBC Modi. Mehrere Padding-Optionen einschließlich PKCS5, ISO 7816 und mehr. 100% clientseitig, sichere Verschlüsselung.',
      keywords: 'DES Verschlüsselung, 3DES Verschlüsselung, Triple DES, DES Entschlüsselung, DES Rechner, 3DES Online Tool, TDES, DES ECB, DES CBC, Datenverschlüsselungsstandard, Zahlungsverschlüsselung',
      faqTitle: 'DES/3DES Verschlüsselung FAQ',
      usageTitle: 'DES/3DES Tool Anleitung',
      faqs: [
        { question: 'Was ist der Unterschied zwischen DES und 3DES?', answer: 'DES verwendet einen einzelnen 56-Bit Schlüssel (8 Bytes mit Parität), während 3DES den DES-Algorithmus dreimal mit zwei oder drei verschiedenen Schlüsseln (16 oder 24 Bytes) anwendet und viel stärkere Sicherheit bietet.' },
        { question: 'Ist DES noch sicher?', answer: 'Einzel-DES gilt als unsicher und veraltet. 3DES wird noch in Legacy-Systemen verwendet, besonders in der Zahlungsbranche, aber AES wird für neue Anwendungen empfohlen.' },
        { question: 'Was sind Paritätsbits in DES-Schlüsseln?', answer: 'Bei DES hat jedes Byte des Schlüssels ein Paritätsbit (das niedrigstwertige Bit), wodurch die effektive Schlüssellänge von 64 Bit auf 56 Bit reduziert wird. Dieses Tool kann Paritätsbits automatisch anpassen.' },
        { question: 'Welches Padding sollte ich verwenden?', answer: 'PKCS5/PKCS7 ist die häufigste Wahl. ISO 9797 wird oft in Bankanwendungen verwendet. Die Wahl sollte mit dem übereinstimmen, was Ihre Gegenseite erwartet.' },
      ],
      usage: [
        'Wählen Sie DES (8 Bytes Schlüssel) oder 3DES (16 oder 24 Bytes Schlüssel).',
        'Wählen Sie den Verschlüsselungsmodus (ECB oder CBC) und die Padding-Methode.',
        'Geben Sie Ihren Schlüssel im Hexadezimalformat ein.',
        'Für CBC Modus geben Sie einen IV (8 Bytes in Hex) an.',
        'Geben Sie Daten ein und klicken Sie auf Verschlüsseln oder Entschlüsseln.',
      ],
    },
    rsa: {
      title: 'RSA Verschlüsselung Online - Kostenloser RSA Rechner & Schlüsselgenerator | HSM Kit',
      description: 'Kostenloses Online RSA Verschlüsselungs-, Entschlüsselungs-, Signatur- und Verifizierungs-Tool. Generieren Sie RSA Schlüsselpaare (1024-4096 Bit), verschlüsseln Sie mit dem öffentlichen Schlüssel, signieren Sie mit dem privaten Schlüssel. Unterstützt PKCS#1 und OAEP Padding. Alle Operationen werden clientseitig durchgeführt.',
      keywords: 'RSA Verschlüsselung, RSA Entschlüsselung, RSA Schlüsselgenerator, RSA Rechner, RSA Online Tool, RSA Signatur, RSA Verifizierung, Public Key Verschlüsselung, PKCS1, OAEP, asymmetrische Verschlüsselung, digitale Signatur',
      faqTitle: 'RSA Verschlüsselung FAQ',
      usageTitle: 'RSA Tool Anleitung',
      faqs: [
        { question: 'Was ist RSA Verschlüsselung?', answer: 'RSA ist ein asymmetrischer Verschlüsselungsalgorithmus, der ein Schlüsselpaar verwendet - einen öffentlichen Schlüssel zur Verschlüsselung und einen privaten Schlüssel zur Entschlüsselung. Er wird weitverbreitet für sichere Datenübertragung und digitale Signaturen verwendet.' },
        { question: 'Welche Schlüsselgröße sollte ich verwenden?', answer: 'Für aktuelle Sicherheitsstandards gelten 2048-Bit Schlüssel als Minimum. 4096-Bit Schlüssel werden für langfristige Sicherheit empfohlen. 1024-Bit Schlüssel sind veraltet.' },
        { question: 'Was ist der Unterschied zwischen PKCS#1 und OAEP?', answer: 'PKCS#1 v1.5 ist ein älteres Padding-Schema. OAEP (Optimal Asymmetric Encryption Padding) ist sicherer und wird für neue Anwendungen empfohlen, da es bestimmte Angriffe verhindert.' },
        { question: 'Was ist die maximale Datengröße für RSA Verschlüsselung?', answer: 'RSA kann nur Daten verschlüsseln, die kleiner sind als die Schlüsselgröße minus Padding-Overhead. Für einen 2048-Bit Schlüssel mit OAEP-SHA256 sind es maximal etwa 190 Bytes. Verwenden Sie hybride Verschlüsselung für größere Daten.' },
      ],
      usage: [
        'Generieren Sie ein neues RSA Schlüsselpaar oder importieren Sie vorhandene Schlüssel.',
        'Für Verschlüsselung: Klartext eingeben und Verschlüsseln klicken (verwendet öffentlichen Schlüssel).',
        'Für Entschlüsselung: Chiffretext eingeben und Entschlüsseln klicken (erfordert privaten Schlüssel).',
        'Für Signatur: Daten-Hash eingeben und Signieren klicken (erfordert privaten Schlüssel).',
        'Für Verifizierung: Daten, Signatur eingeben und Verifizieren klicken (verwendet öffentlichen Schlüssel).',
      ],
    },
    ecc: {
      title: 'ECC/ECDSA Online Tool - Elliptische Kurven Kryptografie | HSM Kit',
      description: 'Kostenloses Online ECC (Elliptische Kurven Kryptografie) Tool. Generieren Sie ECDSA Schlüsselpaare, signieren und verifizieren Sie Daten mit secp256k1, P-256, P-384 Kurven. Kompakte Schlüssel mit starker Sicherheit. 100% Browser-Verarbeitung.',
      keywords: 'ECC Verschlüsselung, ECDSA, elliptische Kurve, secp256k1, P-256, P-384, ECC Schlüsselgenerator, ECDSA Signatur, ECDSA Verifizierung, Bitcoin Kryptografie, Ethereum Kryptografie, digitale Signatur',
      faqTitle: 'ECC/ECDSA FAQ',
      usageTitle: 'ECC/ECDSA Tool Anleitung',
      faqs: [
        { question: 'Was ist ECC?', answer: 'Elliptische Kurven Kryptografie (ECC) ist ein Ansatz zur Public-Key-Kryptografie basierend auf der algebraischen Struktur elliptischer Kurven. Es bietet äquivalente Sicherheit zu RSA mit viel kleineren Schlüsselgrößen.' },
        { question: 'Was ist secp256k1?', answer: 'secp256k1 ist die elliptische Kurve, die von Bitcoin und Ethereum für ihre digitalen Signaturen verwendet wird. Sie bietet eine gute Balance zwischen Sicherheit und Performance.' },
        { question: 'Warum ECC statt RSA verwenden?', answer: 'ECC bietet das gleiche Sicherheitsniveau wie RSA mit viel kleineren Schlüsseln (256-Bit ECC ≈ 3072-Bit RSA), was zu schnelleren Operationen und geringerem Speicher-/Bandbreitenbedarf führt.' },
        { question: 'Was ist ECDSA?', answer: 'ECDSA (Elliptic Curve Digital Signature Algorithm) ist der auf ECC basierende Signaturalgorithmus. Er wird verwendet, um digitale Signaturen zu erstellen, die die Authentizität von Daten verifizieren können.' },
      ],
      usage: [
        'Wählen Sie die elliptische Kurve (secp256k1, P-256 oder P-384).',
        'Generieren Sie ein neues Schlüsselpaar oder importieren Sie vorhandene Schlüssel.',
        'Für Signatur: Daten (oder deren Hash) eingeben und Signieren klicken.',
        'Für Verifizierung: Originaldaten, Signatur eingeben und Verifizieren klicken.',
      ],
    },
    fpe: {
      title: 'Format-Preserving Encryption (FPE) Online - FF1/FF3-1 Tool | HSM Kit',
      description: 'Kostenloses Online Format-Preserving Encryption Tool gemäß NIST SP 800-38G. Verschlüsseln Sie Daten unter Beibehaltung von Format und Länge. Ideal für die Tokenisierung von Kreditkartennummern, Sozialversicherungsnummern und anderen strukturierten Daten. PCI DSS konform.',
      keywords: 'FPE, Format Preserving Encryption, FF1, FF3, FF3-1, NIST 800-38G, Tokenisierung, Kreditkarten Verschlüsselung, Datenmaskierung, PCI DSS, Daten-Tokenisierung, strukturierte Datenverschlüsselung',
      faqTitle: 'Format-Preserving Encryption FAQ',
      usageTitle: 'FPE Tool Anleitung',
      faqs: [
        { question: 'Was ist Format-Preserving Encryption?', answer: 'FPE ist eine Verschlüsselungsmethode, die Chiffretext im gleichen Format und mit gleicher Länge wie der Klartext erzeugt. Beispielsweise wird eine 16-stellige Kreditkartennummer zu einer anderen 16-stelligen Nummer verschlüsselt.' },
        { question: 'Was ist der Unterschied zwischen FF1 und FF3-1?', answer: 'Beide sind NIST-genehmigte FPE-Algorithmen. FF1 unterstützt Tweaks variabler Länge, während FF3-1 einen festen 56-Bit Tweak verwendet. FF3-1 ist im Allgemeinen schneller, hat aber mehr Einschränkungen.' },
        { question: 'Was ist Tokenisierung?', answer: 'Tokenisierung ersetzt sensible Daten durch nicht-sensible Platzhalter (Token). FPE wird oft für Tokenisierung verwendet, da die Token das ursprüngliche Datenformat beibehalten.' },
        { question: 'Ist FPE PCI DSS konform?', answer: 'Ja, FPE mit NIST SP 800-38G genehmigten Algorithmen (FF1, FF3-1) wird bei korrekter Implementierung für PCI DSS Compliance akzeptiert.' },
      ],
      usage: [
        'Wählen Sie den FPE-Algorithmus (FF1 oder FF3-1) und den Radix (Zahlenbasis).',
        'Geben Sie Ihren AES-Schlüssel (16, 24 oder 32 Bytes in Hex) ein.',
        'Optional einen Tweak-Wert für zusätzliche Sicherheit angeben.',
        'Klartext-Daten eingeben und Verschlüsseln klicken, um format-erhaltenden Chiffretext zu generieren.',
      ],
    },
    keyGenerator: {
      title: 'Sicherer Schlüsselgenerator Online - Zufalls AES/DES Schlüsselgenerator | HSM Kit',
      description: 'Kostenloser Online kryptografischer Schlüsselgenerator. Generieren Sie sichere Zufallsschlüssel für AES, DES, 3DES Verschlüsselung. Schlüsselkombination (XOR), Paritätsanpassung und Schlüsselvalidierungs-Tools enthalten. Kryptografisch sichere Zufallszahlengenerierung.',
      keywords: 'Schlüsselgenerator, Zufallsschlüssel, AES Schlüsselgenerator, DES Schlüsselgenerator, 3DES Schlüsselgenerator, kryptografischer Schlüssel, sicherer Zufall, Schlüsselkombination, XOR Schlüssel, sicherer Schlüsselgenerator, Zufallsschlüsselgenerator',
      faqTitle: 'Schlüsselgenerator FAQ',
      usageTitle: 'Schlüsselgenerator Anleitung',
      faqs: [
        { question: 'Wie werden die Zufallsschlüssel generiert?', answer: 'Schlüssel werden mit der Web Crypto API (crypto.getRandomValues) generiert, die kryptografisch sichere Zufallszahlen bereitstellt, die für Verschlüsselungsschlüssel geeignet sind.' },
        { question: 'Was ist Schlüsselkombination (XOR)?', answer: 'Schlüsselkombination ermöglicht es Ihnen, mehrere Schlüsselkomponenten zu XOR-en, um einen vollständigen Schlüssel zu bilden. Dies wird häufig bei Zeremonien verwendet, bei denen mehrere Verwahrer jeweils eine Komponente halten.' },
        { question: 'Was sind Paritätsbits?', answer: 'Bei DES/3DES-Schlüsseln hat jedes Byte ein Paritätsbit zur Fehlererkennung. Dieses Tool kann Paritätsbits automatisch auf ungerade Parität anpassen, wie vom DES-Standard gefordert.' },
        { question: 'Welche Schlüssellängen werden unterstützt?', answer: 'Der Generator unterstützt DES (8 Bytes/64 Bit), 2-Key 3DES (16 Bytes/128 Bit), 3-Key 3DES (24 Bytes/192 Bit) und AES-128/192/256.' },
      ],
      usage: [
        'Wählen Sie die gewünschte Schlüssellänge aus dem Dropdown.',
        'Klicken Sie auf "Generieren" um einen neuen Zufallsschlüssel zu erstellen.',
        'Verwenden Sie den Tab Schlüsselkombination um mehrere Komponenten zu XOR-en.',
        'Verwenden Sie den Tab Parität um DES/3DES Schlüssel-Paritätsbits anzupassen.',
        'Verwenden Sie den Tab Validierung um zu prüfen, ob ein Schlüssel korrektes Format und Parität hat.',
      ],
    },
    keyshare: {
      title: 'Keyshare Generator Online - Schlüssel in Komponenten aufteilen | HSM Kit',
      description: 'Kostenloser Online Keyshare Generator zum Aufteilen von kryptografischen Schlüsseln in mehrere Komponenten. Schlüssel eingeben, um automatisch 2-teilige oder 3-teilige Anteile mit KCV-Verifikation zu generieren. Unverzichtbar für Schlüsselzeremonien und Verwahrer-Verteilung. Sicherheitsmodus mit PIN-Schutz unterstützt.',
      keywords: 'Keyshare Generator, Schlüssel teilen, Schlüsselkomponenten, XOR Schlüssel, Schlüsselzeremonie, Schlüsselverwahrer, KCV Verifikation, DES Schlüsselanteil, AES Schlüsselanteil, Schlüsselverteilung, Schlüsselteilung, Schlüsselverwahrung',
      faqTitle: 'Keyshare Generator FAQ',
      usageTitle: 'So verwenden Sie den Keyshare Generator',
      faqs: [
        { question: 'Was ist Schlüsselteilung?', answer: 'Schlüsselteilung teilt einen kryptografischen Schlüssel mittels XOR-Operation in mehrere Komponenten (Anteile) auf. Alle Komponenten zusammen XOR-verknüpft rekonstruieren den ursprünglichen Schlüssel. Dies erhöht die Sicherheit durch verteilte Schlüsselverwahrung.' },
        { question: 'Was ist der Unterschied zwischen Insecure und Secure Modus?', answer: 'Im Insecure Modus werden generierte Schlüsselanteile direkt angezeigt. Im Secure Modus sind Anteile versteckt und durch eine 4-stellige PIN geschützt – Sie müssen die korrekte PIN eingeben, um jeden Anteil anzuzeigen.' },
        { question: 'Wie werden Schlüsselanteile generiert?', answer: 'Wenn Sie einen kombinierten Schlüssel eingeben, generiert das System zufällige Anteile wobei: Part1 ⊕ Part2 ⊕ Part3 = Kombinierter Schlüssel (3-Teil), oder Part1 ⊕ Part2 = Kombinierter Schlüssel (2-Teil).' },
        { question: 'Was ist KCV (Key Check Value)?', answer: 'KCV ist eine Prüfsumme, die durch Verschlüsselung von Nullen mit dem Schlüssel berechnet wird. Jeder Anteil und der kombinierte Schlüssel hat seinen eigenen KCV zur Verifikation ohne den tatsächlichen Schlüsselwert preiszugeben.' },
        { question: 'Was macht Force Odd Parität?', answer: 'Force Odd passt jedes Byte von DES/3DES Schlüsseln auf ungerade Parität (ungerade Anzahl von 1-Bits) an, wie vom DES-Standard für ordnungsgemäßen Betrieb erforderlich.' },
      ],
      usage: [
        'Geben Sie Ihren kryptografischen Schlüssel im Feld Kombinierter Schlüssel ein.',
        'Das System berechnet automatisch den KCV und generiert Schlüsselanteile.',
        '3-Teil Schlüssel: 3 Anteile, die zusammen XOR-verknüpft den kombinierten Schlüssel ergeben.',
        '2-Teil Schlüssel: 2 Anteile, die zusammen XOR-verknüpft den kombinierten Schlüssel ergeben.',
        'Im Secure Modus: Legen Sie für jeden Anteil eine 4-stellige PIN fest, dann klicken Sie auf Entsperren zum Anzeigen.',
      ],
    },
    tr31: {
      title: 'TR-31 Schlüsselblock Encoder/Decoder Online - ANSI X9.143 | HSM Kit',
      description: 'Kostenloser Online TR-31 Schlüsselblock Encoder und Decoder. Kryptografische Schlüssel nach ANSI X9.143 (TR-31) Standard mit KBPK-Schutz umhüllen/entpacken. Unterstützt Version A-E (TDES/AES), alle Schlüsselverwendungen, Algorithmen und Exportierbarkeitsoptionen. Ideal für Zahlungssicherheit.',
      keywords: 'TR-31, Schlüsselblock, ANSI X9.143, TR31 Encoder, TR31 Decoder, Schlüsselblock Wrapper, KBPK, Zahlungs-HSM, Schlüsselverwendung, Schlüssel-Exportierbarkeit, DUKPT, Schlüsselverwaltung, TDES Schlüsselumhüllung, AES Schlüsselumhüllung, Zahlungssicherheit, HSM-Schlüsselaustausch',
      faqTitle: 'TR-31 Schlüsselblock FAQ',
      usageTitle: 'TR-31 Schlüsselblock Tool Anleitung',
      faqs: [
        { question: 'Was ist TR-31?', answer: 'TR-31 (ANSI X9.143) ist der Branchenstandard für sicheren kryptografischen Schlüsselaustausch in Zahlungssystemen. Es umhüllt Verschlüsselungsschlüssel mit Metadaten (Schlüsselverwendung, Algorithmus, Verwendungsmodus, Exportierbarkeit), geschützt durch einen Key Block Protection Key (KBPK).' },
        { question: 'Welche TR-31 Versionen gibt es?', answer: 'Version A verwendet TDES-Variantenbindung, Version B verwendet TDES-Schlüsselableitung, Version C verwendet TDES-Variantenbindung (alternativ), Version D verwendet AES-Schlüsselableitung (sicherste, empfohlen), Version E verwendet AES mit CMAC-Bindung.' },
        { question: 'Was ist KBPK?', answer: 'KBPK (Key Block Protection Key) ist der Masterschlüssel, der zum Verschlüsseln/Entschlüsseln von TR-31 Schlüsselblöcken verwendet wird. Für TDES-Versionen (A/B/C) verwenden Sie einen 16- oder 24-Byte-Schlüssel. Für AES-Versionen (D/E) verwenden Sie einen 16-, 24- oder 32-Byte-AES-Schlüssel.' },
        { question: 'Was ist Schlüsselverwendung?', answer: 'Schlüsselverwendung (2 Zeichen) definiert den Zweck des umhüllten Schlüssels: B0/B1=BDK/DUKPT, C0=CVK, D0=Datenverschlüsselung, E0-E6=EMV Masterschlüssel, K0/K1=Schlüsselumhüllung, M0-M8=MAC-Schlüssel, P0/P1=PIN-Schlüssel, V0-V4=PIN-Verifizierung.' },
        { question: 'Was ist Verwendungsmodus?', answer: 'Verwendungsmodus definiert erlaubte Operationen: B=Verschlüsseln/Entschlüsseln, C=Generieren/Verifizieren, D=Nur Entschlüsseln, E=Nur Verschlüsseln, G=Nur Generieren, N=Keine Einschränkungen, X=Schlüsselableitung.' },
        { question: 'Was ist Exportierbarkeit?', answer: 'Exportierbarkeit steuert den Schlüsselexport: E=Exportierbar in vertrauenswürdigem Schlüsselblock, N=Nicht exportierbar, S=Sensitiv (eingeschränkter Export).' },
      ],
      usage: [
        'Kodieren: Geben Sie KBPK (3DES oder AES), Klartext-Schlüssel ein, wählen Sie Version, Schlüsselverwendung, Algorithmus, Verwendungsmodus, Exportierbarkeit und klicken Sie auf Kodieren.',
        'Der kodierte Schlüsselblock enthält Header-Metadaten + verschlüsselten Schlüssel + MAC für Integrität.',
        'Dekodieren: Geben Sie KBPK ein und fügen Sie die Schlüsselblockdaten ein, klicken Sie auf Dekodieren.',
        'Das Dekodierergebnis zeigt alle Header-Felder (Version, Länge, Schlüsselverwendung, Algorithmus, Verwendungsmodus, Schlüsselversion, Exportierbarkeit, Opt. Blöcke), verschlüsselte Daten, MAC, entschlüsselten Schlüssel und KCV.',
      ],
    },
    kcv: {
      title: 'KCV Rechner Online - Key Check Value Generator | HSM Kit',
      description: 'Kostenloser Online KCV (Key Check Value) Rechner für AES und DES/3DES Schlüssel. Verifizieren Sie die Korrektheit von Verschlüsselungsschlüsseln durch Berechnung des Prüfwerts. Unterstützt automatische Paritätsanpassung für DES-Schlüssel. Unverzichtbar für Zahlungssicherheit und Schlüsselverifizierung.',
      keywords: 'KCV Rechner, Key Check Value, KCV Generator, AES KCV, DES KCV, 3DES KCV, CMAC, Schlüsselverifizierung, Zahlungsschlüssel, Key Check Value Rechner, HSM-Schlüsselverifizierung',
      faqTitle: 'KCV Rechner FAQ',
      usageTitle: 'KCV Rechner Anleitung',
      faqs: [
        { question: 'Was ist KCV (Key Check Value)?', answer: 'KCV ist eine Prüfsumme, die verwendet wird um zu verifizieren, dass ein kryptografischer Schlüssel korrekt eingegeben oder übertragen wurde. Sie wird berechnet, indem ein Block aus Nullen verschlüsselt und die ersten 3 Bytes des Ergebnisses genommen werden.' },
        { question: 'Wie wird KCV für DES/3DES berechnet?', answer: 'Für DES/3DES: Verschlüsseln Sie 8 Bytes Nullen (0x0000000000000000) im ECB-Modus, dann nehmen Sie die ersten 6 Hex-Zeichen (3 Bytes) des Chiffretexts.' },
        { question: 'Wie wird KCV für AES berechnet?', answer: 'Für AES: Berechnen Sie CMAC über 16 Bytes Nullen mit dem Schlüssel, dann nehmen Sie die ersten 6 Hex-Zeichen (3 Bytes) des MAC-Werts.' },
        { question: 'Was ist automatische Paritätsanpassung?', answer: 'DES-Schlüssel erfordern ungerade Parität für jedes Byte. Wenn Ihr Schlüssel keine korrekte Parität hat, aktivieren Sie die automatische Anpassung, um sie vor der KCV-Berechnung zu korrigieren.' },
      ],
      usage: [
        'Wählen Sie den Algorithmus (AES oder DES/3DES).',
        'Geben Sie Ihren Verschlüsselungsschlüssel im Hexadezimalformat ein.',
        'Für DES-Schlüssel optional die automatische Paritätsanpassung aktivieren.',
        'Klicken Sie auf "KCV berechnen" um den Key Check Value zu generieren.',
        'Vergleichen Sie den KCV mit dem erwarteten Wert, um die Schlüsselkorrektheit zu verifizieren.',
      ],
    },
    pinBlock: {
      title: 'PIN Block Generator Online - ISO 9564 Format 0/1/3/4 | HSM Kit',
      description: 'Kostenloser Online PIN Block Generator mit Unterstützung für ISO 9564 Formate (Format 0, 1, 3, 4). Generieren Sie PIN Blocks für Zahlungstransaktionen, ATM und POS-Systeme. Essentielles Tool für Zahlungssicherheitstests. 100% clientseitig.',
      keywords: 'PIN Block, ISO 9564, PIN Block Format 0, PIN Block Format 4, Zahlungssicherheit, ATM PIN, POS PIN, PIN Verschlüsselung, Karten-PIN, PIN Block Generator, Zahlungskartensicherheit',
      faqTitle: 'PIN Block FAQ',
      usageTitle: 'PIN Block Generator Anleitung',
      faqs: [
        { question: 'Was ist ein PIN Block?', answer: 'Ein PIN Block ist ein standardisiertes Format zur Kodierung einer PIN (Personal Identification Number) vor der Verschlüsselung. Es kombiniert die PIN mit einem Füllmuster oder PAN-Daten, um einen Block fester Länge für die Verschlüsselung zu erstellen.' },
        { question: 'Was ist Format 0 (ISO 9564-1)?', answer: 'Format 0 XOR-t den PIN Block mit den rechtesten 12 Ziffern der PAN (ohne Prüfziffer). Es ist das am weitesten verbreitete Format in Zahlungssystemen.' },
        { question: 'Was ist Format 4 (ISO 9564-1:2017)?', answer: 'Format 4 ist das neueste Format, das für AES-Verschlüsselung konzipiert wurde. Es enthält zufälliges Padding und bietet bessere Sicherheit als ältere Formate.' },
        { question: 'Warum wird PAN für PIN Block benötigt?', answer: 'Bei Format 0 und einigen anderen wird die PAN mit den PIN-Daten XOR-t, wodurch die PIN an eine bestimmte Karte gebunden und bestimmte Angriffe verhindert werden.' },
      ],
      usage: [
        'Wählen Sie das PIN Block Format (0, 1, 3 oder 4).',
        'Geben Sie die PIN (4-12 Ziffern) ein.',
        'Für Formate, die PAN erfordern, geben Sie die Kartennummer ein.',
        'Klicken Sie auf "Generieren" um den PIN Block zu erstellen.',
        'Verwenden Sie den generierten Hex-String als Eingabe für Ihren Verschlüsselungsprozess.',
      ],
    },
    pinBlockGeneral: {
      title: 'PIN-Block Encoder/Decoder - ISO 9564 Formate 0-4 | HSM Kit',
      description: 'Kostenloser Online-PIN-Block-Encoder und -Decoder. Unterstützt alle ISO 9564-Formate (0, 1, 2, 3, 4). Kodieren Sie PINs in PIN-Blöcke oder dekodieren Sie PIN-Blöcke zurück in PINs. 100% clientseitige Verarbeitung.',
      keywords: 'PIN-Block-Encoder, PIN-Block-Decoder, ISO 9564, PIN-Block-Format 0, PIN-Block-Format 1, PIN-Block-Format 2, PIN-Verschlüsselung, Zahlungssicherheit, HSM-Tests, Karten-PIN',
      faqTitle: 'PIN-Block Encoder/Decoder FAQ',
      usageTitle: 'So verwenden Sie das PIN-Block-Tool',
      faqs: [
        { question: 'Was sind die Unterschiede zwischen PIN-Block-Formaten?', answer: 'Format 0: XOR mit PAN (am häufigsten). Format 1: Zufälliges Padding, kein PAN erforderlich. Format 2: Ähnlich wie Format 0 mit unterschiedlichem Steuerfeld. Format 3: Zufälliges Padding mit PAN. Format 4: Für AES entwickelt, 128-Bit-Blockgröße.' },
        { question: 'Wann sollte ich Format 0 statt Format 1 verwenden?', answer: 'Format 0 wird am häufigsten bei Kartenzahlungen verwendet, da es die PIN an eine bestimmte Karte (PAN) bindet. Format 1 wird verwendet, wenn PAN nicht verfügbar ist oder für universelle PIN-Übertragung, bei der keine Kartenbindung erforderlich ist.' },
        { question: 'Kann ich einen PIN-Block ohne PAN dekodieren?', answer: 'Nur Format 1 kann ohne PAN dekodiert werden, da es zufälliges Padding anstelle von XOR mit PAN-Daten verwendet. Formate 0, 2, 3 und 4 benötigen die PAN, um die XOR-Operation umzukehren und die PIN wiederherzustellen.' },
        { question: 'Wofür wird Format 4 verwendet?', answer: 'Format 4 ist das neueste Format (ISO 9564-1:2017), das speziell für AES-Verschlüsselung entwickelt wurde. Es verwendet eine 128-Bit-Blockgröße (32 Hex-Zeichen) und enthält zufälliges Padding für erhöhte Sicherheit. Es wird zunehmend in modernen Zahlungssystemen eingesetzt.' },
        { question: 'Wofür wird das Padding-Zeichen verwendet?', answer: 'Das Padding-Zeichen (typischerweise "F") füllt ungenutzte Positionen im PIN-Block nach den PIN-Ziffern. Dies erzeugt einen Block fester Länge, der für die Verschlüsselung geeignet ist. Verschiedene Systeme können unterschiedliche Padding-Zeichen verwenden.' },
      ],
      usage: [
        'Wählen Sie das gewünschte PIN-Block-Format (0, 1, 2, 3 oder 4).',
        'Wählen Sie "Kodieren", um eine PIN in einen PIN-Block umzuwandeln, oder "Dekodieren", um eine PIN aus einem PIN-Block zu extrahieren.',
        'Für Kodierung: Geben Sie PIN (4-12 Ziffern), PAN (Kartennummer) ein und ändern Sie optional das Padding-Zeichen.',
        'Für Dekodierung: Geben Sie PIN-Block (Hex) und PAN (falls vom Format benötigt) ein.',
        'Klicken Sie auf die Schaltfläche Kodieren oder Dekodieren zum Verarbeiten.',
        'Das Ergebnis zeigt den PIN-Block (für Kodierung) oder die dekodierte PIN (für Dekodierung).',
      ],
    },
    pinBlockAes: {
      title: 'AES PIN-Block Format 4 - ISO 9564-1:2017 Verschlüsselung/Entschlüsselung | HSM Kit',
      description: 'Kostenloses Online-AES-PIN-Block-Tool. Verschlüsseln und entschlüsseln Sie PINs mit dem ISO 9564-1:2017 Format 4 Standard. Unterstützt AES-128 ECB-Modus. Zeigt Zwischenschritte für optimales Lernen. 100% clientseitige Verarbeitung.',
      keywords: 'AES PIN-Block, Format 4, ISO 9564-1, AES-128, PIN-Verschlüsselung, PIN-Entschlüsselung, ECB-Modus, Zahlungssicherheit, HSM, verschlüsselter PIN-Block',
      faqTitle: 'AES PIN-Block FAQ',
      usageTitle: 'So verwenden Sie das AES PIN-Block-Tool',
      faqs: [
        { question: 'Was ist PIN-Block Format 4?', answer: 'Format 4 ist ein in ISO 9564-1:2017 definiertes PIN-Block-Format, das speziell für AES-Verschlüsselung entwickelt wurde. Es verwendet eine 128-Bit (16-Byte) Blockgröße und bietet stärkere Sicherheit als ältere Formate. Der PIN-Block wird vor der AES-Verschlüsselung mit dem PAN-Block XOR-verknüpft.' },
        { question: 'Was ist der Unterschied zwischen Format 4 und Format 0?', answer: 'Format 0 verwendet 64-Bit (8-Byte) Blöcke für DES/3DES-Verschlüsselung. Format 4 verwendet 128-Bit (16-Byte) Blöcke für AES-Verschlüsselung. Format 4 bietet verbesserte Sicherheit durch längere Blockgröße und zufälliges Padding.' },
        { question: 'Welcher Verschlüsselungsalgorithmus wird verwendet?', answer: 'Dieses Tool verwendet AES-128-Verschlüsselung im ECB (Electronic Codebook) Modus. Der Schlüssel muss 16 Bytes (32 Hex-Zeichen) lang sein. AES-192 und AES-256 werden auch von ISO 9564-1:2017 unterstützt, aber AES-128 ist am gebräuchlichsten.' },
        { question: 'Kann ich AES-192 oder AES-256 verwenden?', answer: 'Dieses Tool unterstützt derzeit AES-128 (16-Byte-Schlüssel). AES-192 benötigt einen 24-Byte-Schlüssel und AES-256 einen 32-Byte-Schlüssel. Die Implementierung kann erweitert werden, um verschiedene AES-Varianten zu unterstützen.' },
        { question: 'Warum werden Zwischenschritte angezeigt?', answer: 'Zwischenschritte helfen beim Verständnis des Verschlüsselungsprozesses: Klarer PIN-Block (vor Verschlüsselung) → PAN-Block → XOR-Ergebnis (AES-Eingabe) → Verschlüsselungsergebnis. Dies ist nützlich zum Lernen, Debuggen und Verstehen der HSM-Funktionsweise.' },
      ],
      usage: [
        'Wählen Sie den Betriebsmodus: Verschlüsseln (PIN-Block aus PIN erstellen) oder Entschlüsseln (PIN aus PIN-Block extrahieren).',
        'Geben Sie den AES-128-Schlüssel ein (32 Hex-Zeichen, 16 Bytes).',
        'Geben Sie die PAN (Kartennummer) ein (13-19 Ziffern).',
        'Im Verschlüsselungsmodus: Geben Sie die PIN (4-12 Ziffern) ein. Im Entschlüsselungsmodus: Geben Sie den verschlüsselten Block (32 Hex-Zeichen) ein.',
        'Klicken Sie auf die Schaltfläche Verschlüsseln oder Entschlüsseln zum Verarbeiten.',
        'Das Ergebnis zeigt den verschlüsselten Block (für Verschlüsselung) oder die extrahierte PIN (für Entschlüsselung).',
        'Optional aktivieren Sie "Zwischenschritte anzeigen" für eine detaillierte Aufschlüsselung des Verschlüsselungsprozesses.',
      ],
    },
    pinOffset: {
      title: 'PIN-Offset-Rechner - IBM 3624 Methode Online | HSM Kit',
      description: 'Kostenloser Online-PIN-Offset-Rechner mit IBM 3624-Methode. PIN-Offset aus Kunden-PIN berechnen oder PIN mit Offset verifizieren. Unterstützt 3DES-Verschlüsselung mit PDK, Dezimalisierungstabelle und flexible Validierungsdatenmethoden. Unverzichtbares Tool für PIN-Management.',
      keywords: 'PIN-Offset, IBM 3624, PIN-Offset-Rechner, natürliche PIN, Dezimalisierungstabelle, PDK, PIN-Ableitungsschlüssel, PIN-Verifizierung, Kunden-PIN, Validierungsdaten, 3DES-Verschlüsselung, PIN-Management',
      faqTitle: 'PIN-Offset FAQ',
      usageTitle: 'So verwenden Sie das PIN-Offset-Tool',
      faqs: [
        { question: 'Was ist PIN-Offset?', answer: 'PIN-Offset ist die Differenz zwischen der vom Kunden gewählten PIN und der aus den Kartendaten berechneten "natürlichen PIN". Dies ermöglicht dem Aussteller, kundengewählte PINs zu unterstützen und gleichzeitig eine kryptografische Verifizierungsmethode beizubehalten. Der Offset wird als (Kunden-PIN - Natürliche PIN) mod 10 berechnet.' },
        { question: 'Was ist die IBM 3624-Methode?', answer: 'IBM 3624 ist eine weit verbreitete Methode zur PIN-Generierung und -Verifizierung. Sie verschlüsselt die PAN mit einem PIN-Ableitungsschlüssel (PDK) mit 3DES, wendet eine Dezimalisierungstabelle an, um Hex in Ziffern umzuwandeln, extrahiert Validierungsdaten und berechnet den Offset oder verifiziert die PIN.' },
        { question: 'Was ist eine Dezimalisierungstabelle (DecTab)?', answer: 'Eine Dezimalisierungstabelle (DecTab) ist eine 16-stellige Nachschlagetabelle zur Konvertierung hexadezimaler Ziffern (0-F) in Dezimalziffern (0-9). Der Standard ist "0123456789012345", kann aber angepasst werden. Jede Hex-Ziffer wird durch die entsprechende Position in der Tabelle ersetzt.' },
        { question: 'Was ist der Unterschied zwischen Validierungsdatenparametern und Maske?', answer: 'Validierungsdatenparameter (Start, Länge, Auffüllung, PIN-Länge) extrahieren einen Teilstring fester Länge aus der natürlichen PIN. Die Validierungsdatenmaske ermöglicht flexiblere Extraktion mit einem Muster, bei dem "N" natürliche PIN-Ziffern darstellt und 0-9 feste Werte sind (z.B. "0000000N0000").' },
        { question: 'Wie verifiziere ich eine PIN mit einem Offset?', answer: 'Verwenden Sie den PIN-Tab: Geben Sie PDK, PAN, PIN-Offset und Validierungsparameter ein. Das Tool berechnet die natürliche PIN, extrahiert Validierungsdaten und addiert den Offset, um die Kunden-PIN zu erhalten: (Validierungsdaten + Offset) mod 10.' },
      ],
      usage: [
        'Verwenden Sie den "Offset"-Tab zur Berechnung des PIN-Offsets aus einer Kunden-PIN oder den "PIN"-Tab zur Verifizierung/Berechnung der PIN aus dem Offset.',
        'Geben Sie den PDK (PIN-Ableitungsschlüssel) ein - 32 Hex-Zeichen (16 Bytes) 3DES-Schlüssel.',
        'Geben Sie die PAN (Primäre Kontonummer) ein - 12-19 Ziffern.',
        'Geben Sie die Dezimalisierungstabelle (DecTab) ein - 16 Ziffern, Standard: 0123456789012345.',
        'Wählen Sie die Validierungsdatenmethode: Parameter (Start, Länge, Auffüllung, PIN-Länge) oder Maskenmuster.',
        'Für Offset-Tab: Geben Sie Kunden-PIN ein und klicken Sie auf "Offset berechnen".',
        'Für PIN-Tab: Geben Sie PIN-Offset ein und klicken Sie auf "PIN berechnen", um die Kunden-PIN zu erhalten.',
      ],
    },
    pinPvv: {
      title: 'PIN PVV-Rechner - Visa PIN Verification Value Online | HSM Kit',
      description: 'Kostenloser Online-PIN-PVV (PIN Verification Value) Rechner mit Visa-Standardalgorithmus. PVV aus Kunden-PIN berechnen oder PIN mit PVV verifizieren. Unterstützt 3DES-Verschlüsselung mit PDK, PVKI-Auswahl und Dezimalisierung. Unverzichtbares Tool für Kartenzahlungssicherheit.',
      keywords: 'PIN PVV, PIN Verification Value, Visa PVV, PVV-Rechner, PDK, PVKI, PIN-Verifizierung, Kartensicherheit, Zahlungssicherheit, 3DES-Verschlüsselung, Dezimalisierung, TSP, PIN-Ableitung',
      faqTitle: 'PIN PVV FAQ',
      usageTitle: 'So verwenden Sie das PIN PVV-Tool',
      faqs: [
        { question: 'Was ist PIN PVV?', answer: 'PIN Verification Value (PVV) ist ein Visa-Standard für PIN-Verifizierung. Es ist ein 4-stelliger Wert, der aus der Kunden-PIN, Kartennummer (PAN) und einem geheimen PIN-Ableitungsschlüssel (PDK) mit 3DES-Verschlüsselung und Dezimalisierung berechnet wird. Banken verwenden PVV zur Verifizierung von Kunden-PINs ohne Speicherung der tatsächlichen PIN.' },
        { question: 'Wie wird PVV berechnet?', answer: 'PVV-Berechnung: 1) Verschlüsseln Sie die PAN (rechtsbündig, nullaufgefüllt) mit dem PDK mit 3DES ECB. 2) Wenden Sie die Dezimalisierungstabelle an, um Hex in Ziffern zu konvertieren (0-9 bleiben, A-F werden auf 0-5 abgebildet). 3) Extrahieren Sie 4 Ziffern ab Position PVKI (Transformed Selection Process - TSP). 4) Berechnen Sie PVV durch stellenweises Addieren von PIN und TSP modulo 10.' },
        { question: 'Was ist PVKI?', answer: 'PVKI (PIN Verification Key Index) ist ein Wert von 0-9, der bestimmt, an welcher Position in der verschlüsselten PAN mit der Extraktion von Ziffern für TSP begonnen wird. Verschiedene Karten können verschiedene PVKI-Werte verwenden, um dem Verifizierungsprozess Variation hinzuzufügen. Der PVKI wird typischerweise mit dem Kartenkonto gespeichert.' },
        { question: 'Was ist TSP bei der PVV-Berechnung?', answer: 'TSP (Transformed Selection Process) ist ein 4-stelliger Wert, der aus der dezimalisierten verschlüsselten PAN extrahiert wird, beginnend an der von PVKI angegebenen Position. Er wird mit der Kunden-PIN kombiniert, um den PVV zu erzeugen. Der TSP fungiert als kryptografisches Salt, das pro Karte variiert.' },
        { question: 'Wie verifiziere ich eine PIN mit PVV?', answer: 'Verwenden Sie den PIN-Tab: Geben Sie PDK, PAN, PVV (gespeicherter Wert) und PVKI ein. Das Tool berechnet die natürliche PIN, indem es die PAN verschlüsselt, TSP extrahiert und die PVV-Formel umkehrt: PIN = (PVV - TSP) mod 10. Vergleichen Sie das Ergebnis mit der vom Kunden eingegebenen PIN zur Verifizierung.' },
      ],
      usage: [
        'Verwenden Sie den "PVV"-Tab zur Berechnung des PVV aus einer Kunden-PIN oder den "PIN"-Tab zur Verifizierung/Berechnung der PIN aus einem bekannten PVV.',
        'Geben Sie den PDK (PIN-Ableitungsschlüssel) ein - 32 Hex-Zeichen (16 Bytes) 3DES-Schlüssel.',
        'Geben Sie die PAN (Primäre Kontonummer) ein - 12-19 Ziffern.',
        'Für PVV-Tab: Geben Sie Kunden-PIN (4-12 Ziffern) und PVKI (0-9) ein und klicken Sie auf PVV berechnen.',
        'Für PIN-Tab: Geben Sie PVV (4 Ziffern) und PVKI (0-9) ein und klicken Sie auf PIN berechnen.',
        'Das Ergebnis zeigt den berechneten Wert zusammen mit Zwischenwerten (Verschlüsselte PAN und TSP) zur Verifizierung.',
      ],
    },
    visaCertificates: {
      title: 'VISA Zertifikat-Validator - Aussteller-Signieranfrage & Signierte Öffentliche Schlüsseldaten Validieren | HSM Kit',
      description: 'Kostenloser Online VISA Zertifikat-Validator. Validieren Sie VISA Aussteller-Zertifikats-Signieranfragen und verifizieren Sie signierte Aussteller-öffentliche Schlüsseldaten mit CA-öffentlichen Schlüsseln. Unterstützt VSDC CA V92, V94 und benutzerdefinierte CA-Schlüssel. Unverzichtbares Tool für Zahlungskarten-Zertifikatsverwaltung und EMV-Zertifizierung.',
      keywords: 'VISA Zertifikate, Aussteller-Signieranfrage, Zertifikatsvalidierung, CA öffentlicher Schlüssel, signiertes Zertifikat, EMV Zertifikate, Zahlungskarten-Sicherheit, VISA CA, Aussteller öffentlicher Schlüssel, Zertifikatssignierung, VSDC CA, EMV-Zertifizierung',
      faqTitle: 'VISA Zertifikate FAQ',
      usageTitle: 'So verwenden Sie das VISA Zertifikate Tool',
      faqs: [
        { question: 'Was ist ein VISA Aussteller-Zertifikat?', answer: 'Ein VISA Aussteller-Zertifikat ist ein digitales Zertifikat von VISA, das den öffentlichen Schlüssel des Ausstellers enthält. Es wird in EMV-Chipkarten-Transaktionen verwendet, um den Kartenaussteller zu authentifizieren und eine Vertrauenskette vom Zahlungssystem zur Karte zu etablieren.' },
        { question: 'Was ist eine Aussteller-Signieranfrage?', answer: 'Eine Aussteller-Signieranfrage (CSR) ist eine Anfrage an die VISA CA, um den öffentlichen Schlüssel des Ausstellers zu signieren. Sie enthält den öffentlichen Schlüssel-Modulus, Exponenten und andere Zertifikatsinformationen, die von VISA zertifiziert werden müssen, bevor sie in der Produktion verwendet werden können.' },
        { question: 'Wie validiere ich ein signiertes Zertifikat?', answer: 'Um ein signiertes Zertifikat zu validieren, benötigen Sie die signierten Aussteller-öffentlichen Schlüsseldaten und den entsprechenden VISA CA öffentlichen Schlüssel. Dieses Tool verifiziert die RSA-Signatur, um sicherzustellen, dass das Zertifikat authentisch ist, nicht manipuliert wurde und tatsächlich von VISA signiert wurde.' },
        { question: 'Welche CA öffentlichen Schlüssel werden unterstützt?', answer: 'Dieses Tool enthält vordefinierte VISA CA öffentliche Schlüssel für VSDC CA V92 und V94 (häufig in EMV-Zertifizierungen verwendet). Sie können auch benutzerdefinierte CA öffentliche Schlüssel laden, wenn Sie Zertifikate verifizieren müssen, die von anderen VISA CA-Versionen oder Test-CAs signiert wurden.' },
        { question: 'Warum ist Zertifikatsvalidierung wichtig?', answer: 'Die Zertifikatsvalidierung stellt sicher, dass Aussteller-öffentliche Schlüssel ordnungsgemäß von VISA zertifiziert wurden und nicht verändert wurden. Dies erhält die Sicherheitskette in EMV-Transaktionen aufrecht und verhindert, dass betrügerische Karten von Terminals akzeptiert werden.' },
      ],
      usage: [
        'Verwenden Sie die Registerkarte "Aussteller-Signieranfrage validieren", um Zertifikatsanfragen zu prüfen, bevor Sie sie zur Signierung an die VISA CA senden.',
        'Laden Sie die Zertifikatsanfrage-Datei oder fügen Sie Hex-Daten ein und klicken Sie auf Validieren, um Struktur und Format zu überprüfen.',
        'Verwenden Sie die Registerkarte "Signierte Aussteller-öffentliche Schlüsseldaten validieren", um von der VISA CA erhaltene Zertifikate zu verifizieren.',
        'Laden oder fügen Sie die signierten Zertifikatsdaten ein, wählen Sie einen vordefinierten CA-Schlüssel (VSDC CA V92/V94) oder laden Sie einen benutzerdefinierten CA öffentlichen Schlüssel.',
        'Klicken Sie auf Validieren, um die Signatur mit RSA-Verifizierung unter Verwendung des ausgewählten CA öffentlichen Schlüssels zu überprüfen.',
        'Aktivieren Sie den Debug-Modus, um detaillierte Informationen zur Zertifikatsstruktur, Modulus, Exponenten und Validierungsschritten anzuzeigen.',
      ],
    },
    hash: {
      title: 'Hash-Rechner Online - MD5, SHA-256, SHA-512, BLAKE2 | HSM Kit',
      description: 'Kostenloser Online-Hash-Rechner mit Unterstützung für MD5, SHA-1, SHA-256, SHA-512, RIPEMD-160, WHIRLPOOL, BLAKE2, CRC32 und mehr. Hash-Werte aus Text oder Hex-Eingabe berechnen. Unterstützt über 20 Hash-Algorithmen. Alle Berechnungen werden im Browser durchgeführt.',
      keywords: 'Hash-Rechner, MD5-Hash, SHA-256-Hash, SHA-512-Hash, BLAKE2, RIPEMD-160, WHIRLPOOL, CRC32, Hash-Generator, Prüfsummenrechner, Nachrichtendigest, kryptografischer Hash',
      faqTitle: 'Hash-Rechner FAQ',
      usageTitle: 'Hash-Rechner Anleitung',
      faqs: [
        { question: 'Was ist eine Hash-Funktion?', answer: 'Eine Hash-Funktion ist ein mathematischer Algorithmus, der Eingabedaten beliebiger Größe in eine Ausgabe fester Größe (Hash-Wert) umwandelt.' },
        { question: 'Welchen Hash-Algorithmus sollte ich verwenden?', answer: 'Für Sicherheitszwecke verwenden Sie SHA-256 oder SHA-512. MD5 und SHA-1 gelten als unsicher für kryptografische Zwecke.' },
        { question: 'Was ist der Unterschied zwischen MD5 und SHA-256?', answer: 'MD5 erzeugt einen 128-Bit-Hash und ist schnell, aber kryptografisch gebrochen. SHA-256 erzeugt einen 256-Bit-Hash und ist derzeit kryptografisch sicher. Verwenden Sie SHA-256 für sicherheitskritische Anwendungen.' },
        { question: 'Kann ein Hash entschlüsselt werden?', answer: 'Nein, Hash-Funktionen sind konstruktionsbedingt Einwegfunktionen. Die ursprüngliche Eingabe kann nicht aus dem Hash wiederhergestellt werden. Diese Eigenschaft macht sie nützlich für Passwortspeicherung und Datenintegritätsprüfung.' },
      ],
      usage: ['Eingabetyp wählen', 'Algorithmus wählen', 'Daten eingeben', 'Berechnen klicken'],
    },
    encoding: {
      title: 'Zeichencodierung Konverter Online - ASCII, EBCDIC, Hex | HSM Kit',
      description: 'Kostenloser Online-Zeichencodierung-Konverter. Konvertierung zwischen ASCII, EBCDIC, Hexadezimal, Binär und ATM-Dezimal. Unverzichtbar für Zahlungssystementwicklung und Mainframe-Integration. 100% clientseitige Konvertierung.',
      keywords: 'Zeichencodierung, ASCII EBCDIC Konverter, Hex-Konverter, Binär-Konverter, EBCDIC-Konverter, ATM-Dezimal, Codierungskonvertierung, Zahlungssystemcodierung, Bankcodierung',
      faqTitle: 'Zeichencodierung FAQ',
      usageTitle: 'Codierung-Konverter Anleitung',
      faqs: [
        { question: 'Was ist Zeichencodierung?', answer: 'Zeichencodierung ist ein System, das jedes Zeichen mit einer eindeutigen Nummer oder Bytesequenz verbindet.' },
        { question: 'Was ist EBCDIC?', answer: 'EBCDIC ist eine 8-Bit-Zeichencodierung, die hauptsächlich auf IBM-Mainframes verwendet wird.' },
        { question: 'Warum brauche ich ASCII-EBCDIC-Konvertierung?', answer: 'Viele Legacy-Bank- und Finanzsysteme laufen auf IBM-Mainframes mit EBCDIC. Bei der Integration moderner Systeme (ASCII/UTF-8) mit diesen Mainframes ist die Zeichenkonvertierung unverzichtbar.' },
        { question: 'Was ist ATM-Dezimalcodierung?', answer: 'ATM-Dezimal ist eine spezifische Codierung in der ATM-Kommunikation, bei der jede Ziffer (0-9) durch ihren ASCII-Code dargestellt wird. Sie wird häufig in Finanznachrichtenprotokollen verwendet.' },
      ],
      usage: ['Konvertierungstyp wählen', 'Daten eingeben', 'Konvertieren klicken'],
    },
    bcd: {
      title: 'BCD Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-BCD-Encoder und -Decoder. Dezimalzahlen in BCD oder BCD zurück in Dezimal konvertieren. Wird in Finanz- und Embedded-Systemen verwendet. Ideal für Zahlungsterminal-Integration.',
      keywords: 'BCD-Encoder, BCD-Decoder, Binär codierte Dezimalzahl, Dezimal-BCD-Konvertierung, Finanzcodierung, Zahlungssystemcodierung',
      faqTitle: 'BCD FAQ',
      usageTitle: 'BCD-Tool Anleitung',
      faqs: [
        { question: 'Was ist BCD?', answer: 'Binär codierte Dezimalzahl (BCD) ist eine Codierung, bei der jede Dezimalziffer durch 4 Bits dargestellt wird.' },
        { question: 'Warum wird BCD verwendet?', answer: 'BCD wird in Finanzanwendungen verwendet, wo genaue Dezimaldarstellung wichtig ist.' },
        { question: 'Was ist der Unterschied zwischen gepacktem und ungepacktem BCD?', answer: 'Gepacktes BCD speichert zwei Dezimalziffern pro Byte (je 4 Bits). Ungepacktes BCD verwendet ein ganzes Byte für jede Ziffer. Gepacktes BCD ist speichereffizienter.' },
        { question: 'Wo wird BCD üblicherweise verwendet?', answer: 'BCD wird häufig in Finanzsystemen, Taschenrechnern, Digitaluhren und Anwendungen verwendet, bei denen Dezimalpräzision wichtig ist. Zahlungsterminals und Geldautomaten verwenden oft BCD für Beträge.' },
      ],
      usage: ['Codieren oder Decodieren wählen', 'Daten eingeben', 'Schaltfläche klicken'],
    },
    checkDigits: {
      title: 'Prüfziffer-Rechner Online - Luhn MOD 10, MOD 9 | HSM Kit',
      description: 'Kostenloser Online-Prüfziffer-Rechner und -Validator. Prüfziffern mit Luhn (MOD 10) und MOD 9 generieren oder verifizieren. Validiert Kreditkartennummern, IMEI und andere Identifikatoren. Unverzichtbar für Zahlungsvalidierung.',
      keywords: 'Prüfziffer-Rechner, Luhn-Algorithmus, MOD 10, MOD 9, Kreditkartenvalidierung, IMEI-Prüfung, Prüfsummenrechner, Luhn-Prüfung, Kartennummernvalidierung, Identifikatorvalidierung',
      faqTitle: 'Prüfziffer FAQ',
      usageTitle: 'Prüfziffer-Rechner Anleitung',
      faqs: [
        { question: 'Was ist eine Prüfziffer?', answer: 'Eine Prüfziffer ist eine Ziffer, die zur Fehlererkennung an eine Nummer angehängt wird.' },
        { question: 'Was ist der Luhn-Algorithmus?', answer: 'Der Luhn-Algorithmus (MOD 10) ist eine Prüfsummenformel zur Validierung von Kreditkartennummern usw.' },
        { question: 'Welche Nummern verwenden den Luhn-Algorithmus?', answer: 'Kreditkartennummern (Visa, MasterCard, Amex), IMEI-Nummern, NPI (Gesundheitsanbieter-Identifikator), kanadische Sozialversicherungsnummern und viele andere Identifikationsnummern verwenden Luhn-Validierung.' },
        { question: 'Was ist der Amex SE MOD 9 Algorithmus?', answer: 'Der Amex SE (Service Establishment) MOD 9 Algorithmus wird von American Express zur Validierung von Händler-/Servicenummern verwendet. Er verwendet eine andere Berechnungsmethode als Luhn.' },
      ],
      usage: ['Algorithmus wählen', 'Verifizieren oder Generieren wählen', 'Nummer eingeben'],
    },
    base64: {
      title: 'Base64 Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-Base64-Encoder und -Decoder. Text in Base64 oder Base64 in Text konvertieren. Unverzichtbar für Webanwendungsdaten-Codierung. Schnelle und sichere Browser-Verarbeitung.',
      keywords: 'Base64-Encoder, Base64-Decoder, Base64-Konvertierung, Binär-Text-Konvertierung, Base64-Konverter, MIME-Codierung',
      faqTitle: 'Base64 FAQ',
      usageTitle: 'Base64-Tool Anleitung',
      faqs: [
        { question: 'Was ist Base64?', answer: 'Base64 ist eine Codierung, die Binärdaten in ASCII-Strings mit 64 Zeichen umwandelt.' },
        { question: 'Warum Base64 verwenden?', answer: 'Base64 wird verwendet, um Binärdaten in textbasierten Protokollen zu übertragen.' },
        { question: 'Bietet Base64 Verschlüsselung?', answer: 'Nein, Base64 ist ein Codierungsschema, keine Verschlüsselung. Jeder kann Base64-Daten decodieren. Es dient der Datenrepräsentation, nicht der Sicherheit.' },
        { question: 'Warum erhöht Base64 die Datengröße?', answer: 'Base64 kodiert 3 Bytes Binärdaten in 4 ASCII-Zeichen, was zu einer Größenerhöhung von etwa 33% führt. Wenn die Eingabelänge nicht durch 3 teilbar ist, werden Füllzeichen "=" verwendet.' },
      ],
      usage: ['Codieren oder Decodieren wählen', 'Daten eingeben', 'Schaltfläche klicken'],
    },
    base94: {
      title: 'Base94 Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-Base94-Encoder und -Decoder. Kompakte Codierung mit allen 94 druckbaren ASCII-Zeichen. Etwa 20% kompakter als Base64. Nützlich für effiziente Datenspeicherung und -übertragung.',
      keywords: 'Base94-Encoder, Base94-Decoder, Kompakte Codierung, effiziente Codierung, URL-sichere Codierung',
      faqTitle: 'Base94 FAQ',
      usageTitle: 'Base94-Tool Anleitung',
      faqs: [
        { question: 'Was ist Base94?', answer: 'Base94 ist eine Codierung mit 94 druckbaren ASCII-Zeichen, effizienter als Base64.' },
        { question: 'Warum Base94 verwenden?', answer: 'Base94 bietet etwa 20% kompaktere Codierung als Base64.' },
        { question: 'Welche Zeichen verwendet Base94?', answer: 'Base94 verwendet alle 94 druckbaren ASCII-Zeichen von ! (0x21) bis ~ (0x7E), ausgenommen Leerzeichen. Dies umfasst Buchstaben, Ziffern und alle Standard-Satzzeichen.' },
        { question: 'Wann sollte ich Base94 verwenden?', answer: 'Verwenden Sie Base94, wenn Sie eine kompakte Textdarstellung von Binärdaten benötigen und Ihr Übertragungs-/Speichersystem alle druckbaren ASCII-Zeichen unterstützt. Ideal für URLs, QR-Codes oder Speicheroptimierung.' },
      ],
      usage: ['Codieren oder Decodieren wählen', 'Daten eingeben', 'Schaltfläche klicken'],
    },
    messageParser: {
      title: 'Nachrichtenparser Online - ATM NDC, Wincor, ISO 8583 | HSM Kit',
      description: 'Kostenloser Online-ATM- und Finanznachrichtenparser. ATM NDC, Wincor, ISO 8583 Nachrichtenformate analysieren. Unverzichtbar für Zahlungssystementwicklung und -debugging. Alle Parsing-Vorgänge werden im Browser durchgeführt.',
      keywords: 'Nachrichtenparser, ATM NDC, ATM Wincor, ISO 8583, Finanznachricht, Transaktionsparser, Hex-Parser, ATM-Nachrichtendecoder, Zahlungsnachrichtenparser, Finanztransaktionsparser',
      faqTitle: 'Nachrichtenparser FAQ',
      usageTitle: 'Nachrichtenparser Anleitung',
      faqs: [
        { question: 'Was ist ATM NDC?', answer: 'NDC (NCR Direct Connect) ist ein Protokoll, das NCR-Geldautomaten zur Kommunikation mit Hostsystemen verwenden.' },
        { question: 'Was ist ISO 8583?', answer: 'ISO 8583 ist ein internationaler Standard für Finanztransaktionsnachrichten.' },
        { question: 'Was ist das Wincor/Nixdorf-Protokoll?', answer: 'Das Wincor Nixdorf (jetzt Diebold Nixdorf) Protokoll ist ein proprietäres ATM-Kommunikationsprotokoll, ähnlich wie NDC, aber mit herstellerspezifischen Variationen. Es wird in europäischen und asiatischen Märkten weit verbreitet.' },
        { question: 'Wie identifiziere ich das Nachrichtenformat?', answer: 'NDC-Nachrichten beginnen typischerweise mit bestimmten Nachrichtenklassen-Identifikatoren. ISO 8583-Nachrichten beginnen mit einem 4-stelligen MTI (Message Type Indicator). Die Hex-Dump-Struktur hilft bei der Identifizierung des verwendeten Protokolls.' },
      ],
      usage: ['Nachrichtenformat wählen', 'Hex-Daten eingeben', 'Analysieren klicken'],
    },
    rsaDer: {
      title: 'RSA DER Öffentlicher Schlüssel Encoder/Decoder Online | HSM Kit',
      description: 'Kostenloser Online-RSA-DER-Öffentlicher-Schlüssel-Encoder und -Decoder. Zwischen Modulus/Exponent und DER ASN.1 Format konvertieren. Unterstützt PEM-Ausgabe und verschiedene Eingabe-Codierungen (ASCII Hex, Base64, EBCDIC). 100% Browser-Verarbeitung.',
      keywords: 'RSA DER, RSA öffentlicher Schlüssel, DER-Codierung, ASN.1, PEM-Format, Modulus, Exponent, RSA-Schlüsselkonverter, öffentlicher Schlüsselencoder, RSA-Schlüsselparser, Zertifikatschlüsselextraktor',
      faqTitle: 'RSA DER Öffentlicher Schlüssel FAQ',
      usageTitle: 'RSA DER Tool Anleitung',
      faqs: [
        { question: 'Was ist DER-Codierung?', answer: 'DER (Distinguished Encoding Rules) ist ein Binärformat zur Codierung von ASN.1-Datenstrukturen.' },
        { question: 'Was ist PEM-Format?', answer: 'PEM ist eine Base64-codierte Version von DER mit Header-/Footer-Zeilen.' },
        { question: 'Was sind Modulus und Exponent in RSA?', answer: 'Der Modulus (n) ist das Produkt zweier großer Primzahlen und bestimmt die Schlüsselgröße. Der öffentliche Exponent (e) ist typischerweise 65537 (0x10001). Zusammen bilden sie den öffentlichen Schlüssel.' },
        { question: 'Wie extrahiere ich den Modulus aus einem Zertifikat?', answer: 'Verwenden Sie dieses Tool, um den DER/PEM-codierten öffentlichen Schlüssel zu decodieren. Der Parser extrahiert und zeigt Modulus und Exponent in verschiedenen Formaten (Hex, Dezimal, Base64) an.' },
      ],
      usage: ['Codieren: Modulus und Exponent eingeben', 'Decodieren: DER- oder PEM-Daten einfügen'],
    },
    futurexKeys: {
      title: 'Futurex Schlüssel Verschlüsselung/Entschlüsselung Online - HSM Schlüssel-Varianten-Tool | HSM Kit',
      description: 'Kostenloses Online Futurex HSM Schlüssel-Verschlüsselungs- und Entschlüsselungstool. Verschlüsseln und Entschlüsseln von Schlüsseln mit MFK (Master File Key) und Modifier-Varianten (0-F, 1A-1F). Unterstützt Futurex, IBM, Atalla und VISA Schlüssel-Varianten-Methoden. Schlüsselsuche findet den korrekten Modifier durch KCV-Abgleich. 100% clientseitig.',
      keywords: 'Futurex HSM, Schlüsselverschlüsselung, Schlüsselentschlüsselung, MFK, Master File Key, Schlüsselvariante, Modifier, HSM-Tools, Zahlungssicherheit, Schlüsselverwaltung, IBM HSM, Atalla HSM, VISA PVK, KCV-Prüfung, 3DES-Verschlüsselung, Schlüsselsuche, HSM-Schlüsselverwaltung',
      faqTitle: 'Futurex Schlüssel FAQ',
      usageTitle: 'Futurex Schlüssel-Tool Anleitung',
      faqs: [
        { question: 'Was ist Futurex Schlüsselverschlüsselung?', answer: 'Futurex HSMs verwenden eine spezifische Schlüsselverschlüsselungsmethode, bei der Schlüssel mit Varianten eines Master File Key (MFK) kombiniert mit einem Modifier (0-F, 1A-1F) verschlüsselt werden. Der Varianten-Schlüssel wird durch XOR des MFK mit dem Modifier-Byte erstellt.' },
        { question: 'Was ist der Modifier?', answer: 'Der Modifier (0-F, 1A-1F) wird verwendet, um verschiedene Schlüsselvarianten aus dem MFK zu erstellen. Jeder Modifier erzeugt einen eindeutigen Verschlüsselungsschlüssel für verschiedene Zwecke wie PIN-Schlüssel, MAC-Schlüssel oder Datenverschlüsselungsschlüssel.' },
        { question: 'Was ist MFK (Master File Key)?', answer: 'MFK ist der Basis-Hauptschlüssel in Futurex HSMs. Er ist typischerweise ein dreifach langer 3DES-Schlüssel (48 Hex-Zeichen). Der MFK wird mit einem Modifier kombiniert, um Varianten-Schlüssel zum Verschlüsseln/Entschlüsseln anderer Schlüssel zu erstellen.' },
        { question: 'Was ist Schlüsselsuche?', answer: 'Die Schlüsselsuche versucht alle Modifier (0-F, 1A-1F), um einen verschlüsselten Schlüssel zu entschlüsseln. Sie können die Ergebnisse nach KCV (Key Check Value) und Paritätstyp (Ungerade/Gerade) filtern, um den genauen für die Verschlüsselung verwendeten Modifier zu finden.' },
        { question: 'Was sind die Unterschiede zwischen den verschiedenen HSM-Typen?', answer: 'Verschiedene HSM-Hersteller verwenden unterschiedliche Schlüssel-Varianten-Methoden: Futurex verwendet Vollbyte-XOR, IBM verwendet positionsspezifisches XOR, Atalla verwendet die AKB-Methode und VISA verwendet die PVK-Methode nur für die ersten 8 Bytes.' },
        { question: 'Was ist KCV und wie wird es verwendet?', answer: 'KCV (Key Check Value) wird durch Verschlüsselung von Nullen mit dem Schlüssel berechnet. Bei der Schlüsselsuche können Sie einen erwarteten KCV eingeben, um die Ergebnisse zu filtern und den Modifier zu finden, der diesen spezifischen KCV erzeugt.' },
      ],
      usage: [
        'Schlüssel verschlüsseln: Hexadezimalen Klartext-Schlüssel eingeben, Modifier und MFK auswählen, auf Verschlüsseln klicken.',
        'Schlüssel entschlüsseln: Hexadezimalen verschlüsselten Schlüssel eingeben, Modifier und MFK auswählen, auf Entschlüsseln klicken.',
        'Ergebnis zeigt: Eingabeschlüssel, erkannte Parität, verwendeter MFK, Modifier, Ausgabeschlüssel und KCV.',
        'Schlüsselsuche: Verschlüsselten Schlüssel eingeben, optional KCV-Filter und Paritätsfilter setzen.',
        'HSM-Typ (Beliebig/Futurex/IBM/Atalla/VISA) auswählen und auf Suchen klicken, um alle Modifier zu versuchen.',
        'Ergebnisse zeigen alle übereinstimmenden Entschlüsselungen mit Modifier, entschlüsseltem Schlüssel, KCV und Parität.',
      ],
    },
    atallaKeys: {
      title: 'Atalla Schlüssel (AKB) Online - HSM Schlüssel-Verschlüsselungstool | HSM Kit',
      description: 'Kostenloses Online Atalla HSM Schlüssel-Verschlüsselungs- und Entschlüsselungstool. Schlüssel mit AKB (Atalla Key Block) Format verschlüsseln/entschlüsseln. Sichere Schlüsselverwaltung mit MFK und AKB-Header. KCV-Verifizierung und Paritätsprüfung unterstützt. Alle Verarbeitung erfolgt im Browser.',
      keywords: 'Atalla HSM, AKB, Atalla Key Block, Schlüsselverschlüsselung, Schlüsselentschlüsselung, MFK, HSM-Tools, Zahlungssicherheit, Schlüsselverwaltung, KCV-Prüfung, 3DES-Verschlüsselung, Atalla-Schlüsselverwaltung',
      faqTitle: 'Atalla Schlüssel FAQ',
      usageTitle: 'Atalla Schlüssel-Tool Anleitung',
      faqs: [
        { question: 'Was ist AKB (Atalla Key Block)?', answer: 'AKB ist ein Schlüsselblockformat, das in Atalla HSMs verwendet wird. Es besteht aus einem 8-Zeichen-Header (z.B. 1PUNE000) und verschlüsselten Schlüsseldaten. Der Header definiert die Schlüsselvariante.' },
        { question: 'Was ist der AKB-Header?', answer: 'Der AKB-Header ist ein 8-Zeichen-Präfix, das die für die Verschlüsselung verwendete Schlüsselvariante definiert. Ein häufiges Beispiel ist 1PUNE000, wobei verschiedene Header verschiedene Schlüsseltypen oder Verwendungszwecke anzeigen.' },
        { question: 'Was ist MFK (Master File Key)?', answer: 'MFK ist der Basis-Hauptschlüssel, der in Atalla HSMs verwendet wird. Es ist ein dreifach langer 3DES-Schlüssel (48 Hex-Zeichen), der mit dem AKB-Header kombiniert wird, um Varianten-Schlüssel für die Schlüsselverschlüsselung/entschlüsselung zu erstellen.' },
        { question: 'Wie funktioniert die AKB-Verschlüsselung?', answer: 'Der AKB-Header wird in ASCII-Werte konvertiert und mit dem MFK ge-XOR-t, um einen Varianten-Schlüssel zu erstellen. Dieser Varianten-Schlüssel verschlüsselt den Zielschlüssel mittels 3DES ECB-Modus und bildet den AKB aus Header und Chiffretext.' },
        { question: 'Was ist die KCV-Prüfung?', answer: 'KCV (Key Check Value) wird zur Verifizierung entschlüsselter Schlüssel verwendet. Bei der Entschlüsselung können Sie einen KCV eingeben, um mit dem berechneten KCV zu vergleichen und den korrekten MFK und das AKB-Format zu bestätigen.' },
      ],
      usage: [
        'Schlüssel verschlüsseln: Hexadezimalen Schlüssel eingeben, AKB-Header setzen (Standard: 1PUNE000), MFK eingeben und auf Verschlüsseln klicken.',
        'Ergebnis zeigt: Klartext-Schlüssel, AKB-Header, erzeugter AKB, KCV.',
        'AKB entschlüsseln: AKB eingeben (z.B. 1PUNE000,verschlüsselteDaten), MFK eingeben und auf Entschlüsseln klicken.',
        'Optional KCV-Prüfung aktivieren mit erwartetem KCV, Paritätsfilter setzen.',
        'Ergebnis zeigt: AKB, Header, entschlüsselter Schlüssel, KCV, Parität.',
      ],
    },
    safenetKeys: {
      title: 'SafeNet Schlüssel Verschlüsselung/Entschlüsselung Online - HSM Schlüssel-Varianten-Tool | HSM Kit',
      description: 'Kostenloses Online SafeNet HSM Schlüssel-Verschlüsselungs- und Entschlüsselungstool. Schlüssel mit KM-Schlüssel und Schlüsselformat/Varianten-Optionen verschlüsseln/entschlüsseln. DPK, PPK, MPK, KPK Varianten unterstützt. Schlüsselsuche findet die richtige Variante durch KCV-Abgleich. Sichere Browser-Verarbeitung.',
      keywords: 'SafeNet HSM, Schlüsselverschlüsselung, Schlüsselentschlüsselung, KM-Schlüssel, Schlüsselvariante, DPK, PPK, MPK, KPK, HSM-Tools, Zahlungssicherheit, Schlüsselverwaltung, KCV-Prüfung, 3DES-Verschlüsselung, Schlüsselsuche, SafeNet-Schlüsselverwaltung',
      faqTitle: 'SafeNet Schlüssel FAQ',
      usageTitle: 'SafeNet Schlüssel-Tool Anleitung',
      faqs: [
        { question: 'Was ist SafeNet Schlüsselverschlüsselung?', answer: 'SafeNet HSMs verwenden eine spezifische Schlüsselverschlüsselungsmethode, bei der Schlüssel mit Varianten eines Key Management Key (KM Key) verschlüsselt werden. Die Variante wird durch den Schlüsselverwendungstyp (DPK, PPK, MPK usw.) bestimmt.' },
        { question: 'Was sind Schlüsselformate?', answer: 'Schlüsselformat definiert Verschlüsselungsmethode und Schlüssellänge: 00=Klar, 10/20=Einzel-DES, 11/21=Doppel-DES3, 12/22=Dreifach-DES3. Formate 1x verwenden ECB-Modus, 2x verwenden CBC-Modus.' },
        { question: 'Was sind Varianten?', answer: 'Varianten bestimmen Schlüsselverwendung: 00=DPK (Datenschutz), 01=PPK (PIN-Schutz), 02=MPK (MAC-Schutz), 03=KPK (Schlüsselschutz), 04=KTK (Schlüsseltransport), 05=KEK (Schlüsselverschlüsselung). Jede Variante XOR-t den KM-Schlüssel mit einer spezifischen Maske.' },
        { question: 'Was ist der KM-Schlüssel?', answer: 'KM-Schlüssel (Key Management Key) ist der Hauptschlüssel in SafeNet HSMs. Typischerweise ein doppelt langer 3DES-Schlüssel (32 Hex-Zeichen). Der KM-Schlüssel wird mit Varianten-Masken ge-XOR-t, um Verschlüsselungsschlüssel zu erstellen.' },
        { question: 'Was ist Schlüsselsuche?', answer: 'Schlüsselsuche versucht alle Varianten (DPK, PPK, MPK usw.), um einen verschlüsselten Schlüssel zu entschlüsseln. KCV und Parität filtern Ergebnisse, um die genaue für Verschlüsselung verwendete Variante zu finden.' },
      ],
      usage: [
        'Schlüssel verschlüsseln: Klartext-Schlüssel eingeben, Schlüsselformat und Variante wählen, KM-Schlüssel eingeben, Verschlüsseln klicken.',
        'Schlüssel entschlüsseln: Verschlüsselten Schlüssel eingeben, Schlüsselformat und Variante wählen, KM-Schlüssel eingeben, Entschlüsseln klicken.',
        'Ergebnis zeigt: Klar-/Verschlüsselter Schlüssel, KCV, Parität, Schlüsselformat, Variante, Varianten-Schlüssel, Ausgabe.',
        'Schlüsselsuche: Verschlüsselten Schlüssel eingeben, optional KCV-Filter und Paritätsfilter setzen.',
        'KM-Schlüssel eingeben und Suchen klicken, um alle Varianten zu versuchen und passende Entschlüsselungen zu finden.',
        'Ergebnisse zeigen alle passenden Varianten mit entschlüsseltem Schlüssel, KCV und Parität.',
      ],
    },
    dukpt: {
      title: 'DUKPT Rechner Online - ISO 9797 Schlüsselableitung & Verschlüsselung | HSM Kit',
      description: 'Kostenloser Online DUKPT-Rechner für ISO 9797 Standard. PEK-Schlüssel von BDK/IPEK und KSN ableiten. PIN-Blöcke verschlüsseln/entschlüsseln, MAC berechnen und Daten verarbeiten. Unverzichtbares Tool für POS- und ATM-Systementwicklung.',
      keywords: 'DUKPT Rechner, ISO 9797, PEK Ableitung, BDK, IPEK, KSN, PIN Verschlüsselung, MAC Berechnung, POS Sicherheit, ATM Sicherheit, Schlüsselableitung, Zahlungsterminal',
      faqTitle: 'DUKPT FAQ',
      usageTitle: 'So verwenden Sie den DUKPT-Rechner',
      faqs: [
        { question: 'Was ist DUKPT?', answer: 'DUKPT (Derived Unique Key Per Transaction) ist ein Schlüsselverwaltungsschema, das für jede Transaktion einen eindeutigen Verschlüsselungsschlüssel von einem Base Derivation Key (BDK) und einer Key Serial Number (KSN) ableitet. Es wird häufig in POS-Terminals und ATM-Systemen verwendet.' },
        { question: 'Was ist der Unterschied zwischen BDK und IPEK?', answer: 'BDK (Base Derivation Key) ist der Hauptschlüssel, den die Schlüsselinjektionsanlage besitzt. IPEK (Initial PIN Encryption Key) ist der erste abgeleitete Schlüssel, der in das Gerät injiziert wird. IPEK wird aus dem BDK und der KSN-Basis des Geräts abgeleitet.' },
        { question: 'Was ist KSN?', answer: 'KSN (Key Serial Number) ist ein 10-Byte-Wert, der jede Transaktion eindeutig identifiziert. Er enthält die Geräteseriennummer und einen Transaktionszähler. Jede KSN erzeugt einen eindeutigen abgeleiteten Schlüssel.' },
        { question: 'Warum gilt DUKPT als sicher?', answer: 'DUKPT ist sicher, weil jede Transaktion einen anderen Verschlüsselungsschlüssel verwendet. Wenn ein Schlüssel kompromittiert wird, kann er nicht zum Entschlüsseln vergangener Transaktionen verwendet werden (Forward Secrecy). Nur zukünftige Transaktionen mit diesem spezifischen Gerät wären gefährdet.' },
        { question: 'Was ist Datenvariante in DUKPT?', answer: 'Datenvariante ist eine Schlüsselmodifikationstechnik, bei der der Verschlüsselungsschlüssel vor der Verwendung mit einem festen Muster (typischerweise 0x000...0FF) XOR-verknüpft wird. Dies erzeugt verschiedene Schlüssel für verschiedene Zwecke (PIN, MAC, Daten) aus demselben abgeleiteten Schlüssel.' },
      ],
      usage: [
        'Für PEK-Ableitung: Geben Sie BDK/IPEK (32 Hex) und KSN (20 Hex) ein, klicken Sie dann auf "PEK ableiten", um den PIN-Verschlüsselungsschlüssel zu generieren.',
        'Für PIN-Verschlüsselung: Geben Sie PEK und PIN-Block ein, klicken Sie dann auf "Verschlüsseln" oder "Entschlüsseln".',
        'Für MAC-Berechnung: Geben Sie PEK ein, wählen Sie den Algorithmus (DES/3DES), geben Sie Daten ein und klicken Sie auf "MAC berechnen".',
        'Für Datenverschlüsselung: Geben Sie PEK ein, aktivieren Sie optional Datenvariante, wählen Sie Eingabetyp (ASCII/Hex), geben Sie Daten ein und klicken Sie auf "Verschlüsseln" oder "Entschlüsseln".',
      ],
    },
    dukptAes: {
      title: 'DUKPT AES Rechner Online - AES Schlüsselableitung & Verschlüsselung | HSM Kit',
      description: 'Kostenloser Online DUKPT AES-Rechner mit Unterstützung für AES-128, AES-192, AES-256, 2TDEA und 3TDEA. Arbeitsschlüssel von BDK/IK und KSN ableiten. Unverzichtbares Tool für moderne POS- und Zahlungsterminalentwicklung.',
      keywords: 'DUKPT AES Rechner, AES-128, AES-192, AES-256, 2TDEA, 3TDEA, Arbeitsschlüsselableitung, BDK, IK, KSN, PIN Verschlüsselung, MAC Berechnung, POS Sicherheit, Zahlungsterminal, Schlüsselverwaltung',
      faqTitle: 'DUKPT AES FAQ',
      usageTitle: 'So verwenden Sie den DUKPT AES-Rechner',
      faqs: [
        { question: 'Was ist DUKPT AES?', answer: 'DUKPT AES ist eine Erweiterung des ursprünglichen DUKPT-Standards (Derived Unique Key Per Transaction), die zusätzlich zu traditionellem TDEA (Triple DES) Unterstützung für AES-Verschlüsselungsalgorithmen (AES-128, AES-192, AES-256) bietet.' },
        { question: 'Welche Schlüsseltypen werden unterstützt?', answer: 'DUKPT AES unterstützt 2TDEA (16-Byte-Schlüssel), 3TDEA (24-Byte-Schlüssel), AES-128 (16-Byte-Schlüssel), AES-192 (24-Byte-Schlüssel) und AES-256 (32-Byte-Schlüssel). Jeder bietet unterschiedliche Sicherheits- und Leistungsebenen.' },
        { question: 'Was ist der Unterschied zwischen BDK und IK?', answer: 'BDK (Base Derivation Key) ist der Stammschlüssel, der von Schlüsselinjektionsanlagen verwendet wird. IK (Initial Key) ist der erste abgeleitete Schlüssel, der in ein Gerät geladen wird. Beide können als Ausgangspunkte für die DUKPT-Schlüsselableitung verwendet werden.' },
        { question: 'Warum AES statt TDEA verwenden?', answer: 'AES bietet stärkere Sicherheit, bessere Leistung und ist der moderne Verschlüsselungsstandard. AES-128 bietet gleichwertige Sicherheit wie 3TDEA, aber mit besserer Geschwindigkeit. AES-256 bietet noch stärkeren Schutz für hochsensible Daten.' },
        { question: 'Was ist das KSN-Format?', answer: 'KSN (Key Serial Number) ist ein 12-Byte-Wert (24 Hex-Zeichen), der die Geräteseriennummer und einen Transaktionszähler enthält. Er stellt sicher, dass jede Transaktion einen eindeutigen abgeleiteten Schlüssel verwendet.' },
      ],
      usage: [
        'Wählen Sie Schlüsseltyp (BDK/IK) und Arbeitsschlüsseltyp (2TDEA, 3TDEA, AES-128, AES-192 oder AES-256).',
        'Geben Sie BDK/IK mit korrekter Länge basierend auf Schlüsseltyp (32/48/64 Hex) und KSN (24 Hex) ein.',
        'Klicken Sie auf "Schlüssel ableiten", um den Arbeitsschlüssel für die spezifische Transaktion zu generieren.',
        'Verwenden Sie den abgeleiteten Schlüssel für PIN-Verschlüsselung/Entschlüsselung, MAC-Berechnung oder Datenverschlüsselungsoperationen.',
      ],
    },
    ansiMac: {
      title: 'ANSI MAC Rechner Online - X9.9 & X9.19 MAC Generator | HSM Kit',
      description: 'Kostenloser Online ANSI MAC Rechner für X9.9 (Wholesale) und X9.19 (Retail) Algorithmen. Generieren Sie Message Authentication Codes für Finanztransaktionen mit DES und 3DES Verschlüsselung.',
      keywords: 'ANSI MAC, X9.9 MAC, X9.19 MAC, Wholesale MAC, Retail MAC, Finanz-MAC, Zahlungs-MAC, DES MAC, 3DES MAC, CBC-MAC, Message Authentication',
      faqTitle: 'ANSI MAC FAQ',
      usageTitle: 'So verwenden Sie den ANSI MAC Rechner',
      faqs: [
        { question: 'Was ist ANSI X9.9?', answer: 'ANSI X9.9 (Wholesale MAC) ist ein Message Authentication Code Algorithmus, der DES-Verschlüsselung im CBC-Modus (Cipher Block Chaining) verwendet. Er verarbeitet Daten in 8-Byte-Blöcken und führt für jeden Block eine XOR-Operation mit der vorherigen verschlüsselten Ausgabe durch. Der letzte verschlüsselte Block wird zum MAC. Weit verbreitet in Wholesale-Banking und Interbanken-Finanztransaktionen zur Verifizierung der Nachrichtenintegrität.' },
        { question: 'Was ist ANSI X9.19?', answer: 'ANSI X9.19 (Retail MAC) ist ein verbesserter MAC-Algorithmus für Retail-Zahlungssysteme. Er verwendet Single-DES für alle Datenblöcke im CBC-Modus, wendet aber Triple DES (3DES) Verschlüsselung auf den letzten Block für erhöhte Sicherheit an. Dieser hybride Ansatz bietet stärkeren Schutz gegen kryptanalytische Angriffe bei gleichzeitiger Rückwärtskompatibilität mit X9.9-Systemen in Retail-Umgebungen.' },
        { question: 'Wann sollte ich X9.19 anstelle von X9.9 verwenden?', answer: 'Verwenden Sie X9.19 für Retail/Consumer-Transaktionen (POS-Terminals, Geldautomaten, Kartenzahlungen), die höhere Sicherheit durch die 3DES-Verschlüsselung des letzten Blocks erfordern. Verwenden Sie X9.9 für Wholesale/institutionelle Transaktionen (Interbanken-Überweisungen, Clearing-Systeme), bei denen beide Parteien in sicheren Umgebungen arbeiten. X9.19 wird für alle neuen Implementierungen aufgrund des stärkeren kryptografischen Schutzes empfohlen.' },
        { question: 'Was sind die Schlüsselanforderungen für ANSI MAC?', answer: 'Für X9.9: Ein einzelner DES-Schlüssel (64-Bit, 16 Hex-Zeichen, mit Paritätsbits effektiv 56-Bit). Für X9.19: Entweder ein einzelner DES-Schlüssel (zweimal in 3DES verwendet) oder zwei separate DES-Schlüssel (K und K\') für die finale 3DES-Verschlüsselung. Schlüssel müssen korrekte Parität haben und sollten kryptografisch stark sein. Daten werden vor der Verarbeitung auf 8-Byte-Grenzen mit Nullen aufgefüllt.' },
        { question: 'Wie funktioniert MAC-Truncation?', answer: 'MAC-Truncation reduziert die 8-Byte (64-Bit) MAC-Ausgabe auf eine kürzere Länge für Übertragungseffizienz. Übliche Truncation-Werte sind 4 Bytes (32 Bits) für Standardsicherheit oder 6 Bytes (48 Bits) für erhöhte Sicherheit. Truncation verwendet die linkesten N Bytes des finalen MAC-Blocks. Beachten Sie, dass kürzere MACs die Sicherheit reduzieren - ein 4-Byte-MAC bietet 2^32 mögliche Werte, was Brute-Force einfacher macht als der volle 8-Byte-MAC mit 2^64 Möglichkeiten.' }
      ],
      usage: [
        'Wählen Sie den MAC-Algorithmus: Wählen Sie "ANSI MAC X9.9 (Wholesale MAC)" für Wholesale-Banking-Transaktionen mit DES CBC-MAC, oder "ANSI MAC X9.19 (Retail MAC)" für Retail-Zahlungssysteme mit DES und 3DES-Verschlüsselung des letzten Blocks.',
        'Geben Sie den primären DES-Schlüssel (K) ein: Geben Sie den Hauptverschlüsselungsschlüssel im Hexadezimalformat ein. Muss genau 16 Hex-Zeichen (8 Bytes, 64 Bits mit Parität) für einen einfachen DES-Schlüssel oder 32 Hex-Zeichen (16 Bytes) für einen doppelten 3DES-Schlüssel sein.',
        'Für X9.19 geben Sie den zweiten Schlüssel (K\') ein: Wenn Sie separate Schlüssel für den 3DES-Endblock verwenden, geben Sie den zweiten DES-Schlüssel (16 Hex-Zeichen) ein. Leer lassen, um den primären Schlüssel K für beide DES-Operationen im finalen 3DES-Schritt zu verwenden.',
        'Geben Sie die zu authentifizierenden Daten ein: Geben Sie die Nachricht oder Transaktionsdaten im Hexadezimalformat ein. Die Daten werden automatisch mit Nullen auf ein Vielfaches von 16 Hex-Zeichen (8 Bytes) aufgefüllt, um die Anforderungen der Blockchiffre zu erfüllen.',
        'Setzen Sie die Truncation-Länge: Geben Sie an, wie viele Bytes des finalen MAC verwendet werden sollen (1-8 Bytes). Standardwerte sind 4 Bytes (8 Hex-Zeichen) für die meisten Finanzanwendungen oder 8 Bytes (volle 16 Hex-Zeichen) für maximale Sicherheit.',
        'Klicken Sie auf "Calculate MAC": Das Tool verarbeitet Ihre Daten mit dem ausgewählten Algorithmus. Für X9.9 wendet es DES CBC-MAC an. Für X9.19 wendet es DES CBC auf alle Blöcke an, dann 3DES auf den finalen Block.',
        'Kopieren Sie den generierten MAC: Der berechnete MAC erscheint im Hexadezimalformat mit der angegebenen Truncation-Länge. Verwenden Sie die Kopieren-Schaltfläche, um den MAC in Ihre Transaktionsnachricht oder Ihr Validierungssystem zu übertragen. Überprüfen Sie, ob die MAC-Länge den Anforderungen Ihres Systems entspricht.'
      ],
    },
    as2805Mac: {
      title: 'AS2805.4.1 MAC Rechner Online - Australischer EFTPOS Message Authentication Code | HSM Kit',
      description: 'Kostenloser Online AS2805 MAC-Rechner zur Generierung von Message Authentication Codes für australische Zahlungssysteme. Unterstützt Method 1 (DES CBC-MAC) und Method 2 (DES+3DES final block) Sicherheitsstufen gemäß AS2805.4.1 Standard. Verwendet K|KL und KR Schlüssel für EFTPOS-Transaktionen. PCI DSS-konform für australische Zahlungssicherheit.',
      keywords: 'AS2805 MAC Rechner, AS2805.4.1, EFTPOS MAC, Australian Payment MAC, Message Authentication Code, DES CBC-MAC, 3DES MAC, EFTPOS Sicherheit, K|KL Schlüssel, KR Schlüssel, Zahlungssicherheit',
      faqTitle: 'AS2805 MAC FAQ',
      usageTitle: 'So verwenden Sie den AS2805 MAC-Rechner',
      faqs: [
        { question: 'Was ist AS2805?', answer: 'AS2805.4.1 ist der australische Standard für Message Authentication in EFTPOS-Systemen. Er basiert auf ISO 9797-1 Algorithm 3, ist jedoch für australische Zahlungsnetzwerke spezifisch. Der Standard unterstützt zwei Methoden: Method 1 verwendet DES CBC-MAC für Rückwärtskompatibilität, Method 2 verwendet DES mit einem 3DES-finalen Block für erhöhte Sicherheit.' },
        { question: 'Was ist der Unterschied zwischen Method 1 und Method 2?', answer: 'Method 1 verwendet DES CBC-MAC für alle Blöcke. Method 2 verschlüsselt die meisten Blöcke mit DES, verwendet jedoch 3DES für den finalen Block (encrypt-decrypt-encrypt mit KL und KR), was Meet-in-the-Middle-Angriffe verhindert. Method 2 bietet bessere Sicherheit und wird für neue Implementierungen nach PCI DSS-Anforderungen empfohlen.' },
        { question: 'Welche Schlüssel sind für AS2805 MAC erforderlich?', answer: 'Method 1 benötigt einen Single-DES-Schlüssel K|KL. Method 2 benötigt zwei Schlüssel: K|KL (linker Schlüssel) und KR (rechter Schlüssel) für 3DES-Operationen. Beide Schlüssel müssen gültige DES-Schlüssel mit korrekter Parität sein, typischerweise 16 Hex-Bytes (8 Bytes).' },
        { question: 'Wie unterscheidet sich AS2805 von ISO 9797-1?', answer: 'AS2805 basiert auf ISO 9797-1 Algorithm 3, ist jedoch speziell auf australische EFTPOS-Anforderungen zugeschnitten. Es ist mit den Zahlungsnetzwerken Australiens abgestimmt und integriert lokale Sicherheitsrichtlinien. Der Hauptunterschied liegt in den implementierungsspezifischen Details, Truncation-Anforderungen und Compliance-Standards.' },
        { question: 'Was ist die typische AS2805 MAC-Truncation?', answer: 'Australische EFTPOS-Systeme verwenden typischerweise 4-Byte (8 Hex-Zeichen) MAC-Truncation. Dies balanciert Sicherheit und Effizienz für Terminaloperationen. Der vollständige MAC ist 8 Bytes, aber die Truncation auf 4 Bytes ist Standard für AS2805.4.1-Implementierungen.' },
      ],
      usage: [
        'Wählen Sie Method 1 (DES CBC-MAC) für Legacy-Systeme oder Method 2 (DES+3DES final block) für erhöhte Sicherheit und PCI DSS-Compliance.',
        'Geben Sie den K|KL-Schlüssel ein (16 Hex-Zeichen für 8 Bytes). Bei Method 2 dient dieser als linker Schlüssel für 3DES-Operationen. Stellen Sie sicher, dass die DES-Schlüssel-Parität korrekt ist.',
        'Für Method 2 geben Sie den KR-Schlüssel ein (16 Hex-Zeichen). Dieser rechte Schlüssel wird zusammen mit KL für die Encrypt-Decrypt-Encrypt-Sequenz im finalen Block verwendet.',
        'Geben Sie die Nachrichtendaten im Hex-Format ein. Daten werden automatisch nach ISO 9797-1 padding Method 2 (0x80 gefolgt von 0x00s) auf ein Vielfaches von 8 Bytes aufgefüllt.',
        'Wählen Sie die Truncation-Größe (Standard 4 Bytes für australisches EFTPOS) oder verwenden Sie den vollständigen 8-Byte-MAC für maximale Sicherheit.',
        'Klicken Sie auf "MAC berechnen". Das Tool verarbeitet Ihre Nachricht mit dem ausgewählten Algorithmus und generiert den AS2805-konformen MAC.',
        'Der resultierende MAC kann zum Verifizieren von EFTPOS-Transaktionsintegrität, Sichern von Netzwerknachrichten und Gewährleisten der Datenintegrität in australischen Zahlungssystemen verwendet werden.',
      ],
    },
    iso9797Mac: {
      title: 'ISO/IEC 9797-1 MAC Rechner Online - Message Authentication Code Generator | HSM Kit',
      description: 'Kostenloser Online ISO/IEC 9797-1 MAC Rechner mit Unterstützung für alle 6 Algorithmen (1-6) und mehrere Padding-Methoden. Generieren Sie Message Authentication Codes für Finanztransaktionen, Zahlungssysteme und Sicherheitsanwendungen. Clientseitiges Tool - Ihre Schlüssel verlassen nie Ihr Gerät.',
      keywords: 'ISO 9797 MAC, ISO 9797-1, MAC Rechner, Message Authentication Code, DES MAC, 3DES MAC, CBC-MAC, Zahlungs-MAC, Retail-MAC, Wholesale-MAC, Finanz-MAC, ISO9797, Block-Cipher-MAC, kryptografischer MAC, sicherer MAC, Banking-MAC, Algorithmus 1, Algorithmus 2, Algorithmus 3, Padding-Methode 1, Padding-Methode 2',
      faqTitle: 'ISO 9797-1 MAC FAQ',
      usageTitle: 'So verwenden Sie den ISO 9797-1 MAC Rechner',
      faqs: [
        { question: 'Was ist ISO/IEC 9797-1?', answer: 'ISO/IEC 9797-1 ist ein internationaler Standard, der mehrere MAC (Message Authentication Code) Algorithmen zur Datenintegrität und Authentifizierung mit Blockchiffren wie DES und 3DES definiert. Er wird weit verbreitet in Finanz- und Zahlungssystemen zur Nachrichtenauthentifizierung eingesetzt.' },
        { question: 'Welchen MAC-Algorithmus soll ich verwenden?', answer: 'Algorithmus 1 (DES CBC-MAC) ist der einfachste. Algorithmus 2 verwendet duale Schlüssel für erhöhte Sicherheit. Algorithmus 3 (Retail MAC) ist am sichersten mit DES CBC und abschließender 3DES-Verschlüsselung. Wählen Sie basierend auf Ihren Sicherheitsanforderungen, Systemkompatibilität und Industriestandards.' },
        { question: 'Was sind die Padding-Methoden?', answer: 'Methode 1 füllt mit Nullen (0x00) auf, geeignet für die meisten Fälle. Methode 2 verwendet 0x80 gefolgt von Nullen (ISO 7816-4) und bietet bessere Sicherheit gegen bestimmte Angriffe. Methode 3 enthält die Datenlänge für zusätzliche Integrität. Methode 2 wird für maximale Sicherheit empfohlen.' },
        { question: 'Was ist der Truncation-Parameter?', answer: 'Truncation gibt an, wie viele Bytes (1-8) des endgültigen MAC-Werts ausgegeben werden sollen. Gängige Werte sind 4 Bytes (8 Hex-Zeichen) für Effizienz oder 8 Bytes (16 Hex-Zeichen) für volle Sicherheit. Industriestandards können erforderliche Truncation-Längen angeben.' },
        { question: 'Wie viele Schlüssel benötige ich?', answer: 'Algorithmus 1 erfordert 1 Schlüssel (K). Algorithmus 2 erfordert 2 Schlüssel (K, K2). Algorithmus 3 erfordert 2 Schlüssel (K, K\') für 3DES-Betrieb. Geben Sie Schlüssel im Hexadezimalformat ein, typischerweise 16 oder 32 Zeichen.' },
      ],
      usage: [
        'Wählen Sie den MAC-Algorithmus (Algorithmus 1-6) aus dem Dropdown-Menü.',
        'Geben Sie die erforderlichen Schlüssel im Hexadezimalformat ein (16 oder 32 Hex-Zeichen pro Schlüssel).',
        'Wählen Sie die Padding-Methode: Methode 1 (Nullen), Methode 2 (0x80 + Nullen) oder Methode 3 (mit Länge).',
        'Geben Sie Ihre Daten im Hexadezimalformat in das Datenfeld ein.',
        'Legen Sie die Truncation-Länge (1-8 Bytes) für die Ausgabe-MAC-Größe fest.',
        'Klicken Sie auf "MAC berechnen", um den Message Authentication Code zu generieren.',
        'Kopieren Sie den resultierenden MAC zur Verwendung in Ihrer Anwendung oder im Verifikationsprozess.',
      ],
    },
    cvv: {
      title: 'CVV/CVC Rechner Online - Kartenprüfwert Generieren & Validieren | HSM Kit',
      description: 'Kostenloser Online CVV/CVC-Rechner und -Validator. Generieren und validieren Sie CVV, CVC, iCVV, CVV2, CVC2 und dCVV für Zahlungskartensicherheit. Unterstützt Visa, Mastercard, Amex. Unverzichtbares Tool für Kartenzahlungstests und Sicherheit.',
      keywords: 'CVV Rechner, CVC Rechner, CVV Generator, CVV Validator, iCVV, CVV2, CVC2, dCVV, Kartenprüfwert, Kartensicherheitscode, Zahlungskartensicherheit, CVK-Schlüssel, Kartenverifizierung',
      faqTitle: 'CVV/CVC FAQ',
      usageTitle: 'So verwenden Sie den CVV-Rechner',
      faqs: [
        { question: 'Was ist CVV/CVC?', answer: 'CVV (Card Verification Value) für Visa und CVC (Card Verification Code) für Mastercard sind 3-stellige Sicherheitscodes zur Verifizierung von Transaktionen ohne physische Karte. Sie werden mithilfe von Kartendaten berechnet, die mit den CVK-Schlüsseln des Ausstellers verschlüsselt sind.' },
        { question: 'Was ist der Unterschied zwischen CVV und CVV2?', answer: 'CVV (CVV1) ist auf dem Magnetstreifen kodiert. CVV2 ist der 3-stellige Code auf der Rückseite der Karte. CVV2 bietet zusätzliche Sicherheit für Transaktionen ohne physische Karte wie Online-Käufe.' },
        { question: 'Was ist iCVV?', answer: 'iCVV (integrated Circuit CVV) wird für Chipkarten verwendet. Es enthält den ATC (Application Transaction Counter) in der Berechnung, wodurch es für jede Transaktion einzigartig ist und verbesserte Sicherheit bietet.' },
        { question: 'Was ist dCVV?', answer: 'dCVV (dynamic CVV) wird für kontaktlose Zahlungen verwendet. Wie iCVV verwendet es den ATC, um für jede Transaktion einen eindeutigen Verifizierungswert zu generieren und Replay-Angriffe zu verhindern.' },
        { question: 'Was sind CVK-Schlüssel?', answer: 'CVK (Card Verification Key) besteht aus zwei 16-Byte-DES-Schlüsseln (CVK-A und CVK-B), die vom Kartenaussteller zum Generieren und Validieren von CVV-Werten verwendet werden. Diese Schlüssel müssen sicher aufbewahrt werden, da sie alle von dieser Institution ausgegebenen Karten schützen.' },
      ],
      usage: [
        'Wählen Sie die Registerkarte „Generieren", um einen CVV zu erstellen, oder „Validieren", um einen vorhandenen CVV zu überprüfen.',
        'Geben Sie CVK A- und CVK B-Schlüssel ein (jeweils 32 Hex-Zeichen).',
        'Geben Sie PAN (Primary Account Number), Ablaufdatum (JJMM) und Servicecode (3 Ziffern) ein.',
        'Geben Sie für iCVV oder dCVV auch den ATC (Application Transaction Counter) ein.',
        'Wählen Sie den Verifizierungstyp: CVV/CVC, iCVV, CVV2/CVC2 oder dCVV.',
        'Klicken Sie auf „Generieren", um den CVV zu erstellen, oder geben Sie den CVV ein und klicken Sie auf „Validieren", um ihn zu überprüfen.',
      ],
    },
    amexCsc: {
      title: 'AMEX CSC Rechner Online - American Express Kartensicherheitscode Generieren & Validieren | HSM Kit',
      description: 'Kostenloser Online AMEX CSC-Rechner und -Validator. Generieren und validieren Sie CSC, CSC-5, CSC-4 und CSC-3 für American Express-Karten. Unterstützt CSC Version 1 und 2. Unverzichtbares Tool für AMEX-Kartenzahlungstests.',
      keywords: 'AMEX CSC Rechner, AMEX CSC Generator, American Express CSC, CSC-5, CSC-4, CSC-3, Kartensicherheitscode, AMEX Kartenverifizierung, Zahlungskartensicherheit, CSC-Schlüssel, AMEX-Validierung',
      faqTitle: 'AMEX CSC FAQ',
      usageTitle: 'So verwenden Sie den AMEX CSC-Rechner',
      faqs: [
        { question: 'Was ist AMEX CSC?', answer: 'AMEX CSC (Card Security Code) ist die Version des Kartenprüfwerts von American Express. Er ähnelt CVV/CVC, verwendet jedoch eine 15-stellige PAN, die spezifisch für AMEX-Karten ist.' },
        { question: 'Was ist der Unterschied zwischen CSC Version 1 und 2?', answer: 'CSC Version 1 generiert einen 4-stelligen Code für den Magnetstreifen. CSC Version 2 ist erweitert und generiert CSC-5 (5 Ziffern), CSC-4 (4 Ziffern) und CSC-3 (3 Ziffern auf der Vorderseite der Karte).' },
        { question: 'Wo befindet sich CSC-3?', answer: 'CSC-3 ist der 3- oder 4-stellige Code auf der Vorderseite von American Express-Karten, typischerweise über der Kartennummer auf der rechten Seite.' },
        { question: 'Wofür wird CSC-5 verwendet?', answer: 'CSC-5 ist ein 5-stelliger Code, der intern für erweiterte Kartenverifizierung in Version 2 verwendet wird. Er bietet zusätzliche Sicherheitsebenen für die Transaktionsvalidierung.' },
        { question: 'Wie unterscheidet sich AMEX CSC von Visa/Mastercard CVV?', answer: 'AMEX verwendet 15-stellige PANs (im Vergleich zu 16 für Visa/MC) und hat einen anderen Algorithmus. AMEX CSC Version 2 bietet außerdem mehrere Verifizierungswerte (CSC-5, CSC-4, CSC-3) für verschiedene Anwendungsfälle.' },
      ],
      usage: [
        'Wählen Sie CSC-Version: Version 1 (4-stelliger Magnetstreifen) oder Version 2 (erweitert mit CSC-5, CSC-4, CSC-3).',
        'Geben Sie CSC-Schlüssel ein (32 oder 48 Hex-Zeichen) - den Kartensicherheitsschlüssel des Ausstellers.',
        'Geben Sie AMEX PAN (15 Ziffern), Ablaufdatum (JJMM) und Servicecode (3 Ziffern) ein.',
        'Klicken Sie auf „Generieren", um die CSC-Werte zu erstellen, oder geben Sie einen CSC ein und klicken Sie auf „Validieren", um ihn zu überprüfen.',
        'Version 2 generiert mehrere Codes: CSC-5 (5 Ziffern), CSC-4 (4 Ziffern), CSC-3 (3 Ziffern).',
      ],
    },
    mastercardCvc3: {
      title: 'MasterCard CVC3 Rechner Online - Dynamischen CVC3 Generieren & Validieren | HSM Kit',
      description: 'Kostenloser Online MasterCard dynamischer CVC3-Rechner und -Validator. Generieren und validieren Sie dynamische CVC3 und PIN-CVC3 für kontaktlose EMV-Karten. Unverzichtbares Tool für MasterCard-Zahlungstests.',
      keywords: 'MasterCard CVC3, dynamischer CVC3, PIN-CVC3, kontaktlose Zahlung, EMV-Karte, ICC Master Key, IMK, Kartenverifizierung, Zahlungssicherheit, ATC, Unpredictable Number',
      faqTitle: 'MasterCard CVC3 FAQ',
      usageTitle: 'So verwenden Sie den MasterCard CVC3-Rechner',
      faqs: [
        { question: 'Was ist MasterCard dynamischer CVC3?', answer: 'MasterCard dynamischer CVC3 ist ein 3-stelliger Sicherheitscode, der dynamisch für jede kontaktlose EMV-Transaktion generiert wird. Im Gegensatz zu statischem CVV/CVC ändert er sich bei jeder Transaktion und bietet erhöhte Sicherheit.' },
        { question: 'Was ist der Unterschied zwischen dynamischem CVC3 und PIN-CVC3?', answer: 'Dynamischer CVC3 wird für kontaktlose Transaktionen ohne PIN-Verifizierung verwendet. PIN-CVC3 wird generiert, wenn eine PIN-Verifizierung während der Transaktion durchgeführt wird und eine zusätzliche Sicherheitsebene bietet.' },
        { question: 'Was ist IMK?', answer: 'IMK (ICC Master Key) ist der Hauptschlüssel des Ausstellers, der zum Ableiten kartenspezifischer Schlüssel verwendet wird. Er wird zur Generierung von MK-CVC3 verwendet, das dann den dynamischen CVC3 für jede Transaktion erzeugt.' },
        { question: 'Was ist die Unpredictable Number?', answer: 'Die Unpredictable Number (UN) ist ein Zufallswert, der vom Terminal für jede Transaktion bereitgestellt wird. Sie stellt sicher, dass der CVC3 auch bei identischen Transaktionsdaten jedes Mal anders ist.' },
        { question: 'Warum werden Track 1/2-Daten benötigt?', answer: 'Track 1/2-Daten enthalten Karteninformationen, die vom Magnetstreifen gelesen oder im EMV-Chip gespeichert werden. Sie sind Teil der Eingabedaten zur Berechnung des CVC3 und stellen sicher, dass der Code kartenspezifisch und transaktionsspezifisch ist.' },
      ],
      usage: [
        'Geben Sie IMK ein (32 Hex-Zeichen) - den ICC Master Key vom Kartenaussteller.',
        'Geben Sie PAN (13-19 Ziffern), PAN-Sequenznummer (2 Ziffern) und ATC (4 Hex-Zeichen) ein.',
        'Geben Sie Track 1/2-Daten (bis zu 128 Hex-Zeichen) und Unpredictable Number (8 Hex-Zeichen) ein.',
        'Wählen Sie CVC3-Typ: dynamischer CVC3 (Standard kontaktlos) oder PIN-CVC3 (mit PIN-Verifizierung).',
        'Klicken Sie auf „Generieren", um den 3-stelligen CVC3 zu erstellen, oder geben Sie einen CVC3 ein und klicken Sie auf „Validieren", um ihn zu überprüfen.',
      ],
    },
    thalesKeys: {
      title: 'Thales Schlüssel (LMK) Online - HSM Schlüssel-Verschlüsselung/Entschlüsselung | HSM Kit',
      description: 'Kostenloses Online Thales HSM Schlüssel-Verschlüsselungs-/Entschlüsselungstool. Schlüssel mit LMK (Local Master Key) und Schlüsselschema/Varianten-Optionen verschlüsseln/entschlüsseln. Unterstützt mehrere LMK-Paare und Varianten-Masken. Schlüsselsuche findet passende Entschlüsselungen. 100% clientseitig.',
      keywords: 'Thales HSM, LMK, Local Master Key, Schlüsselverschlüsselung, Schlüsselentschlüsselung, Schlüsselschema, Schlüsselvariante, LMK-Paar, HSM-Tools, Zahlungssicherheit, Schlüsselverwaltung, KCV-Prüfung, 3DES-Verschlüsselung, Schlüsselsuche, Thales-Schlüsselverwaltung',
      faqTitle: 'Thales Schlüssel (LMK) FAQ',
      usageTitle: 'Thales Schlüssel-Tool Anleitung',
      faqs: [
        { question: 'Was ist Thales Schlüsselverschlüsselung?', answer: 'Thales HSMs verwenden LMK-basierte (Local Master Key) Verschlüsselung, bei der Schlüssel mit Varianten von LMK-Paaren verschlüsselt werden. Die Variante wird durch eine auf den LMK angewendete XOR-Maske bestimmt.' },
        { question: 'Was ist das Schlüsselschema?', answer: 'Schlüsselschema definiert Schlüssellänge und Format: 0=Klar, U=Einzellänge ECB, T=Doppellänge ECB, X=Dreifachlänge ECB, Y=Doppellänge Variante, Z=Dreifachlänge Variante. Schema-Präfix wird zu verschlüsselten Schlüsseln hinzugefügt.' },
        { question: 'Was sind LMK-Paare?', answer: 'LMK-Paare sind Hauptschlüsselpaare für verschiedene Zwecke: 00-01 für ZMK/ZPK/TMK/TPK, 02-03 für PVK/CVK/BDK, 04-05 für TAK, 14-15 für ZEK/DEK usw. Jedes Paar verschlüsselt bestimmte Schlüsseltypen.' },
        { question: 'Was sind Varianten?', answer: 'Varianten (0-8) bestimmen XOR-Masken für LMK: 0=Keine Variante, 1=A6, 2=5A, 3=6A, 4=DE, 5=2B, 6=50, 7=74, 8=9C. Maske wird mit jedem 8-Byte-Block des LMK ge-XOR-t.' },
        { question: 'Was ist LMK-Größe?', answer: 'LMK-Größe bestimmt LMK-Länge: Doppelt (16 Byte/32 Hex) oder Dreifach (24 Byte/48 Hex). Die meisten Thales HSMs verwenden auf Dreifachlänge erweiterte Doppellängen-LMKs für 3DES-Verschlüsselung.' },
        { question: 'Was ist Schlüsselsuche?', answer: 'Schlüsselsuche versucht alle Varianten, um einen verschlüsselten Schlüssel zu entschlüsseln. KCV (Key Check Value) und Paritätstyp (Ungerade/Gerade) filtern Ergebnisse, um die genaue für Verschlüsselung verwendete Variante zu finden.' },
      ],
      usage: [
        'Schlüssel verschlüsseln: Klartext-Schlüssel eingeben, Schlüsselschema, LMK-Größe, LMK-Paar wählen, LMK-Schlüssel eingeben, Variante wählen, Verschlüsseln klicken.',
        'Schlüssel entschlüsseln: Verschlüsselten Schlüssel (mit/ohne Schema-Präfix) eingeben, LMK-Einstellungen konfigurieren, Entschlüsseln klicken.',
        'Ergebnis zeigt: Klar-/Verschlüsselter Schlüssel, KCV, Parität, Schlüsselschema, LMK-Paar, Variante, Ausgabe.',
        'Schlüsselsuche: Verschlüsselten Schlüssel eingeben, optional KCV-Filter und Paritätsfilter setzen.',
        'Suchen klicken, um alle Varianten zu versuchen und passende Entschlüsselungen zu finden.',
        'Ergebnisse zeigen alle passenden Varianten mit entschlüsseltem Schlüssel, KCV und Parität.',
      ],
    },
    thalesKeyBlock: {
      title: 'Thales Schlüsselblock Online - Proprietäre Schlüsselblöcke Kodieren/Dekodieren | HSM Kit',
      description: 'Kostenloser Online Thales Schlüsselblock-Encoder und -Decoder. Proprietäre Thales-Schlüsselblöcke mit KBPK (Key Block Protection Key) kodieren/dekodieren. Unterstützt 3DES/AES KBPK, verschiedene Schlüsselverwendungen, Algorithmen und Exportfähigkeitsoptionen. Alle Verarbeitung erfolgt im Browser.',
      keywords: 'Thales Schlüsselblock, KBPK, Key Block Protection Key, Schlüsselblock-Encoder, Schlüsselblock-Decoder, HSM-Tools, Zahlungssicherheit, Schlüsselverwaltung, 3DES, AES, Schlüsselverwendung, Exportfähigkeit, Thales-Schlüsselblockformat',
      faqTitle: 'Thales Schlüsselblock FAQ',
      usageTitle: 'Thales Schlüsselblock-Tool Anleitung',
      faqs: [
        { question: 'Was ist Thales Schlüsselblock?', answer: 'Thales Schlüsselblock ist ein proprietäres Schlüsselblockformat, das von Thales HSMs verwendet wird, um Verschlüsselungsschlüssel sicher zu verpacken und zu transportieren. Es enthält Metadaten wie Verwendung, Algorithmus und Exportfähigkeit.' },
        { question: 'Was ist KBPK?', answer: 'KBPK (Key Block Protection Key) ist der Hauptschlüssel zur Verschlüsselung/Entschlüsselung von Schlüsselblöcken. 3DES KBPK ist 24 Byte (48 Hex), AES KBPK ist 32 Byte (64 Hex).' },
        { question: 'Was ist Schlüsselverwendung?', answer: 'Schlüsselverwendung (2 Zeichen) definiert, wie der verpackte Schlüssel verwendet werden kann: B0=BDK, C0=CVK, D0=Datenverschlüsselung, K0=Schlüsselverschlüsselung, M0-M8=MAC-Schlüssel, P0=PIN-Verschlüsselung usw.' },
        { question: 'Was ist Algorithmus?', answer: 'Algorithmus (1 Zeichen) gibt den kryptografischen Algorithmus an: A=AES, D=DES, T=Triple DES, R=RSA, E=Elliptische Kurve, H=HMAC.' },
        { question: 'Was ist Verwendungsmodus?', answer: 'Verwendungsmodus definiert erlaubte Operationen: B=Ver-/Entschlüsseln, C=Generieren/Verifizieren, D=Nur Entschlüsseln, E=Nur Verschlüsseln, G=Nur Generieren, N=Keine Einschränkungen, X=Schlüsselableitung.' },
        { question: 'Was ist Exportfähigkeit?', answer: 'Exportfähigkeit steuert Schlüsselexport: E=Exportierbar in vertrauenswürdigem Schlüsselblock, N=Nicht exportierbar, S=Sensibel (eingeschränkter Export).' },
      ],
      usage: [
        'Kodieren: KBPK (3DES oder AES), Klartext-Schlüssel eingeben, Version, Schlüsselverwendung, Algorithmus, Verwendungsmodus, Exportfähigkeit wählen, Kodieren klicken.',
        'Kodierter Schlüsselblock enthält Header-Metadaten + verschlüsselter Schlüssel + MAC für Integrität.',
        'Dekodieren: KBPK eingeben und Schlüsselblockdaten einfügen, ASCII- oder Hex-Format wählen, Dekodieren klicken.',
        'Dekodierungsergebnis zeigt alle Header-Felder, entschlüsselter Schlüssel, KCV und MAC.',
      ],
    },
    uuid: {
      title: 'UUID Generator Online - Version 1, 3, 4, 5 | HSM Kit',
      description: 'Kostenloser Online-UUID-Generator mit Unterstützung für Version 1 (zeitbasiert), 3 (MD5), 4 (zufällig), 5 (SHA-1). Generieren Sie einzelne oder Batch-UUIDs für Anwendungen. Kryptografisch sichere Zufallszahlengenerierung.',
      keywords: 'UUID-Generator, GUID-Generator, UUID v4, UUID v1, Zufällige UUID, Eindeutige Kennung, UUID online, Batch-UUID-Generator, Eindeutige ID-Generator, GUID-Generator online',
      faqTitle: 'UUID Generator FAQ',
      usageTitle: 'UUID Generator Anleitung',
      faqs: [
        { question: 'Was ist UUID?', answer: 'UUID (Universally Unique Identifier) ist ein 128-Bit-Bezeichner, der in Zeit und Raum eindeutig ist.' },
        { question: 'Welche UUID-Version sollte ich verwenden?', answer: 'Version 4 (zufällig) ist am häufigsten und wird empfohlen.' },
        { question: 'Was ist der Unterschied zwischen UUID und GUID?', answer: 'UUID und GUID (Globally Unique Identifier) sind das Gleiche. GUID ist Microsofts Begriff, während UUID der Standardbegriff (RFC 4122) ist. Gleiches Format, gleicher Zweck.' },
        { question: 'Sind UUIDs wirklich eindeutig?', answer: 'Die Kollisionswahrscheinlichkeit bei UUID v4 beträgt etwa 1 zu 2^122. Selbst bei der Generierung von einer Milliarde UUIDs ist die Wahrscheinlichkeit einer Duplikation extrem gering. Praktisch können sie als eindeutig angesehen werden.' },
      ],
      usage: ['UUID-Version wählen', 'Anzahl eingeben', 'Generieren klicken'],
    },
    bitmap: {
      title: 'ISO8583 Bitmap Encoder/Decoder Online - Zahlungsnachricht Bitmap | HSM Kit',
      description: 'Kostenloser Online-ISO-8583-Bitmap-Encoder und -Decoder. Hex-Bitmap analysieren, um zu sehen, welche Felder in Zahlungsnachrichten vorhanden sind. Unterstützt primäre (1-64) und sekundäre (65-128) Bitmaps. Unverzichtbares Tool für ISO8583-Nachrichtenanalyse.',
      keywords: 'ISO 8583 Bitmap, Bitmap-Decoder, Bitmap-Encoder, Zahlungsnachricht, ISO8583-Felder, Primäre Bitmap, Sekundäre Bitmap, Finanztransaktion, Zahlungsprotokoll, Nachrichten-Bitmap',
      faqTitle: 'ISO8583 Bitmap FAQ',
      usageTitle: 'Bitmap-Tool Anleitung',
      faqs: [
        { question: 'Was ist eine ISO 8583 Bitmap?', answer: 'Die Bitmap in ISO 8583 ist ein Feld, das angibt, welche Datenelemente in der Nachricht vorhanden sind. Jede Bitposition entspricht einer Datenfeldnummer. Wenn ein Bit auf 1 gesetzt ist, ist dieses Feld in der Nachricht enthalten.' },
        { question: 'Was ist der Unterschied zwischen primärer und sekundärer Bitmap?', answer: 'Die primäre Bitmap (64 Bits) deckt die Felder 1-64 ab. Wenn Bit 1 gesetzt ist, folgt eine sekundäre Bitmap, die die Felder 65-128 abdeckt. Dies ermöglicht ISO 8583-Nachrichten bis zu 128 Datenfelder zu enthalten.' },
        { question: 'Wie wird die Bitmap codiert?', answer: 'Die Bitmap wird typischerweise als Hexadezimalwert codiert. Die primäre Bitmap besteht aus 16 Hex-Zeichen (64 Bits). Wenn das erste Bit gesetzt ist (Bit 1), folgen weitere 16 Hex-Zeichen für die sekundäre Bitmap.' },
        { question: 'Wie erkenne ich, welche Felder vorhanden sind?', answer: 'Geben Sie die Hex-Bitmap in das Tool ein, und es zeigt alle Bitpositionen (1-64 oder 1-128) an. Aktivierte Kontrollkästchen zeigen die in der Nachricht vorhandenen Felder an. Sie können auch eine Bitmap erstellen, indem Sie die benötigten Felder auswählen.' },
      ],
      usage: [
        'Geben Sie einen Hex-Bitmap-String ein, um ihn zu decodieren und zu sehen, welche Feldbit gesetzt sind.',
        'Alternativ aktivieren/deaktivieren Sie die Bit-Kontrollkästchen, um Ihre eigene Bitmap zu erstellen.',
        'Bit 1 steuert das Vorhandensein der sekundären Bitmap (Felder 65-128).',
        'Die Hex-Bitmap wird automatisch aktualisiert, wenn Sie Bits aktivieren oder deaktivieren.',
        'Kopieren Sie die generierte Bitmap-Hex für die Verwendung in Ihren ISO8583-Nachrichten.',
      ],
    },
    sslCert: {
      title: 'SSL-Zertifikate (X509) - Schlüssel, CSR, Selbstsignierte Zertifikate | HSM Kit',
      description: 'Kostenloses Online-SSL-Zertifikat-Tool. RSA-Schlüsselpaare mit verschlüsselten privaten Schlüsseln generieren, Certificate Signing Requests (CSR) erstellen, selbstsignierte X.509-Zertifikate generieren und Zertifikate analysieren. Alle Verarbeitung erfolgt clientseitig in Ihrem Browser. 100% sicher.',
      keywords: 'SSL-Zertifikat, X509, CSR-Generator, selbstsigniertes Zertifikat, RSA-Schlüsselgenerator, Zertifikat-Parser, PEM, PKI-Tools, Certificate Signing Request, X.509-Zertifikat, SSL-Tools, Zertifikatgenerator, TLS-Zertifikat, HTTPS-Zertifikat',
      faqTitle: 'SSL-Zertifikate FAQ',
      usageTitle: 'SSL-Zertifikat-Tool Anleitung',
      faqs: [
        { question: 'Was ist ein X.509-Zertifikat?', answer: 'X.509 ist das Standardformat für Public-Key-Zertifikate, verwendet in TLS/SSL für sichere Webverbindungen, E-Mail-Signatur (S/MIME), Code-Signatur und anderen PKI-Anwendungen.' },
        { question: 'Was ist ein CSR (Certificate Signing Request)?', answer: 'Ein CSR ist eine Nachricht an eine Zertifizierungsstelle (CA), um ein Zertifikat anzufordern. Er enthält den öffentlichen Schlüssel und Subjektinformationen (Organisation, Domainname usw.), die im Zertifikat enthalten sein werden.' },
        { question: 'Was ist ein selbstsigniertes Zertifikat?', answer: 'Ein selbstsigniertes Zertifikat wird mit dem eigenen privaten Schlüssel signiert, nicht von einer CA. Es ist nützlich für Tests, Entwicklung oder internen Gebrauch, aber Browser zeigen Warnungen an, da das Zertifikat nicht von einer vertrauenswürdigen CA verifiziert wurde.' },
        { question: 'Warum brauche ich eine Passphrase für den privaten Schlüssel?', answer: 'Die Passphrase verschlüsselt den privaten Schlüssel mit 3DES. Dies schützt den Schlüssel, falls die Datei kompromittiert wird. Ohne die richtige Passphrase kann der private Schlüssel nicht verwendet werden.' },
        { question: 'Welche Schlüssellänge sollte ich verwenden?', answer: 'Für RSA-Schlüssel sind 2048 Bit das Minimum für Sicherheit. 4096 Bit bieten stärkere Sicherheit, sind aber langsamer. 3072 Bit sind ein guter Kompromiss zwischen Sicherheit und Leistung.' },
      ],
      usage: [
        'Schlüssel-Tab: RSA-Schlüsselpaare mit verschlüsselten privaten Schlüsseln generieren. Schlüssellänge und Passphrase festlegen.',
        'CSRs-Tab: Certificate Signing Requests erstellen. Privaten Schlüssel einfügen, Subjektdetails eingeben und CSR generieren.',
        'CSR lesen-Tab: Bestehende CSRs analysieren, um Subjektinformationen und öffentlichen Schlüssel anzuzeigen.',
        'Selbstsigniert-Tab: Selbstsignierte Zertifikate für Tests generieren. Gültigkeitsdauer, Seriennummer und Subjektdetails festlegen.',
        'Zertifikat lesen-Tab: X.509-Zertifikate analysieren, um Aussteller, Subjekt, Gültigkeitsdaten, Erweiterungen und öffentlichen Schlüssel anzuzeigen.',
      ],
    },
  },
};
