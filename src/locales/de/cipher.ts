// German translations - Cipher tools
export default {
  cipher: {
    title: 'AES-Verschlüsselung/Entschlüsselung',
    description: 'Daten mit dem AES-Algorithmus in verschiedenen Modi verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsseltes Ergebnis',
    decryptResult: 'Entschlüsseltes Ergebnis',
    aesInfo: 'AES-Informationen',
    keyLengthInfo: 'Die Schlüssellänge muss mit dem gewählten Algorithmus übereinstimmen',
    ivInfo: 'IV (Initialisierungsvektor) muss 16 Bytes lang sein',
    paddingInfo: 'Verwendet PKCS7-Padding',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} betragen',
    errorDataRequired: 'Daten sind erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes betragen',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für den ECB/KCV-Modus nicht erforderlich',
    kcvInfo: 'KCV: Nullen verschlüsseln und die ersten 6 Hex-Zeichen nehmen',
    calculateKcv: 'KCV berechnen',
    noPaddingInfo: 'Kein Padding - Datenlänge muss ein Vielfaches von 16 Bytes sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 16 Bytes sein',
    kcvNoDataNeeded: 'Für die KCV-Berechnung werden keine Daten benötigt',
    kcvDataHint: 'KCV wird mit Nullen berechnet, keine Dateneingabe erforderlich',
    errorKcvCalculation: 'KCV-Berechnung fehlgeschlagen',
    kcvResult: 'KCV-Ergebnis',
  },

  des: {
    title: 'DES / 3DES-Verschlüsselung/Entschlüsselung',
    description: 'Daten mit DES- oder 3DES-Algorithmus unter Verwendung verschiedener Modi und Padding verschlüsseln und entschlüsseln',
    algorithm: 'Algorithmus',
    mode: 'Modus',
    dataInput: 'Dateneingabe',
    hexadecimal: 'Hexadezimal',
    padding: 'Padding',
    key: 'Schlüssel',
    data: 'Daten',
    hexChars: 'Hex-Zeichen',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    dataPlaceholderAscii: 'ASCII-Text eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    encryptResult: 'Verschlüsseltes Ergebnis',
    decryptResult: 'Entschlüsseltes Ergebnis',
    desInfo: 'DES/3DES-Informationen',
    keyLengthInfoDes: 'DES erfordert einen 8-Byte (64-Bit) Schlüssel',
    keyLengthInfo3Des: '3DES erfordert einen 16- oder 24-Byte Schlüssel',
    ivInfo: 'IV (Initialisierungsvektor) muss 8 Bytes lang sein',
    blockSizeInfo: 'Blockgröße beträgt 8 Bytes',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLengthDes: 'DES-Schlüssellänge muss 8 Bytes betragen',
    errorKeyLength3Des: '3DES-Schlüssellänge muss 16 oder 24 Bytes betragen',
    errorDataRequired: 'Daten sind erforderlich',
    errorInvalidDataHex: 'Daten müssen gültiges Hexadezimal sein',
    errorDataLength: 'Datenlänge muss ein Vielfaches von 8 Bytes sein, wenn kein Padding verwendet wird',
    errorInvalidIvHex: 'IV muss gültiges Hexadezimal sein',
    errorIvLength: 'IV-Länge muss {length} Bytes betragen',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorInvalidCiphertext: 'Chiffretext muss gültiges Hexadezimal sein',
    ivNotRequired: 'IV ist für den ECB-Modus nicht erforderlich',
    paddingNone: 'Kein Padding',
    paddingZeros: 'Mit 0x00 auffüllen',
    paddingSpaces: 'Mit Leerzeichen 0x20 auffüllen',
    paddingANSIX923: 'Letztes Byte ist Padding-Länge, der Rest mit 0x00 gefüllt',
    paddingISO10126: 'Letztes Byte ist Padding-Länge, der Rest mit zufälligen Bytes gefüllt',
    paddingPKCS5: 'Jeder Padding-Byte-Wert entspricht der Padding-Länge',
    paddingPKCS7: 'Wie PKCS#5',
    paddingISO7816: '0x80 hinzufügen, dann mit 0x00 auffüllen',
    paddingRijndael: 'Wie Zero-Padding',
    paddingISO9797M1: 'Mit 0x00 bis zur Blockgröße auffüllen',
    paddingISO9797M2: 'Wie ISO 7816-4',
    mode8BitNote: 'Hinweis: Der 8-Bit-Modus verarbeitet jeweils 1 Byte',
    mode64BitNote: 'Der 64-Bit-Modus verarbeitet jeweils einen ganzen Block (8 Bytes)',
  },

  rsa: {
    title: 'RSA-Verschlüsselung/Entschlüsselung',
    description: 'Asymmetrische RSA-Verschlüsselung, Entschlüsselung, Signatur und Verifizierung',
    rsaInfo: 'RSA-Informationen',
    rsaInfo1: 'RSA ist ein asymmetrischer kryptografischer Algorithmus',
    rsaInfo2: 'Schlüsselgrößen: 1024, 2048, 4096 Bit (2048+ empfohlen)',
    rsaInfo3: 'PKCS#1 v1.5 und OAEP-Padding werden unterstützt',
    tabKeys: 'Schlüssel',
    tabEncrypt: 'Verschlüsseln',
    tabDecrypt: 'Entschlüsseln',
    tabSign: 'Signieren',
    tabVerify: 'Verifizieren',
    tabOAEP: 'OAEP',
    modulusPlaceholder: 'RSA-Modulus in Hexadezimal',
    privateExpPlaceholder: 'RSA privater Exponent in Hexadezimal',
    keyLength: 'Schlüssellänge',
    generateKeys: 'Schlüssel generieren',
    importKeys: 'Schlüssel importieren',
    clearKeys: 'Leeren',
    keyGenerated: 'Schlüsselpaar erfolgreich generiert',
    keysCleared: 'Schlüssel gelöscht',
    keyImported: 'Öffentlicher Schlüssel erfolgreich importiert',
    privateKeyImportNote: 'Import des privaten Schlüssels erfordert vollständige CRT-Parameter. Verwenden Sie "Schlüssel generieren" für volle Funktionalität.',
    padding: 'Padding',
    hashAlgorithm: 'Hash-Algorithmus',
    data: 'Daten',
    dataToEncrypt: 'Zu verschlüsselnde Daten',
    dataPlaceholderAscii: 'Textdaten eingeben',
    encodingMethod: 'Kodierungsmethode',
    private: 'Privat',
    public: 'Öffentlich',
    inputDataFormat: 'Eingabedatenformat',
    hexadecimal: 'Hexadezimal',
    paddingMethod: 'Padding-Methode',
    noPadding: 'Kein Padding',
    errorDataRequired: 'Daten sind erforderlich',
    privateEncryptNote: 'Hinweis: Öffentlicher Schlüssel wird für Verschlüsselungsdemo verwendet',
    dataToSign: 'Zu signierende Daten',
    dataToVerify: 'Zu verifizierende Daten',
    ciphertextToDecrypt: 'Zu entschlüsselnder Chiffretext',
    signatureToVerify: 'Signatur',
    dataPlaceholder: 'Hexadezimale Daten eingeben',
    ciphertextPlaceholder: 'Verschlüsselte hexadezimale Daten eingeben',
    signaturePlaceholder: 'Signatur in Hexadezimal eingeben',
    encrypt: 'Verschlüsseln',
    decrypt: 'Entschlüsseln',
    sign: 'Signieren',
    verify: 'Verifizieren',
    encryptedResult: 'Verschlüsseltes Ergebnis',
    encryptionFinished: 'Datenverschlüsselung abgeschlossen',
    decryptionFinished: 'Datenentschlüsselung abgeschlossen',
    decodingMethod: 'Dekodierungsmethode',
    copyResult: 'Ergebnis kopieren',
    result: 'ERGEBNIS',
    decryptedResult: 'Entschlüsseltes Ergebnis',
    signatureResult: 'Signatur',
    signatureValid: '✓ Signatur ist gültig',
    signatureInvalid: '✗ Signatur ist ungültig',
    encryptInfo: 'RSA-Verschlüsselung',
    encryptDesc: 'Daten mit dem öffentlichen Schlüssel verschlüsseln. Die Datengröße ist durch die Schlüsselgröße begrenzt.',
    decryptInfo: 'RSA-Entschlüsselung',
    decryptDesc: 'Daten mit dem privaten Schlüssel entschlüsseln.',
    signInfo: 'RSA-Signatur',
    signDesc: 'Daten mit dem privaten Schlüssel signieren (RSA-PSS).',
    verifyInfo: 'RSA-Signaturprüfung',
    verifyDesc: 'Signatur mit dem öffentlichen Schlüssel verifizieren (RSA-PSS).',
    oaepDesc1: 'OAEP ist ein Padding-Schema, das bei der RSA-Verschlüsselung verwendet wird',
    oaepDesc2: 'Sicherer als PKCS#1 v1.5-Padding',
    oaepDesc3: 'Verhindert Angriffe mit gewähltem Geheimtext (Chosen-Ciphertext-Attacks)',
    oaepDesc4: 'Für neue Anwendungen empfohlen',
    oaepStructure: 'OAEP-Struktur',
    maxDataSize: 'Maximale Datengröße',
    errorKeyGen: 'Schlüsselgenerierung fehlgeschlagen',
    errorKeyImport: 'Schlüsselimport fehlgeschlagen',
    errorInvalidModulus: 'Ungültiger Modulus',
    errorInvalidPublicExp: 'Ungültiger öffentlicher Exponent',
    errorNoPublicKey: 'Bitte generieren oder importieren Sie zuerst einen öffentlichen Schlüssel',
    errorNoPrivateKey: 'Bitte generieren Sie zuerst ein Schlüsselpaar (privater Schlüssel erforderlich)',
    errorInvalidData: 'Ungültige Daten (müssen hexadezimal sein)',
    errorInvalidCiphertext: 'Ungültiger Chiffretext (muss hexadezimal sein)',
    errorInvalidSignature: 'Ungültige Signatur (muss hexadezimal sein)',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    errorSign: 'Signieren fehlgeschlagen',
    errorVerify: 'Verifizierung fehlgeschlagen',
  },

  ecc: {
    title: 'ECC (ECDSA)',
    description: 'Elliptische-Kurven-Kryptografie - Digitaler Signaturalgorithmus',
    infoTitle: 'Über ECC/ECDSA',
    infoContent1: 'Elliptische-Kurven-Kryptografie bietet starke Sicherheit bei kleineren Schlüssellängen',
    infoContent2: 'Unterstützt P-256, P-384, P-521 Kurven für digitale Signaturen',
    infoContent3: 'ECDSA-Signaturen können Datenauthentizität und -integrität verifizieren',
    // Tabs
    tabKeys: 'Schlüssel',
    tabSign: 'Signieren',
    tabVerify: 'Verifizieren',
    // Keys tab
    curveName: 'ECC-Kurvenname:',
    privateKey: 'Privater Schlüssel:',
    publicKey: 'Öffentlicher Schlüssel:',
    publicKeyForm: 'Format des öffentlichen Schlüssels:',
    privateKeyPlaceholder: 'Privater Schlüssel (Hexadezimal)',
    publicKeyPlaceholder: 'Öffentlicher Schlüssel (Hexadezimal, unkomprimiertes Format: 04 || X || Y)',
    generateKeys: 'Schlüssel generieren',
    importKeys: 'Schlüssel importieren',
    clear: 'Leeren',
    keyGenerated: 'ECC-Schlüsselpaar erfolgreich generiert',
    keysImported: 'Schlüssel erfolgreich importiert',
    keysCleared: 'Schlüssel gelöscht',
    privateKeyImportFailed: 'Import des privaten Schlüssels fehlgeschlagen, nur öffentlicher Schlüssel importiert',
    // Sign tab
    data: 'Daten:',
    dataToSign: 'Zu signierende Daten:',
    inputDataFormat: 'Eingabedatenformat:',
    hashAlgorithm: 'Hash-Algorithmus:',
    sign: 'Signieren',
    signatureResult: '✓ ECDSA-Signaturergebnis',
    copyDER: 'DER kopieren',
    dataLabel: 'Daten:',
    dataSize: 'Datengröße:',
    hashAlgorithmLabel: 'Hash-Algorithmus:',
    ecName: 'EC-Name:',
    keyConversionForm: 'Schlüsselkonvertierungsformat:',
    messageDigest: 'Message Digest:',
    messageDigestSize: 'Message Digest Größe:',
    signatureR: 'Signatur->r:',
    signatureS: 'Signatur->s:',
    signatureDER: 'Signatur (DER):',
    // Verify tab
    dataToVerify: 'Zu verifizierende Daten:',
    signatureHex: 'Signatur (Hex):',
    signaturePlaceholder: 'Signatur in Hexadezimal eingeben (r || s Format)',
    verify: 'Verifizieren',
    signatureValid: '✓ Signatur ist gültig',
    signatureInvalid: '✗ Signatur ist ungültig',
    // Placeholders
    dataPlaceholderAscii: 'Textdaten eingeben',
    dataPlaceholderHex: 'Hexadezimale Daten eingeben',
    // Errors
    errorKeyGen: 'Schlüsselgenerierung fehlgeschlagen',
    errorKeyImport: 'Schlüsselimport fehlgeschlagen',
    errorInvalidPublicKey: 'Ungültiger öffentlicher Schlüssel (muss hexadezimal sein)',
    errorInvalidPublicKeyFormat: 'Ungültiges Format des öffentlichen Schlüssels. Erwartet {size} Bytes, beginnend mit 04',
    errorNoPrivateKey: 'Bitte generieren oder importieren Sie zuerst einen privaten Schlüssel',
    errorNoPublicKey: 'Bitte generieren oder importieren Sie zuerst einen öffentlichen Schlüssel',
    errorDataRequired: 'Daten sind erforderlich',
    errorInvalidData: 'Ungültige Daten (müssen hexadezimal sein)',
    errorInvalidSignature: 'Ungültige Signatur (muss hexadezimal sein)',
    errorSign: 'Signieren fehlgeschlagen',
    errorVerify: 'Verifizierung fehlgeschlagen',
  },

  fpe: {
    title: 'Formaterhaltende Verschlüsselung (FPE)',
    description: 'Daten unter Beibehaltung von Format und Länge verschlüsseln (NIST SP 800-38G)',
    radix: 'Radix',
    encryptionType: 'Verschlüsselungstyp',
    keyInput: 'Schlüsseleingabe',
    useTweak: 'Tweak verwenden?',
    fpeInfo: 'FPE-Informationen',
    formatPreserving: 'Formaterhaltend: Ausgabe hat das gleiche Format und die gleiche Länge wie die Eingabe',
    radixInfo: 'Aktueller Radix definiert den gültigen Zeichensatz für Daten',
    tweakInfo: 'Tweak bietet zusätzliche Eingabe für die Verschlüsselung (wie ein IV)',
    minLength: 'Minimale Datenlänge: 2 Zeichen',
    dataPlaceholder: 'Daten mit gültigen Radix-Zeichen eingeben',
    tweakPlaceholderFF1: 'Tweak in Hexadezimal eingeben (beliebige Länge)',
    tweakPlaceholderFF3: '16 Hex-Zeichen (8 Bytes)',
    resultLength: 'Länge',
    characters: 'Zeichen',
    algorithm: 'Algorithmus',
    errorInvalidKeyHex: 'Schlüssel muss gültiges Hexadezimal sein',
    errorKeyLength: 'Schlüssellänge muss {length} Bytes für {algorithm} betragen',
    errorDataRequired: 'Daten sind erforderlich',
    errorDataTooShort: 'Daten müssen mindestens 2 Zeichen lang sein',
    errorInvalidDataForRadix: 'Daten enthalten ungültige Zeichen für Radix {radix}',
    errorInvalidTweakHex: 'Tweak muss gültiges Hexadezimal sein',
    errorTweakLength: 'Tweak-Länge muss {length} Bytes für {algorithm} betragen',
    errorEncryption: 'Verschlüsselung fehlgeschlagen',
    errorDecryption: 'Entschlüsselung fehlgeschlagen',
    algorithmNotImplemented: 'Dieser Algorithmus ist noch nicht vollständig implementiert',
  },
};